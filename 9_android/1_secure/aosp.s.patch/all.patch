From c8f6808acd8cf85fcbd5cc55ce7c725b55184b0b Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Tue, 30 Aug 2022 00:14:44 +0800
Subject: [PATCH 1/5]  mobile data network ok

---
 system/netd/server/NetdNativeService.cpp      |  56 +++-
 system/netd/server/NetdNativeService.h        |   4 +
 system/netd/server/virt_net_config.h          |   1 +
 vendor/cells/cells/Android.mk                 |   1 +
 vendor/cells/cells/celld.c                    |   5 +
 vendor/cells/cells/nsexec.c                   |   3 +
 vendor/cells/cells/virt_net_config.h          | 240 ++++++++++++++++++
 vendor/cells/cells/virtual_network.c          | 158 ++++++++++++
 vendor/cells/cells/virtual_network.h          |   8 +
 vendor/cells/cellsservice/Android.mk          |  13 +
 .../cellsservice/CellsPrivateService.cpp      |  46 ++++
 .../cells/cellsservice/CellsPrivateService.h  |   1 +
 .../cellsservice/ICellsPrivateService.cpp     |  29 +++
 .../cells/cellsservice/ICellsPrivateService.h |   2 +
 vendor/cells/cellsservice/cell_cfg_net.cpp    |  42 +++
 vendor/cells/cellsservice/virt_net_config.h   |   1 +
 16 files changed, 608 insertions(+), 2 deletions(-)
 create mode 120000 system/netd/server/virt_net_config.h
 create mode 100644 vendor/cells/cells/virt_net_config.h
 create mode 100644 vendor/cells/cells/virtual_network.c
 create mode 100644 vendor/cells/cells/virtual_network.h
 create mode 100755 vendor/cells/cellsservice/cell_cfg_net.cpp
 create mode 120000 vendor/cells/cellsservice/virt_net_config.h

diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
index 1f5dc97612..85359f5e4e 100644
--- a/system/netd/server/NetdNativeService.cpp
+++ b/system/netd/server/NetdNativeService.cpp
@@ -49,6 +49,7 @@
 #include "binder_utils/BinderUtil.h"
 #include "binder_utils/NetdPermissions.h"
 #include "netid_client.h"  // NETID_UNSET
+#include "virt_net_config.h"
 
 using android::base::StringPrintf;
 using android::base::WriteStringToFile;
@@ -170,6 +171,24 @@ bool contains(const Vector<String16>& words, const String16& word) {
 
 }  // namespace
 
+int NetdNativeService::CallHostNetworkAddRouteParcel(int sysId, const RouteInfoParcel& route) {
+    char cmd[MAX_CMD_LEN];
+
+    if (route.nextHop.empty()) {
+        snprintf(cmd, sizeof(cmd), "cell_cfg_net %d %s %s",
+            sysId, route.ifName.c_str(),
+            route.destination.c_str());
+    } else {
+        snprintf(cmd, sizeof(cmd), "cell_cfg_net %d %s %s %s",
+            sysId, route.ifName.c_str(),
+            route.destination.c_str(),
+            route.nextHop.c_str());
+    }
+
+    system(cmd);  // NOLINT(cert-env33-c)
+    return 0;
+}
+
 NetdNativeService::NetdNativeService() {
     // register log callback to BnNetd::logFunc
     BnNetd::logFunc = [](const auto& log) {
@@ -1025,17 +1044,50 @@ binder::Status NetdNativeService::tetherDnsList(std::vector<std::string>* dnsLis
     return binder::Status::ok();
 }
 
+static int get_sys_id()
+{
+    char prop_value[PROP_VALUE_MAX] = {0};
+    int sys_id = -1; //host
+
+    if (__system_property_get("ro.boot.vm.name", prop_value) > 0) {
+        if (0 == strncmp("cell1", prop_value, strlen("cell1"))) {
+            sys_id = 0;
+        } else if (0 == strncmp("cell2", prop_value, strlen("cell2"))) {
+            sys_id = 1;
+        }
+    }
+    return sys_id;
+}
+
 binder::Status NetdNativeService::networkAddRouteParcel(int32_t netId,
                                                         const RouteInfoParcel& route) {
     // Public methods of NetworkController are thread-safe.
     ENFORCE_NETWORK_STACK_PERMISSIONS();
     bool legacy = false;
     uid_t uid = 0;  // UID is only meaningful for legacy routes.
+    int sys_id = get_sys_id();
+    const char *gw = nullptr;
+    char cmd[MAX_CMD_LEN];
+
+    if (-1 != sys_id) {
+        //cells
+        //config vnet ip
+        snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",
+            route.ifName.c_str(),
+            get_vnet_ip(sys_id, route.ifName.c_str()),
+            get_vnet_mask(sys_id, route.ifName.c_str()));
+        system(cmd);  // NOLINT(cert-env33-c)
+        //config host route
+        CallHostNetworkAddRouteParcel(sys_id, route);
+        //map gw
+        gw = get_vnet_gw(sys_id, route.ifName.c_str());
+    } else {
+        gw = route.nextHop.empty() ? nullptr : route.nextHop.c_str();
+    }
 
     // convert Parcel to parameters
     int res = gCtls->netCtrl.addRoute(netId, route.ifName.c_str(), route.destination.c_str(),
-                                      route.nextHop.empty() ? nullptr : route.nextHop.c_str(),
-                                      legacy, uid, route.mtu);
+                                      gw, legacy, uid, route.mtu);
     return statusFromErrcode(res);
 }
 
diff --git a/system/netd/server/NetdNativeService.h b/system/netd/server/NetdNativeService.h
index 9779f3680a..43eb842e87 100644
--- a/system/netd/server/NetdNativeService.h
+++ b/system/netd/server/NetdNativeService.h
@@ -24,6 +24,8 @@
 
 #include "android/net/BnNetd.h"
 
+#define NETD_SERVICE
+
 namespace android {
 namespace net {
 
@@ -80,6 +82,8 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
             const netd::aidl::NativeUidRangeConfig& uidRangesConfig) override;
     binder::Status networkRejectNonSecureVpn(bool enable,
                                              const std::vector<UidRangeParcel>& uids) override;
+    //op: 0--add 1--update 2--remove
+    int CallHostNetworkAddRouteParcel(int sysid, const RouteInfoParcel& route);
     binder::Status networkAddRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
     binder::Status networkUpdateRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
     binder::Status networkRemoveRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
diff --git a/system/netd/server/virt_net_config.h b/system/netd/server/virt_net_config.h
new file mode 120000
index 0000000000..c17fbce5ad
--- /dev/null
+++ b/system/netd/server/virt_net_config.h
@@ -0,0 +1 @@
+../../../vendor/cells/cells/virt_net_config.h
\ No newline at end of file
diff --git a/vendor/cells/cells/Android.mk b/vendor/cells/cells/Android.mk
index 93321f0c88..49596da697 100755
--- a/vendor/cells/cells/Android.mk
+++ b/vendor/cells/cells/Android.mk
@@ -42,6 +42,7 @@ LOCAL_SRC_FILES:= \
 	network.c \
 	cellnet.c \
 	array.c \
+	virtual_network.c
 
 LOCAL_MODULE := celld
 LOCAL_MODULE_TAGS := optional
diff --git a/vendor/cells/cells/celld.c b/vendor/cells/cells/celld.c
index 4fe4eac858..588c0cee89 100755
--- a/vendor/cells/cells/celld.c
+++ b/vendor/cells/cells/celld.c
@@ -62,6 +62,8 @@
 #include "nsexec.h"
 #include "util.h"
 
+#include "virtual_network.h"
+
 #define CELLS_MAX_CONTEXT 6
 
 static void set_properties_cells(char *name,char* v)
@@ -2684,6 +2686,9 @@ static void celld_main(void)
 	socklen_t addr_len;
 	pthread_t tid;
 
+	//gwb add for host vnet init
+	onHostStart();
+
 	sd = socket(AF_UNIX, SOCK_STREAM, 0);
 	if (sd == -1) {
 		ALOGE("socket() failed: %s", strerror(errno));
diff --git a/vendor/cells/cells/nsexec.c b/vendor/cells/cells/nsexec.c
index 83f6b41ce7..ffb6ffc6e4 100755
--- a/vendor/cells/cells/nsexec.c
+++ b/vendor/cells/cells/nsexec.c
@@ -54,6 +54,7 @@
 #include "util.h"
 #include "network.h"
 #include "cellnet.h"
+#include "virtual_network.h"
 
 #ifndef MNT_DETACH
 #define MNT_DETACH 2
@@ -645,6 +646,8 @@ static int do_clone(struct cell_args *cell_args)
 	if (gettimeofday(&cell_args->start_time, NULL) == -1)
 		ALOGE("%s: gettimeofday failed: %s", __func__, strerror(errno));
 
+	//gwb add for virt net
+	onVsysStart(cell_args->cellname, pid);
 	/*
 	 * Put the new process in a cgroup if requested.
 	 * Note that the child will block until we release it with a write
diff --git a/vendor/cells/cells/virt_net_config.h b/vendor/cells/cells/virt_net_config.h
new file mode 100644
index 0000000000..01785566ca
--- /dev/null
+++ b/vendor/cells/cells/virt_net_config.h
@@ -0,0 +1,240 @@
+#ifndef _VIRT_NET_CONFIG_H_
+#define _VIRT_NET_CONFIG_H_
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+/***********************************虚拟网络相关定义*******************************/
+
+#define MAX_SYS_NUM 2
+#define MAX_VETH_NAME_LEN (30)
+#define MAX_PATH_LEN (256)
+#define MAX_CMD_LEN (256)
+#define BIT(n)  (1 << (n))
+
+#define NET_RICH_ENABLE   BIT(0)
+#define NET_SAFE_ENABLE   BIT(1)
+#define NET_BOTH_ENABLE (NET_RICH_ENABLE | NET_SAFE_ENABLE)
+
+#define VNET_FWMARK_BASE    0xFF001
+#define VNET_HOST_RT_BASE     6001
+#define VNET_RT_BASE     5001
+#define VNET_RT_RULE_PRIO_BASE 5001
+
+#define VETH_TMP_SUFFIX "_tmp"
+
+typedef unsigned int uint32_t;
+typedef int int32_t;
+
+typedef struct _vsys_net_t {
+    const char *virt_name;
+    const char *host_ip;
+    const char *local_ip;
+    const char *mask;
+    uint32_t fwmark;
+    int32_t rt_id;
+    uint32_t rl_prio;
+} vsys_net_t;
+
+typedef struct _virtual_net_t {
+    const char *ifname;
+    uint32_t flag; //标识网络有效域：NET_RICH_ENABLE、NET_SAFE_ENABLE
+    int32_t host_rt;
+    vsys_net_t vnet_info[MAX_SYS_NUM];
+} virtual_net_t;
+
+#define DEFINE_VSYS_NET(vname, hip, lip, mask, idx) {(vname), (hip), (lip), mask, VNET_FWMARK_BASE+(idx), VNET_RT_BASE+(idx), VNET_RT_RULE_PRIO_BASE+(idx)}
+
+
+#define DEFINE_VIRTUAL_NET(ifname, flag, host_rt, vsys1, vsys2) \
+    {(ifname), (flag), (host_rt + VNET_HOST_RT_BASE), {vsys1, vsys2}}
+
+/********************************************************************************************************/
+
+//后续考虑采用配置文件的形式，方便移植和业务隐藏
+static virtual_net_t g_virt_net[] = {
+    DEFINE_VIRTUAL_NET("rmnet0", NET_BOTH_ENABLE, 0, 
+        DEFINE_VSYS_NET("rmnet0_v1", "172.20.202.5", "172.20.202.6",  "255.255.255.252", 0),
+        DEFINE_VSYS_NET("rmnet0_v2", "172.20.202.9", "172.20.202.10", "255.255.255.252", 1)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet1", NET_BOTH_ENABLE, 1,
+        DEFINE_VSYS_NET("rmnet1_v1", "172.20.202.13", "172.20.202.14", "255.255.255.252", 2),
+        DEFINE_VSYS_NET("rmnet1_v2", "172.20.202.17", "172.20.202.18", "255.255.255.252", 3)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet2", NET_BOTH_ENABLE, 2,
+        DEFINE_VSYS_NET("rmnet2_v1", "172.20.202.21", "172.20.202.22", "255.255.255.252", 4),
+        DEFINE_VSYS_NET("rmnet2_v2", "172.20.202.25", "172.20.202.26", "255.255.255.252", 5)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet3", NET_BOTH_ENABLE, 3,
+        DEFINE_VSYS_NET("rmnet3_v1", "172.20.202.29", "172.20.202.30", "255.255.255.252", 6),
+        DEFINE_VSYS_NET("rmnet3_v2", "172.20.202.33", "172.20.202.34", "255.255.255.252", 7)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet4", NET_BOTH_ENABLE, 4,
+        DEFINE_VSYS_NET("rmnet4_v1", "172.20.202.37", "172.20.202.38", "255.255.255.252", 8),
+        DEFINE_VSYS_NET("rmnet4_v2", "172.20.202.41", "172.20.202.42", "255.255.255.252", 9)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet5", NET_BOTH_ENABLE, 5,
+        DEFINE_VSYS_NET("rmnet5_v1", "172.20.202.45", "172.20.202.46", "255.255.255.252", 10),
+        DEFINE_VSYS_NET("rmnet5_v2", "172.20.202.49", "172.20.202.50", "255.255.255.252", 11)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet6", NET_BOTH_ENABLE, 6,
+        DEFINE_VSYS_NET("rmnet6_v1", "172.20.202.53", "172.20.202.54", "255.255.255.252", 12),
+        DEFINE_VSYS_NET("rmnet6_v2", "172.20.202.57", "172.20.202.58", "255.255.255.252", 13)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet7", NET_BOTH_ENABLE, 7,
+        DEFINE_VSYS_NET("rmnet7_v1", "172.20.202.61", "172.20.202.62", "255.255.255.252", 14),
+        DEFINE_VSYS_NET("rmnet7_v2", "172.20.202.65", "172.20.202.66", "255.255.255.252", 15)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet8", NET_BOTH_ENABLE, 8,
+        DEFINE_VSYS_NET("rmnet8_v1", "172.20.202.69", "172.20.202.70", "255.255.255.252", 16),
+        DEFINE_VSYS_NET("rmnet8_v2", "172.20.202.73", "172.20.202.74", "255.255.255.252", 17)
+    ),
+    DEFINE_VIRTUAL_NET(NULL, NET_BOTH_ENABLE, -1,
+        DEFINE_VSYS_NET(NULL, NULL, NULL, NULL, 0),
+        DEFINE_VSYS_NET(NULL, NULL, NULL, NULL, 0)
+    ),
+};
+
+static virtual_net_t *get_vnet(const char *ifname)
+{
+    virtual_net_t *vnet = NULL;
+
+    if (NULL == ifname) {
+        return NULL;
+    }
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        if (0 == strcmp(ifname, vnet->ifname)) {
+            return vnet;
+        }
+    }
+
+    return NULL;
+}
+
+static vsys_net_t *get_vnet_info(int sys, const char *ifname)
+{
+    virtual_net_t *vnet = NULL;
+
+    if (sys < 0 || sys >= MAX_SYS_NUM || NULL == ifname) {
+        return NULL;
+    }
+
+    vnet = get_vnet(ifname);
+    if (NULL == vnet) {
+        return NULL;
+    }
+
+    return &vnet->vnet_info[sys];
+}
+
+static const char *get_vnet_ip(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->local_ip;
+    }
+
+    return NULL;
+}
+
+#if 0
+static inline void ip_mask_to_segment(const char *ip, int mask, char *segment)
+{
+    int ip_int = 0;
+    unsigned char *p = (unsigned char *)&ip_int;
+	inet_pton(AF_INET, ip, &ip_int);
+    p[3] = p[3] - 1;
+    sprintf(segment, "%d.%d.%d.%d/%d", p[0], p[1], p[2], p[3], mask);
+}
+
+//返回类似172.20.202.4/30网段地址---不需要，虚拟系统添加main表路由后也可自动获取
+static int get_vnet_segment(int sys, const char *ifname, char *segment)
+{
+
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL == p) {
+        return -1;
+    }
+
+    ip_mask_to_segment(p->host_ip, 30, segment);
+
+
+    return 0;
+}
+#endif
+
+static const char *get_vnet_mask(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->mask;
+    }
+
+    return NULL;
+}
+
+static const char *get_vnet_gw(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->host_ip;
+    }
+
+    return NULL;
+}
+
+
+
+#ifndef NETD_SERVICE
+static int32_t get_vnet_rt_table(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return (int32_t)p->rt_id;
+    }
+
+    return -1;
+}
+
+static int32_t get_vnet_netid(int sys, const char *ifname)
+{
+    return get_vnet_rt_table(sys, ifname);
+}
+
+static virtual_net_t *get_vnet_info_by_netid(int net_id, int *sysId)
+{
+    virtual_net_t *vnet = NULL;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        if (net_id == vnet->vnet_info[0].rt_id) {
+            *sysId = 0;
+            return vnet;
+        }
+
+        if (net_id == vnet->vnet_info[1].rt_id) {
+            *sysId = 1;
+            return vnet;
+        }
+    }
+
+    return NULL;
+}
+
+
+static int32_t get_host_rt_table(const char *ifname)
+{
+    virtual_net_t *p = get_vnet(ifname);
+    if (NULL != p) {
+        return p->host_rt;
+    }
+
+    return -1;
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/vendor/cells/cells/virtual_network.c b/vendor/cells/cells/virtual_network.c
new file mode 100644
index 0000000000..608311df9e
--- /dev/null
+++ b/vendor/cells/cells/virtual_network.c
@@ -0,0 +1,158 @@
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include "network.h"
+#include "virt_net_config.h"
+#include "virtual_network.h"
+
+#define LOG_TAG "VIRTNET"
+#include <cutils/log.h>
+
+#define VNET_ERR ALOGE
+
+static int create_vnet(virtual_net_t *vnet, int sys)
+{
+    int ret = 0;
+
+    if (NULL == vnet || sys >= MAX_SYS_NUM) {
+        return -1;
+    }
+
+    const char *name1 = vnet->vnet_info[sys].virt_name;
+    char name2[MAX_VETH_NAME_LEN];
+
+    if (sizeof(name2) <= snprintf(name2, sizeof(name2), "%s%s", name1, VETH_TMP_SUFFIX)) {
+        VNET_ERR("[create_vnet] name=%s is out of bonds!\n", name1);
+        ret |= (1 << sys);
+    }
+
+    if (0 != veth_peer_create(name1, name2)) {
+        VNET_ERR("[create_vnet] veth_peer_create(%s, %s) Fail!\n", name1, name2);
+        ret |= (2 << sys);
+    } 
+
+    return ret;
+}
+
+int create_vnet_all(int sys)
+{
+    int ret = 0;
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        ret |= create_vnet(&g_virt_net[i], sys);
+    }
+    return ret;
+}
+
+int config_vnet_host_all(int sys)
+{
+    int ret = 0;
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = NULL;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        //配置IP
+        snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up", 
+            vnet->vnet_info[sys].virt_name,
+            vnet->vnet_info[sys].host_ip,
+            vnet->vnet_info[sys].mask);
+        system(cmd);
+    }
+    return ret;
+}
+
+int move_vnet_all(int sys, pid_t pid)
+{
+    const char *name1 = NULL;
+    char *name2[MAX_VETH_NAME_LEN];
+    virtual_net_t *vnet = NULL;
+    int ret = 0;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        name1 = vnet->vnet_info[sys].virt_name;
+        if (sizeof(name2) <= snprintf((char *)name2, sizeof(name2), "%s%s", name1, VETH_TMP_SUFFIX)) {
+            VNET_ERR("[create_vnet] name=%s is out of bonds!\n", name1);
+            ret |= (1 << sys);
+        }
+
+        ret |= netdev_move_to_netns((const char*)&name2, pid, vnet->ifname);
+    }
+    return ret;
+}
+
+int onHostStart()
+{
+    int ret = 0;
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = NULL;
+
+
+    system("iptables -t raw -F");
+    system("iptables -t mangle -F");
+    system("iptables -t filter -F");
+    system("iptables -t nat -F");
+
+    //AOSP上缺少main表规则
+    snprintf(cmd, sizeof(cmd), "ip rule add from all lookup main prio 31999");
+    system(cmd);
+
+    //静态配置，只需在host启动时执行一次即可-->后续可作为oneshot服务，在rc中启动一次即可
+    for (int sys = 0; sys < MAX_SYS_NUM; sys++) {
+        for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+            vnet = &g_virt_net[i];
+            //配置FWMARK
+            snprintf(cmd, sizeof(cmd), "iptables -t mangle -I PREROUTING -s %s/30 -j MARK --set-mark 0x%x", 
+                vnet->vnet_info[sys].host_ip,
+                vnet->vnet_info[sys].fwmark);
+            system(cmd);
+            //配置MASQUERADE
+            snprintf(cmd, sizeof(cmd), "iptables -t nat -I POSTROUTING -m mark --mark 0x%x -o %s -j MASQUERADE", 
+                vnet->vnet_info[sys].fwmark,
+                vnet->ifname);
+            system(cmd);
+            //配置rule
+  
+            if (0 == sys) {
+                snprintf(cmd, sizeof(cmd), "ip rule add from all iif lo oif %s lookup %d prio %d", 
+                        vnet->ifname,
+                        vnet->host_rt,
+                        vnet->vnet_info[sys].rl_prio);
+                system(cmd);
+            }
+
+            snprintf(cmd, sizeof(cmd), "ip rule add iif %s table %d prio %d", 
+                vnet->vnet_info[sys].virt_name,
+                vnet->vnet_info[sys].rt_id,
+                vnet->vnet_info[sys].rl_prio);
+            system(cmd);
+        }
+    }
+
+    return ret;
+}
+
+int onVsysStart(const char *sysname, pid_t pid)
+{
+    int ret = 0;
+    int sys = 0;
+
+    sscanf(sysname, "cell%d", &sys);
+
+    if (sys > MAX_SYS_NUM || sys < 1) {
+        VNET_ERR("[onVsysStart] sysname=%s is invalide!\n", sysname);
+    }
+    sys -= 1;
+
+    ret = create_vnet_all(sys);
+    ret |= config_vnet_host_all(sys);
+    ret |= move_vnet_all(sys, pid);
+
+    return ret;
+}
+
+
diff --git a/vendor/cells/cells/virtual_network.h b/vendor/cells/cells/virtual_network.h
new file mode 100644
index 0000000000..12584bc39f
--- /dev/null
+++ b/vendor/cells/cells/virtual_network.h
@@ -0,0 +1,8 @@
+
+#ifndef _VIRTUAL_NETWORK_H_
+#define _VIRTUAL_NETWORK_H_
+
+extern int onVsysStart(const char *sysname, pid_t pid);
+extern int onHostStart();
+
+#endif
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/Android.mk b/vendor/cells/cellsservice/Android.mk
index 58fa006bc8..ae4b73406c 100755
--- a/vendor/cells/cellsservice/Android.mk
+++ b/vendor/cells/cellsservice/Android.mk
@@ -66,3 +66,16 @@ LOCAL_SHARED_LIBRARIES := libm libcutils libc libutils liblog
 include $(BUILD_EXECUTABLE)
 
 
+#cfg net
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	cell_cfg_net.cpp \
+	ICellsPrivateService.cpp
+
+LOCAL_MODULE:= cell_cfg_net
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := cells
+#LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
+LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils liblog
+include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/CellsPrivateService.cpp b/vendor/cells/cellsservice/CellsPrivateService.cpp
index 60a664df9b..6b25664673 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/CellsPrivateService.cpp
@@ -20,6 +20,7 @@
 
 #include <android/os/IPowerManager.h>
 #include <powermanager/PowerManager.h>
+#include "virt_net_config.h"
 
 namespace android {
 
@@ -431,6 +432,51 @@ status_t CellsPrivateService::sendCellsVM(const String16& path, const String16&
     return NO_ERROR;
 }
 
+std::string toStdString(const String16& s) {
+    return std::string(String8(s.string()));
+}
+
+
+static int cfg_host_rt(int32_t sysid, const char* ifName, const char* dest, const char* nexthop)
+{
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = get_vnet(ifName);
+    if (NULL == vnet) {
+        return -1;
+    }
+
+    //配置物理路由
+    if (strcmp("NONE", nexthop) == 0) {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s dev %s",
+            vnet->host_rt, dest, ifName);
+    } else {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s via %s dev %s",
+            vnet->host_rt, dest, nexthop, ifName);
+    }
+
+    ALOGD("cfg_host_rt %s", cmd);
+    system(cmd);
+
+    //配置虚拟网卡路由
+    if (strcmp("NONE", nexthop) == 0) {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s dev %s",
+            vnet->vnet_info[sysid].rt_id, dest, ifName);
+    } else {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s via %s dev %s",
+            vnet->vnet_info[sysid].rt_id, dest, nexthop, ifName);
+    }
+
+    ALOGD("cfg_host_rt %s", cmd);
+    system(cmd);
+    return 0;
+}
+
+status_t CellsPrivateService::cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop)
+{
+    cfg_host_rt(sysid, toStdString(ifName).c_str(), toStdString(dest).c_str(), toStdString(nexthop).c_str());
+    return NO_ERROR;
+}
+
 status_t CellsPrivateService::vmSystemReady(const String16& name)
 {
     char pname[PATH_MAX] = {0};
diff --git a/vendor/cells/cellsservice/CellsPrivateService.h b/vendor/cells/cellsservice/CellsPrivateService.h
index 87c7ec71ae..edcf3b5c9b 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.h
+++ b/vendor/cells/cellsservice/CellsPrivateService.h
@@ -38,6 +38,7 @@ public:
     virtual status_t tarCellsVM(const String16& name);
     virtual status_t vmSystemReady(const String16& name);
     virtual status_t sendCellsVM(const String16& path, const String16& address);
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop);
 
     int isInCellstar();
     void setCellstaring();
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.cpp b/vendor/cells/cellsservice/ICellsPrivateService.cpp
index 66c2c93e62..1a6ff6eb35 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/ICellsPrivateService.cpp
@@ -247,6 +247,23 @@ public:
         result = reply.readInt32();
         return result;
     }
+
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICellsPrivateService::getInterfaceDescriptor());
+        data.writeInt32(sysid);
+        data.writeString16(ifName);
+        data.writeString16(dest);
+        data.writeString16(nexthop);
+        status_t result = remote()->transact(CFG_NET_PROXY, data, &reply);
+        if (result != NO_ERROR) {
+            ALOGE("cfgNetProxy err!\n");
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
 };
 
 IMPLEMENT_META_INTERFACE(CellsPrivateService, "CellsPrivateService");
@@ -417,6 +434,18 @@ status_t BnCellsPrivateService::onTransact(uint32_t code, const Parcel& data, Pa
             return NO_ERROR;
         }
         break;
+        case CFG_NET_PROXY:
+        {
+            CHECK_INTERFACE(ICellsPrivateService, data, reply);
+            int32_t sys = data.readInt32();
+            String16 ifname = data.readString16();
+            String16 dest = data.readString16();
+            String16 nexthop = data.readString16();
+            status_t result = cfgNetProxy(sys, ifname, dest, nexthop);
+            reply->writeInt32(result);
+            return NO_ERROR;
+        }
+        break;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.h b/vendor/cells/cellsservice/ICellsPrivateService.h
index 49c2bc06fd..acc20322bf 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.h
+++ b/vendor/cells/cellsservice/ICellsPrivateService.h
@@ -31,6 +31,7 @@ protected:
         EXITCELL = IBinder::FIRST_CALL_TRANSACTION + 13,
         EXITHOST = IBinder::FIRST_CALL_TRANSACTION + 14,
         SENDCELLSVM = IBinder::FIRST_CALL_TRANSACTION + 15,
+        CFG_NET_PROXY = IBinder::FIRST_CALL_TRANSACTION + 16,
     };
 
 public:
@@ -52,6 +53,7 @@ public:
     virtual status_t tarCellsVM(const String16& name) = 0;
     virtual status_t vmSystemReady(const String16& name) = 0;
     virtual status_t sendCellsVM(const String16& path, const String16& address) = 0;
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop) = 0;
 };
 
 class BnCellsPrivateService : public BnInterface<ICellsPrivateService>
diff --git a/vendor/cells/cellsservice/cell_cfg_net.cpp b/vendor/cells/cellsservice/cell_cfg_net.cpp
new file mode 100755
index 0000000000..81a7285706
--- /dev/null
+++ b/vendor/cells/cellsservice/cell_cfg_net.cpp
@@ -0,0 +1,42 @@
+#define LOG_TAG "CELL_CFG_NET"
+
+#include <cutils/log.h>
+#include <binder/BinderService.h>
+#include "ICellsPrivateService.h"
+
+using namespace android;
+
+int main(int argc, char** argv)
+{
+    sp<ICellsPrivateService> pCellsPrivateService = NULL;
+    const sp<IServiceManager> sm = initdefaultServiceManager();
+    if (sm != NULL) {
+        sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
+        if (binder != NULL) {
+            pCellsPrivateService = interface_cast<ICellsPrivateService>(binder);
+        }
+    }
+
+    if(pCellsPrivateService == NULL) {
+        ALOGE("could not get service CellsPrivateService \n");
+        return 0;
+    }
+
+    if (argc < 4) {
+        ALOGE("use cell_cfg_net sysId ifName dest nexthop \n");
+    }
+
+    int sysId = atoi(argv[1]);
+    char *ifName = argv[2];
+    char *dest = argv[3];
+    char *nexthop = "NONE";
+
+    if (argc == 5) {
+        nexthop = argv[4];
+    }
+        
+    ALOGD("call cfgNetProxy(%d, %s, %s, %s)", sysId, ifName, dest, nexthop);
+    pCellsPrivateService->cfgNetProxy(sysId, android::String16(ifName), android::String16(dest), android::String16(nexthop));
+
+    return 0;
+}
diff --git a/vendor/cells/cellsservice/virt_net_config.h b/vendor/cells/cellsservice/virt_net_config.h
new file mode 120000
index 0000000000..675a0e999d
--- /dev/null
+++ b/vendor/cells/cellsservice/virt_net_config.h
@@ -0,0 +1 @@
+../cells/virt_net_config.h
\ No newline at end of file
-- 
2.17.1

From 2bd465950e5b7bfd0cd9f224977ee2b858efcaba Mon Sep 17 00:00:00 2001
From: jianglin <pppaass@163.com>
Date: Sun, 14 Aug 2022 10:16:23 +0800
Subject: [PATCH] virtuil-kernel-5.10.v1.0

---
 arch/arm64/configs/gki_defconfig  |   5 +-
 drivers/android/binder.c          | 195 +++++++++-
 drivers/android/binder_internal.h |  11 +
 drivers/android/binderfs.c        |  20 +-
 drivers/base/core.c               |  21 +-
 drivers/input/evdev.c             | 330 +++++++++++++++-
 include/linux/drv_namespace.h     | 227 +++++++++++
 include/linux/nsproxy.h           |  12 +
 init/Kconfig                      |   8 +
 kernel/Makefile                   |   1 +
 kernel/drv_namespace.c            | 600 ++++++++++++++++++++++++++++++
 kernel/nsproxy.c                  |  24 ++
 kernel/power/wakelock.c           |  17 +
 security/selinux/hooks.c          |   4 +-
 security/selinux/selinuxfs.c      |   2 +-
 15 files changed, 1464 insertions(+), 13 deletions(-)
 create mode 100755 include/linux/drv_namespace.h
 create mode 100755 kernel/drv_namespace.c

diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index 56d405007e96..457a097be2cb 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -1,3 +1,4 @@
+CONFIG_SYSVIPC=y
 CONFIG_AUDIT=y
 CONFIG_NO_HZ=y
 CONFIG_HIGH_RES_TIMERS=y
@@ -24,7 +25,8 @@ CONFIG_CPUSETS=y
 CONFIG_CGROUP_CPUACCT=y
 CONFIG_CGROUP_BPF=y
 CONFIG_NAMESPACES=y
-# CONFIG_PID_NS is not set
+CONFIG_USER_NS=y
+CONFIG_DRV_NS=y
 CONFIG_RT_SOFTINT_OPTIMIZATION=y
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
@@ -551,7 +553,6 @@ CONFIG_POWERCAP=y
 CONFIG_DTPM=y
 CONFIG_ANDROID=y
 CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_BINDERFS=y
 CONFIG_ANDROID_DEBUG_SYMBOLS=y
 CONFIG_ANDROID_VENDOR_HOOKS=y
 CONFIG_LIBNVDIMM=y
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 78f8cf0d6626..1dcd838d5c7e 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -77,6 +77,10 @@
 #include "binder_trace.h"
 #include <trace/hooks/binder.h>
 
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+
 static HLIST_HEAD(binder_deferred_list);
 static DEFINE_MUTEX(binder_deferred_lock);
 
@@ -196,6 +200,68 @@ static struct binder_transaction_log_entry *binder_transaction_log_add(
 	return e;
 }
 
+#ifdef CONFIG_DRV_NS
+
+struct binder_drv_ns {
+	struct drv_ns_info	drv_ns_info;
+};
+
+static void binder_ns_initialize(struct binder_drv_ns *binder_ns)
+{
+
+}
+
+/* binder_ns_id, get_binder_ns(), get_binder_ns_cur(), put_binder_ns() */
+DEFINE_DRV_NS_INFO(binder)
+
+static struct drv_ns_info *binder_ns_create(struct drv_namespace *drv_ns)
+{
+	struct binder_drv_ns *binder_ns;
+
+	binder_ns = kzalloc(sizeof(*binder_ns), GFP_KERNEL);
+	if (!binder_ns)
+		return ERR_PTR(-ENOMEM);
+
+	binder_ns_initialize(binder_ns);
+
+	return &binder_ns->drv_ns_info;
+}
+
+static void binder_ns_release(struct drv_ns_info *drv_ns_info)
+{
+	struct binder_drv_ns *binder_ns;
+
+	binder_ns = container_of(drv_ns_info, struct binder_drv_ns,
+				 drv_ns_info);
+	kfree(binder_ns);
+}
+
+static struct drv_ns_ops binder_ns_ops = {
+	.create = binder_ns_create,
+	.release = binder_ns_release,
+};
+
+#define INIT_OTHER_CONTEXT_MGR_HANDLE 100000000
+
+static inline int current_drv_ns_cell_index(void)
+{
+	char tag[DRV_NS_TAG_LEN];
+	int i = 0;
+
+	if(current_drv_ns() == &init_drv_ns)
+		return 0;
+
+	for(i = 1; i < MAX_CONTEXT; i++){
+		sprintf(tag, "cell%d", i);
+		if(strncmp(current_drv_ns()->tag, tag, DRV_NS_TAG_LEN) == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+#endif /* CONFIG_DRV_NS */
+
 enum binder_deferred_state {
 	BINDER_DEFERRED_FLUSH        = 0x01,
 	BINDER_DEFERRED_RELEASE      = 0x02,
@@ -891,6 +957,21 @@ static void binder_free_node(struct binder_node *node)
 	binder_stats_deleted(BINDER_STAT_NODE);
 }
 
+#ifdef CONFIG_DRV_NS
+static int mgr_node(struct binder_node *node)
+{
+	int i = 0;
+
+	for(i = 0; i < MAX_CONTEXT; i++)
+	{
+		if(node == node->proc->acontext[i]->binder_context_mgr_node)
+			return 1;
+	}
+
+	return 0;
+}
+#endif
+
 static int binder_inc_node_nilocked(struct binder_node *node, int strong,
 				    int internal,
 				    struct list_head *target_list)
@@ -904,9 +985,11 @@ static int binder_inc_node_nilocked(struct binder_node *node, int strong,
 		if (internal) {
 			if (target_list == NULL &&
 			    node->internal_strong_refs == 0 &&
-			    !(node->proc &&
-			      node == node->proc->context->binder_context_mgr_node &&
-			      node->has_strong_ref)) {
+#ifdef CONFIG_DRV_NS
+			    !(node->proc && mgr_node(node) && node->has_strong_ref)) {
+#else
+			    !(node->proc && node == node->proc->context->binder_context_mgr_node && node->has_strong_ref)) {
+#endif
 				pr_err("invalid inc strong node for %d\n",
 					node->debug_id);
 				return -EINVAL;
@@ -1150,6 +1233,9 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 	struct rb_node *parent = NULL;
 	struct binder_ref *ref;
 	struct rb_node *n;
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
 
 	while (*p) {
 		parent = *p;
@@ -1172,6 +1258,31 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 	rb_link_node(&new_ref->rb_node_node, parent, p);
 	rb_insert_color(&new_ref->rb_node_node, &proc->refs_by_node);
 
+#ifdef CONFIG_DRV_NS
+	new_ref->data.desc = 1;
+	for(i = 0; i < MAX_CONTEXT; i++)
+	{
+		if(node == proc->acontext[i]->binder_context_mgr_node){
+			new_ref->data.desc = INIT_OTHER_CONTEXT_MGR_HANDLE + i;
+			break;
+		}
+	}
+	if(node == context->binder_context_mgr_node)
+		new_ref->data.desc = 0;
+	if(new_ref->data.desc < INIT_OTHER_CONTEXT_MGR_HANDLE)
+	{
+		for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
+			ref = rb_entry(n, struct binder_ref, rb_node_desc);
+
+			if(ref->data.desc  >= INIT_OTHER_CONTEXT_MGR_HANDLE)
+				continue;
+
+			if (ref->data.desc > new_ref->data.desc)
+				break;
+			new_ref->data.desc = ref->data.desc + 1;
+		}
+	}
+#else
 	new_ref->data.desc = (node == context->binder_context_mgr_node) ? 0 : 1;
 	for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
 		ref = rb_entry(n, struct binder_ref, rb_node_desc);
@@ -1179,6 +1290,7 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 			break;
 		new_ref->data.desc = ref->data.desc + 1;
 	}
+#endif
 
 	p = &proc->refs_by_desc.rb_node;
 	while (*p) {
@@ -2679,7 +2791,29 @@ static void binder_transaction(struct binder_proc *proc,
 		binder_inner_proc_unlock(target_thread->proc);
 		trace_android_vh_binder_reply(target_proc, proc, thread, tr);
 	} else {
+#ifdef CONFIG_DRV_NS
+		if(tr->target.handle >= INIT_OTHER_CONTEXT_MGR_HANDLE){
+			mutex_lock(&proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			target_node = proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->binder_context_mgr_node;
+			if (target_node)
+				target_node = binder_get_node_refs_for_txn(
+						target_node, &target_proc,
+						&return_error);
+			else
+				return_error = BR_DEAD_REPLY;
+			mutex_unlock(&proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			if (target_node && target_proc->pid == proc->pid) {
+				binder_user_error("%d:%d got transaction to context manager from process owning it\n",
+						  proc->pid, thread->pid);
+				return_error = BR_FAILED_REPLY;
+				return_error_param = -EINVAL;
+				return_error_line = __LINE__;
+				goto err_invalid_target_handle;
+			}
+		}else if (tr->target.handle) {
+#else
 		if (tr->target.handle) {
+#endif
 			struct binder_ref *ref;
 
 			/*
@@ -2725,6 +2859,7 @@ static void binder_transaction(struct binder_proc *proc,
 			/*
 			 * return_error is set above
 			 */
+			binder_user_error("container:%d", tr->target.handle);
 			return_error_param = -EINVAL;
 			return_error_line = __LINE__;
 			goto err_dead_binder;
@@ -3423,7 +3558,21 @@ static int binder_thread_write(struct binder_proc *proc,
 
 			ptr += sizeof(uint32_t);
 			ret = -1;
+#ifdef CONFIG_DRV_NS
+			if (increment && target >= INIT_OTHER_CONTEXT_MGR_HANDLE) {
+				struct binder_node *ctx_mgr_node;
+				mutex_lock(&proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+				ctx_mgr_node = proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->binder_context_mgr_node;
+				if (ctx_mgr_node) {
+					ret = binder_inc_ref_for_node(
+							proc, ctx_mgr_node,
+							strong, NULL, &rdata);
+				}
+				mutex_unlock(&proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			} else if (increment && !target) {
+#else
 			if (increment && !target) {
+#endif
 				struct binder_node *ctx_mgr_node;
 				mutex_lock(&context->context_mgr_node_lock);
 				ctx_mgr_node = context->binder_context_mgr_node;
@@ -4501,7 +4650,11 @@ static void binder_free_proc(struct binder_proc *proc)
 	if (proc->outstanding_txns)
 		pr_warn("%s: Unexpected outstanding_txns %d\n",
 			__func__, proc->outstanding_txns);
+#ifdef CONFIG_DRV_NS
+	device = container_of(proc->context, struct binder_device, context[0]);
+#else
 	device = container_of(proc->context, struct binder_device, context);
+#endif
 	if (refcount_dec_and_test(&device->ref)) {
 		kfree(proc->context->name);
 		kfree(device);
@@ -5199,6 +5352,9 @@ static int binder_open(struct inode *nodp, struct file *filp)
 	struct binderfs_info *info;
 	struct dentry *binder_binderfs_dir_entry_proc = NULL;
 	bool existing_pid = false;
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
 
 	binder_debug(BINDER_DEBUG_OPEN_CLOSE, "%s: %d:%d\n", __func__,
 		     current->group_leader->pid, current->pid);
@@ -5232,7 +5388,21 @@ static int binder_open(struct inode *nodp, struct file *filp)
 					  struct binder_device, miscdev);
 	}
 	refcount_inc(&binder_dev->ref);
+#ifdef CONFIG_DRV_NS
+	for(i = 0; i < MAX_CONTEXT; i++){
+		proc->acontext[i] = &binder_dev->context[i];
+	}
+
+	i = current_drv_ns_cell_index();
+	if( i >= 0 && i < MAX_CONTEXT){
+		proc->context = proc->acontext[i];
+	}else{
+		proc->context = NULL;
+	}
+#else
 	proc->context = &binder_dev->context;
+#endif
+
 	binder_alloc_init(&proc->alloc);
 
 	binder_stats_created(BINDER_STAT_PROC);
@@ -6080,6 +6250,9 @@ static int __init init_binder_device(const char *name)
 {
 	int ret;
 	struct binder_device *binder_device;
+#ifdef CONFIG_DRV_NS
+	int i;
+#endif
 
 	binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL);
 	if (!binder_device)
@@ -6090,9 +6263,18 @@ static int __init init_binder_device(const char *name)
 	binder_device->miscdev.name = name;
 
 	refcount_set(&binder_device->ref, 1);
+#ifdef CONFIG_DRV_NS
+	for(i = 0; i < MAX_CONTEXT; i++){
+		binder_device->context[i].binder_context_mgr_uid = INVALID_UID;
+		binder_device->context[i].name = name;
+		binder_device->context[i].binder_context_mgr_node = NULL;
+		mutex_init(&binder_device->context[i].context_mgr_node_lock);
+	}
+#else
 	binder_device->context.binder_context_mgr_uid = INVALID_UID;
 	binder_device->context.name = name;
 	mutex_init(&binder_device->context.context_mgr_node_lock);
+#endif
 
 	ret = misc_register(&binder_device->miscdev);
 	if (ret < 0) {
@@ -6120,6 +6302,13 @@ static int __init binder_init(void)
 	atomic_set(&binder_transaction_log.cur, ~0U);
 	atomic_set(&binder_transaction_log_failed.cur, ~0U);
 
+#ifdef CONFIG_DRV_NS
+	ret = DRV_NS_REGISTER(binder, "binder");
+	if (ret < 0) {
+		return -ENOMEM;
+	}
+#endif
+
 	binder_debugfs_dir_entry_root = debugfs_create_dir("binder", NULL);
 	if (binder_debugfs_dir_entry_root)
 		binder_debugfs_dir_entry_proc = debugfs_create_dir("proc",
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index 93f02395b0d7..370daa99f9c1 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -15,6 +15,10 @@
 #include <uapi/linux/android/binderfs.h>
 #include "binder_alloc.h"
 
+#ifdef CONFIG_DRV_NS
+#define MAX_CONTEXT 6
+#endif
+
 struct binder_context {
 	struct binder_node *binder_context_mgr_node;
 	struct mutex context_mgr_node_lock;
@@ -34,7 +38,11 @@ struct binder_context {
 struct binder_device {
 	struct hlist_node hlist;
 	struct miscdevice miscdev;
+#ifdef CONFIG_DRV_NS
+	struct binder_context context[MAX_CONTEXT];
+#else
 	struct binder_context context;
+#endif
 	struct inode *binderfs_inode;
 	refcount_t ref;
 };
@@ -467,6 +475,9 @@ struct binder_proc {
 	struct dentry *debugfs_entry;
 	struct binder_alloc alloc;
 	struct binder_context *context;
+#ifdef CONFIG_DRV_NS
+	struct binder_context *acontext[MAX_CONTEXT];
+#endif
 	spinlock_t inner_lock;
 	spinlock_t outer_lock;
 	struct dentry *binderfs_entry;
diff --git a/drivers/android/binderfs.c b/drivers/android/binderfs.c
index 7b4f154f07e6..4a3a46c92d8f 100644
--- a/drivers/android/binderfs.c
+++ b/drivers/android/binderfs.c
@@ -117,6 +117,9 @@ static int binderfs_binder_device_create(struct inode *ref_inode,
 #else
 	bool use_reserve = true;
 #endif
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
 
 	/* Reserve new minor number for the new device. */
 	mutex_lock(&binderfs_minors_mutex);
@@ -160,11 +163,20 @@ static int binderfs_binder_device_create(struct inode *ref_inode,
 
 	refcount_set(&device->ref, 1);
 	device->binderfs_inode = inode;
-	device->context.binder_context_mgr_uid = INVALID_UID;
-	device->context.name = name;
 	device->miscdev.name = name;
 	device->miscdev.minor = minor;
+#ifdef CONFIG_DRV_NS
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		device->context[i].binder_context_mgr_uid = INVALID_UID;
+		device->context[i].name = name;
+		device->context[i].binder_context_mgr_node = NULL;
+		mutex_init(&device->context[i].context_mgr_node_lock);
+	}
+#else
+	device->context.binder_context_mgr_uid = INVALID_UID;
+	device->context.name = name;
 	mutex_init(&device->context.context_mgr_node_lock);
+#endif
 
 	req->major = MAJOR(binderfs_dev);
 	req->minor = minor;
@@ -263,7 +275,11 @@ static void binderfs_evict_inode(struct inode *inode)
 	mutex_unlock(&binderfs_minors_mutex);
 
 	if (refcount_dec_and_test(&device->ref)) {
+#ifdef CONFIG_DRV_NS
+		kfree(device->context[0].name);
+#else
 		kfree(device->context.name);
+#endif
 		kfree(device);
 	}
 }
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 06ad33c1242c..7f71530017d8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -28,10 +28,29 @@
 #include <linux/sched/signal.h>
 #include <linux/sched/mm.h>
 #include <linux/sysfs.h>
-
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
 #include "base.h"
 #include "power/power.h"
 
+#ifdef CONFIG_DRV_NS
+struct drv_namespace init_drv_ns = {
+	.active = true,
+	.count = ATOMIC_INIT(2),  /* extra reference for active_dev_ns */
+	.pid_ns = &init_pid_ns,
+	.tag = { 'i', 'n', 'i', 't', 0 },
+	.notifiers = BLOCKING_NOTIFIER_INIT(init_drv_ns.notifiers),
+	.timestamp = 0,
+	.mutex = __MUTEX_INITIALIZER(init_drv_ns.mutex),
+	.info = { NULL },
+};
+EXPORT_SYMBOL_GPL(init_drv_ns);
+
+struct drv_namespace *active_drv_ns = &init_drv_ns;
+EXPORT_SYMBOL_GPL(active_drv_ns);
+#endif
+
 #ifdef CONFIG_SYSFS_DEPRECATED
 #ifdef CONFIG_SYSFS_DEPRECATED_V2
 long sysfs_deprecated = 1;
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 95f90699d2b1..298dce85dfa6 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -24,6 +24,9 @@
 #include <linux/device.h>
 #include <linux/cdev.h>
 #include "input-compat.h"
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
 
 struct evdev {
 	int open;
@@ -37,6 +40,10 @@ struct evdev {
 	bool exist;
 };
 
+#ifdef CONFIG_DRV_NS
+struct evdev_drv_ns;
+#endif
+
 struct evdev_client {
 	unsigned int head;
 	unsigned int tail;
@@ -45,6 +52,13 @@ struct evdev_client {
 	wait_queue_head_t wait;
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
+#ifdef CONFIG_DRV_NS
+	struct evdev_drv_ns *evdev_ns;
+	struct list_head list;
+	bool grab;
+	struct list_head keys_down;
+	bool is_always_active;
+#endif
 	struct list_head node;
 	enum input_clock_type clk_type;
 	bool revoked;
@@ -53,6 +67,225 @@ struct evdev_client {
 	struct input_event buffer[];
 };
 
+#ifdef CONFIG_DRV_NS
+struct evdev_drv_ns {
+	struct mutex mutex;
+	struct list_head clients;
+	struct drv_ns_info drv_ns_info;
+};
+
+struct keydown {
+	u16 code;
+	struct list_head link;
+};
+
+static void set_keydown(struct evdev_client *client, u16 code)
+{
+	struct keydown *kd;
+	list_for_each_entry(kd, &client->keys_down, link) {
+		if (kd->code == code)
+			return;
+	}
+	kd = kmalloc(sizeof(*kd), GFP_ATOMIC);
+	if (!kd)
+		return;
+	kd->code = code;
+	list_add(&kd->link, &client->keys_down);
+}
+
+static void clear_keydown(struct evdev_client *client, u16 code)
+{
+	struct keydown *kd, *n;
+	list_for_each_entry_safe(kd, n, &client->keys_down, link) {
+		if (kd->code == code) {
+			list_del(&kd->link);
+			kfree(kd);
+			return;
+		}
+	}
+}
+/* evdev_ns_id, get_evdev_ns(), get_evdev_ns_cur(), put_evdev_ns() */
+DEFINE_DRV_NS_INFO(evdev)
+
+static bool is_always_active_evdev(struct evdev_client *client){
+	static char *always_active_evdev[] = {
+		"STM VL53L0 proximity sensor",
+		"sdm670-intcodec-b4-snd-card Headset Jack",
+		"sdm670-intcodec-b4-snd-card Button Jack",
+		NULL
+	};
+
+	char **evdevname;
+	for (evdevname = always_active_evdev; *evdevname != NULL; evdevname++){
+		if(strncmp(client->evdev->handle.dev->name, *evdevname, strlen(*evdevname)) == 0)
+			return true;
+	}
+
+	return false;
+}
+
+/* indicate whether an evdev client is in the foreground */
+static bool evdev_client_is_active(struct evdev_client *client)
+{
+	return client->is_always_active || is_active_evdev_drv_ns(client->evdev_ns);
+}
+
+static struct notifier_block evdev_ns_switch_notifier;
+static int evdev_grab(struct evdev *evdev, struct evdev_client *client);
+static int evdev_ungrab(struct evdev *evdev, struct evdev_client *client);
+static void __pass_event(struct evdev_client *client,const struct input_event *event);
+
+/* evdev_ns helpers */
+static struct drv_ns_info *evdev_drvns_create(struct drv_namespace *drv_ns)
+{
+	struct evdev_drv_ns *evdev_ns;
+	struct drv_ns_info *drv_ns_info;
+
+	evdev_ns = kzalloc(sizeof(*evdev_ns), GFP_KERNEL);
+	if (!evdev_ns)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_init(&evdev_ns->mutex);
+	INIT_LIST_HEAD(&evdev_ns->clients);
+
+	pr_info("new evdev_drv_ns %p (d %p)\n", evdev_ns, drv_ns);
+
+	drv_ns_info = &evdev_ns->drv_ns_info;
+
+	drv_ns_info->nb = evdev_ns_switch_notifier;
+	drv_ns_register_notify(drv_ns, &drv_ns_info->nb);
+
+	return &evdev_ns->drv_ns_info;
+}
+
+static void evdev_drvns_release(struct drv_ns_info *drv_ns_info)
+{
+	struct evdev_drv_ns *evdev_ns;
+
+	evdev_ns = container_of(drv_ns_info, struct evdev_drv_ns, drv_ns_info);
+
+	pr_info("del evdev_drv_ns %p (d %p)\n", evdev_ns, drv_ns_info->drv_ns);
+	drv_ns_unregister_notify(drv_ns_info->drv_ns, &drv_ns_info->nb);
+
+	kfree(evdev_ns);
+}
+
+static struct drv_ns_ops evdev_ns_ops = {
+	.create = evdev_drvns_create,
+	.release = evdev_drvns_release,
+};
+
+static int evdev_ns_track_client(struct evdev_client *client)
+{
+	struct evdev_drv_ns *evdev_ns;
+
+	evdev_ns = get_evdev_ns_cur();
+	if (!evdev_ns)
+		return -ENOMEM;
+
+	//pr_info("track new client 0x%p in evdev_ns 0x%p (drv_ns 0x%p)\n",
+	//	client, evdev_ns, evdev_ns->drv_ns_info.drv_ns);
+
+	client->is_always_active = is_always_active_evdev(client);
+	client->evdev_ns = evdev_ns;
+	client->grab = false;
+	INIT_LIST_HEAD(&client->keys_down);
+
+	mutex_lock(&evdev_ns->mutex);
+	list_add(&client->list, &evdev_ns->clients);
+	mutex_unlock(&evdev_ns->mutex);
+
+	return 0;
+}
+
+static void evdev_ns_untrack_client(struct evdev_client *client)
+{
+	struct evdev_drv_ns *evdev_ns;
+
+	evdev_ns = client->evdev_ns;
+
+	//pr_info("untrack client 0x%p in evdev_ns 0x%p (drv_ns 0x%p)\n",
+	//	client, evdev_ns, evdev_ns->drv_ns_info.drv_ns);
+
+	mutex_lock(&evdev_ns->mutex);
+	list_del(&client->list);
+	mutex_unlock(&evdev_ns->mutex);
+
+	put_evdev_ns(evdev_ns);
+}
+
+/* drv_ns and resepctive fb_drv_ns protected by caller */
+static int evdev_ns_switch_callback(struct notifier_block *self,
+				    unsigned long action, void *data)
+{
+	struct drv_namespace *drv_ns = data;
+	struct evdev_drv_ns *evdev_ns;
+	struct evdev_client *client;
+	struct keydown *kd, *n;
+	struct input_event event;
+	ktime_t *ev_time = NULL;
+	struct timespec64 ts;
+
+	evdev_ns = find_evdev_ns(drv_ns);
+	WARN(evdev_ns == NULL, "drvns 0x%p: no matching evdev_ns\n", drv_ns);
+
+	mutex_lock(&evdev_ns->mutex);
+	switch (action) {
+	case DRV_NS_EVENT_ACTIVATE:
+		list_for_each_entry(client, &evdev_ns->clients, list)
+		{
+			mutex_lock(&client->evdev->mutex);
+			if (client->grab)
+				evdev_grab(client->evdev, client);
+			mutex_unlock(&client->evdev->mutex);
+		}
+		break;
+	case DRV_NS_EVENT_DEACTIVATE:
+		event.type = EV_KEY;
+		event.value = 0;
+		event.code = 0;
+		list_for_each_entry(client, &evdev_ns->clients, list)
+		{
+			if(!ev_time){
+				ev_time = input_get_timestamp(client->evdev->handle.dev);
+				ts = ktime_to_timespec64(ev_time[client->clk_type]);
+			}
+
+			/* release any pressed keys in the inactive client */
+			list_for_each_entry_safe(kd, n, &client->keys_down, link) {
+				event.code = kd->code;
+				event.input_event_sec = ts.tv_sec;
+				event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;
+				//event.time = ktime_to_timeval(ev_time[client->clk_type]);
+				pr_info("sending code %d KEY_UP to %s",kd->code, drv_ns->tag);
+				__pass_event(client, &event);
+			}
+
+			if (event.code) {
+				event.code = SYN_REPORT;
+				event.input_event_sec = ts.tv_sec;
+				event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;
+				//event.time = ktime_to_timeval(ev_time[client->clk_type]);
+				__pass_event(client, &event);
+				wake_up_interruptible(&client->wait);
+			}
+
+			mutex_lock(&client->evdev->mutex);
+			if (client->evdev->grab == client)
+				evdev_ungrab(client->evdev, client);
+			mutex_unlock(&client->evdev->mutex);
+		}
+		break;
+	}
+	mutex_unlock(&evdev_ns->mutex);
+	return 0;
+}
+
+static struct notifier_block evdev_ns_switch_notifier = {
+	.notifier_call = evdev_ns_switch_callback,
+};
+#endif /* CONFIG_DRV_NS */
+
 static size_t evdev_get_mask_cnt(unsigned int type)
 {
 	static const size_t counts[EV_CNT] = {
@@ -239,6 +472,16 @@ static void __pass_event(struct evdev_client *client,
 		client->packet_head = client->head;
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
+
+#ifdef CONFIG_DRV_NS
+	if (event->type == EV_KEY) {
+		if (event->value)
+			set_keydown(client, event->code);
+		else
+			clear_keydown(client, event->code);
+	}
+#endif
+
 }
 
 static void evdev_pass_values(struct evdev_client *client,
@@ -302,8 +545,15 @@ static void evdev_events(struct input_handle *handle,
 	if (client)
 		evdev_pass_values(client, vals, count, ev_time);
 	else
-		list_for_each_entry_rcu(client, &evdev->client_list, node)
+		list_for_each_entry_rcu(client, &evdev->client_list, node){
+
+#ifdef CONFIG_DRV_NS
+			if (!evdev_client_is_active(client))
+				continue;
+#endif
+
 			evdev_pass_values(client, vals, count, ev_time);
+		}
 
 	rcu_read_unlock();
 }
@@ -349,6 +599,10 @@ static int evdev_grab(struct evdev *evdev, struct evdev_client *client)
 	if (error)
 		return error;
 
+#ifdef CONFIG_DRV_NS
+	client->grab = true;
+#endif
+
 	rcu_assign_pointer(evdev->grab, client);
 
 	return 0;
@@ -362,6 +616,10 @@ static int evdev_ungrab(struct evdev *evdev, struct evdev_client *client)
 	if (grab != client)
 		return  -EINVAL;
 
+#ifdef CONFIG_DRV_NS
+	client->grab = false;
+#endif
+
 	rcu_assign_pointer(evdev->grab, NULL);
 	synchronize_rcu();
 	input_release_device(&evdev->handle);
@@ -446,6 +704,10 @@ static int evdev_release(struct inode *inode, struct file *file)
 	evdev_ungrab(evdev, client);
 	mutex_unlock(&evdev->mutex);
 
+#ifdef CONFIG_DRV_NS
+	evdev_ns_untrack_client(client);
+#endif
+
 	evdev_detach_client(evdev, client);
 
 	for (i = 0; i < EV_CNT; ++i)
@@ -482,6 +744,15 @@ static int evdev_open(struct inode *inode, struct file *file)
 	client->bufsize = bufsize;
 	spin_lock_init(&client->buffer_lock);
 	client->evdev = evdev;
+
+#ifdef CONFIG_DRV_NS
+	error = evdev_ns_track_client(client);
+	if (error)
+		goto err_free_client;
+
+	pr_info("evdev_client:%s is_always_active=%d \n",evdev->handle.dev->name,client->is_always_active);
+#endif
+
 	evdev_attach_client(evdev, client);
 
 	error = evdev_open_device(evdev);
@@ -494,6 +765,9 @@ static int evdev_open(struct inode *inode, struct file *file)
 	return 0;
 
  err_free_client:
+#ifdef CONFIG_DRV_NS
+	evdev_ns_untrack_client(client);
+#endif
 	evdev_detach_client(evdev, client);
 	kvfree(client);
 	return error;
@@ -527,6 +801,11 @@ static ssize_t evdev_write(struct file *file, const char __user *buffer,
 		}
 		retval += input_event_size();
 
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			continue;
+#endif
+
 		input_inject_event(&evdev->handle,
 				   event.type, event.code, event.value);
 		cond_resched();
@@ -1068,12 +1347,21 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		if (get_user(v, ip + 1))
 			return -EFAULT;
 
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+
 		input_inject_event(&evdev->handle, EV_REP, REP_DELAY, u);
 		input_inject_event(&evdev->handle, EV_REP, REP_PERIOD, v);
 
 		return 0;
 
 	case EVIOCRMFF:
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
 		return input_ff_erase(dev, (int)(unsigned long) p, file);
 
 	case EVIOCGEFFECTS:
@@ -1084,6 +1372,15 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return 0;
 
 	case EVIOCGRAB:
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client)) {
+			if (p)
+				client->grab = true;
+			else
+				client->grab = false;
+			return 0;
+		} /* else */
+#endif
 		if (p)
 			return evdev_grab(evdev, client);
 		else
@@ -1129,6 +1426,10 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return evdev_handle_get_keycode(dev, p);
 
 	case EVIOCSKEYCODE:
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
 		return evdev_handle_set_keycode(dev, p);
 
 	case EVIOCGKEYCODE_V2:
@@ -1177,6 +1478,11 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return str_to_user(dev->uniq, size, p);
 
 	case EVIOC_MASK_SIZE(EVIOCSFF):
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+
 		if (input_ff_effect_from_user(p, size, &effect))
 			return -EFAULT;
 
@@ -1219,6 +1525,11 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 
 	if (_IOC_DIR(cmd) == _IOC_WRITE) {
 
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+
 		if ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCSABS(0))) {
 
 			if (!dev->absinfo)
@@ -1430,11 +1741,26 @@ static struct input_handler evdev_handler = {
 
 static int __init evdev_init(void)
 {
-	return input_register_handler(&evdev_handler);
+	int ret;
+
+	ret = input_register_handler(&evdev_handler);
+	if (ret < 0)
+		return ret;
+#ifdef CONFIG_DRV_NS
+	ret = DRV_NS_REGISTER(evdev, "evdev");
+	if (ret < 0) {
+		input_unregister_handler(&evdev_handler);
+		return ret;
+	}
+#endif
+	return ret;
 }
 
 static void __exit evdev_exit(void)
 {
+#ifdef CONFIG_DRV_NS
+	DRV_NS_UNREGISTER(evdev);
+#endif
 	input_unregister_handler(&evdev_handler);
 }
 
diff --git a/include/linux/drv_namespace.h b/include/linux/drv_namespace.h
new file mode 100755
index 000000000000..176f71e147ee
--- /dev/null
+++ b/include/linux/drv_namespace.h
@@ -0,0 +1,227 @@
+#ifndef _LINUX_DRV_NS_H
+#define _LINUX_DRV_NS_H
+
+#include <linux/pid_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/notifier.h>
+#include <linux/hardirq.h>
+#include <linux/err.h>
+
+#define DRV_NS_TAG_LEN 64
+#define DRV_NS_DESC_MAX 32
+
+struct drv_namespace;
+struct drv_ns_info;
+
+struct drv_namespace {
+	bool active;
+	atomic_t count;
+	struct pid_namespace *pid_ns;
+	char tag[DRV_NS_TAG_LEN];
+	struct blocking_notifier_head notifiers;
+	unsigned long timestamp; /* jiffies */
+
+	struct mutex mutex;
+	struct drv_ns_info *info[DRV_NS_DESC_MAX];
+};
+
+struct drv_ns_info {
+	struct drv_namespace *drv_ns;
+	struct list_head list;
+	struct notifier_block nb;
+	atomic_t count;
+};
+
+extern struct drv_namespace init_drv_ns;
+extern struct net init_net;
+extern struct drv_namespace *active_drv_ns;
+
+struct drv_ns_ops {
+	struct drv_ns_info* (*create)(struct drv_namespace *drv_ns);
+	void (*release)(struct drv_ns_info *drv_ns_info);
+};
+
+/* driver namespace notifications */
+#define DRV_NS_EVENT_ACTIVATE		0x1
+#define DRV_NS_EVENT_DEACTIVATE		0x2
+
+extern void __put_drv_ns(struct drv_namespace *drv_ns);
+extern int get_drv_ns_idx(void);
+static inline void put_drv_ns(struct drv_namespace *drv_ns)
+{
+	if (atomic_dec_and_test(&drv_ns->count))
+		__put_drv_ns(drv_ns);
+}
+
+static inline struct drv_namespace *get_drv_ns(struct drv_namespace *drv_ns)
+{
+	atomic_inc(&drv_ns->count);
+	return drv_ns;
+}
+
+/* return the driver namespaces of the current process */
+static inline struct drv_namespace *current_drv_ns(void)
+{
+	if (in_interrupt())
+		return &init_drv_ns;
+	return current->nsproxy->drv_ns;
+}
+
+/* return the net namespaces of the current process */
+static inline struct net *current_net_ns(void)
+{
+	if (in_interrupt())
+		return &init_net;
+	return current->nsproxy->net_ns;
+}
+
+/* return whether given driver namespace is active */
+static inline bool is_active_drv_ns(struct drv_namespace *drv_ns)
+{
+	return drv_ns->active;
+}
+
+/* return and get the driver namespace of a given task */
+extern struct drv_namespace *get_drv_ns_by_task(struct task_struct *task);
+extern struct drv_namespace *get_drv_ns_by_vpid(pid_t vpid);
+
+/*
+ * set_active_drv_ns() will lock and unlock drv_namespace_lock
+ * and call all registered activate and inactivate notifiers.
+ */
+extern void set_active_drv_ns(struct drv_namespace *drv_ns);
+
+/* return root pid of the init process in a device namespace */
+static inline pid_t drv_ns_init_pid(struct drv_namespace *drv_ns)
+{
+	return drv_ns->pid_ns->child_reaper->pid;
+}
+
+/* driver namespaces: notifiers (de)registration */
+extern void drv_ns_register_notify(struct drv_namespace *drv_ns,
+				   struct notifier_block *nb);
+extern void drv_ns_unregister_notify(struct drv_namespace *drv_ns,
+				     struct notifier_block *nb);
+
+extern struct drv_namespace *copy_drv_ns(unsigned long flags,
+					 struct task_struct *task,
+					 struct pid_namespace *new_pidns);
+
+/* helpers for per-driver logic of device namespace */
+
+extern int register_drv_ns_ops(char *name, struct drv_ns_ops *ops);
+extern void unregister_drv_ns_ops(int ns_id);
+extern struct drv_ns_info *get_drv_ns_info(int ns_id,
+					   struct drv_namespace *drv_ns,
+					   bool lock, bool create);
+extern struct drv_ns_info *get_drv_ns_info_task(int ns_id,
+						struct task_struct *task);
+extern void put_drv_ns_info(int ns_id,
+			    struct drv_ns_info *drv_ns_info,
+			    int lock);
+extern void loop_drv_ns_info(int ns_id, void *ptr,
+			     void (*func)(struct drv_ns_info *drv_ns_info,
+					  void *ptr));
+
+/* macro-mania to reduce repetitive code - not for the faint of heart */
+
+#define i_to_x_drv_ns(i, x) container_of(i, struct x ## _drv_ns, drv_ns_info)
+
+#define _drv_ns_id(X) \
+	static int X ## _ns_id;
+
+#define _drv_ns_get(X) \
+	static inline \
+	struct X ## _drv_ns *get_ ## X ## _ns(struct drv_namespace *drv_ns) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info(X ## _ns_id, drv_ns, 1, 1); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+
+#define _drv_ns_find(X) \
+	static inline \
+	struct X ## _drv_ns *find_ ## X ## _ns(struct drv_namespace *drv_ns) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info(X ## _ns_id, drv_ns, 0, 0); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+
+
+#define _drv_ns_get_cur(X) \
+	static inline struct X ## _drv_ns *get_ ## X ## _ns_cur(void) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info_task(X ## _ns_id, current); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+
+#define _drv_ns_put(X) \
+	static inline void put_ ## X ## _ns(struct X ## _drv_ns *X ## _ns) \
+	{ \
+		put_drv_ns_info(X ## _ns_id, &X ## _ns->drv_ns_info, 1); \
+	}
+
+#define _drv_ns_active(X) \
+	static inline bool \
+	is_active_ ## X ## _drv_ns(struct X ## _drv_ns *ns) \
+	{ \
+		return is_active_drv_ns(ns->drv_ns_info.drv_ns); \
+	}
+
+#define _drv_nb_self(X) \
+	static inline struct X ## _drv_ns * \
+	get_ ## X ## _nb_self(struct notifier_block *self) \
+	{ \
+		struct drv_ns_info *drv_ns_info; \
+		struct X ## _drv_ns *ns; \
+		drv_ns_info = container_of(self, struct drv_ns_info, nb); \
+		ns = container_of(drv_ns_info, \
+				  struct X ## _drv_ns, drv_ns_info); \
+		return ns; \
+	}
+
+/*
+ * Finally, this is what a driver author really needs to use:
+ * DEFINE_DRV_NS_INFO(X): X_ns_id, put_X_ns(), get_X_ns(), get_X_ns_cur()
+ *                        is_active_X_ns(), get_X_nb_self()
+ * DRV_NS_REGISTER(X): will register X with driver namespace
+ * DRV_NS_UNREGISTER(X): will unregister X from driver namespace
+ */
+
+#define DEFINE_DRV_NS_INFO(X) \
+	_drv_ns_id(X) \
+	_drv_ns_find(X) \
+	_drv_ns_get(X) \
+	_drv_ns_get_cur(X) \
+	_drv_ns_put(X) \
+	_drv_ns_active(X) \
+	_drv_nb_self(X)
+
+#define DRV_NS_REGISTER(X, s) \
+	(X ## _ns_id = register_drv_ns_ops(s, &X ## _ns_ops))
+
+#define DRV_NS_UNREGISTER(X) \
+	unregister_drv_ns_ops(X ## _ns_id)
+
+static inline int is_init_ns(struct drv_namespace *ns)
+{
+	if (ns == &init_drv_ns)
+		return 1;
+	return 0;
+}
+
+static inline struct nsproxy *drv_ns_nsproxy(struct drv_namespace *drv_ns)
+{
+	/*
+	 * a device namespace has a one-to-one relationship with a
+	 * PID namespace, so we know that the init task in the PID
+	 * namespace will also share our device namespace. Therefore,
+	 * we can take the nsproxy pointer from the child_reaper of
+	 * our associated PID namespace.
+	 */
+	return task_nsproxy(drv_ns->pid_ns->child_reaper);
+}
+
+#endif /* _LINUX_DEV_NS_H */
diff --git a/include/linux/nsproxy.h b/include/linux/nsproxy.h
index cdb171efc7cb..381e359cdf05 100644
--- a/include/linux/nsproxy.h
+++ b/include/linux/nsproxy.h
@@ -11,6 +11,9 @@ struct ipc_namespace;
 struct pid_namespace;
 struct cgroup_namespace;
 struct fs_struct;
+#ifdef CONFIG_DRV_NS
+struct drv_namespace;
+#endif
 
 /*
  * A structure to contain pointers to all per-process
@@ -38,6 +41,9 @@ struct nsproxy {
 	struct time_namespace *time_ns;
 	struct time_namespace *time_ns_for_children;
 	struct cgroup_namespace *cgroup_ns;
+#ifdef CONFIG_DRV_NS
+	struct drv_namespace *drv_ns;
+#endif
 };
 extern struct nsproxy init_nsproxy;
 
@@ -90,6 +96,12 @@ static inline struct cred *nsset_cred(struct nsset *set)
  *     task_unlock(task);
  *
  */
+#ifdef CONFIG_DRV_NS
+static inline struct nsproxy *task_nsproxy(struct task_struct *tsk)
+{
+	return rcu_dereference(tsk->nsproxy);
+}
+#endif
 
 int copy_namespaces(unsigned long flags, struct task_struct *tsk);
 void exit_task_namespaces(struct task_struct *tsk);
diff --git a/init/Kconfig b/init/Kconfig
index 4413af4302ea..af88f30ce1b0 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1188,6 +1188,14 @@ config NET_NS
 	  Allow user space to create what appear to be multiple instances
 	  of the network stack.
 
+config DRV_NS
+	bool "drivers namespace"
+	depends on PID_NS
+	default n
+	help
+	Allow user space to create what appear to be multiple instances
+	of the drivers stack.
+
 endif # NAMESPACES
 
 config CHECKPOINT_RESTORE
diff --git a/kernel/Makefile b/kernel/Makefile
index 6ee614db1717..b2a9accce5ae 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -79,6 +79,7 @@ obj-$(CONFIG_CGROUPS) += cgroup/
 obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
+obj-$(CONFIG_DRV_NS) += drv_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_IKHEADERS) += kheaders.o
 obj-$(CONFIG_SMP) += stop_machine.o
diff --git a/kernel/drv_namespace.c b/kernel/drv_namespace.c
new file mode 100755
index 000000000000..fb700f7d2a7a
--- /dev/null
+++ b/kernel/drv_namespace.c
@@ -0,0 +1,600 @@
+/*
+ * include/linux/drv_namespace.h
+ *
+ *
+ * Driver namespaces:
+ *
+ * The driver namespace allows a device driver to register itself and pass a
+ * pointer to its driver specific namespace structure and register notifiers
+ * which are called when the active namepace becomes inactive and when an
+ * inactive namespace becomes active.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GPL 2 license for more details.
+ * The full GPL 2 License is included in this distribution in the file called
+ * COPYING
+ */
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/pid_namespace.h>
+#include <linux/drv_namespace.h>
+#include <linux/kernel.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include "../fs/proc/internal.h"
+
+/* protects active namespace and switches */
+static DECLARE_RWSEM(global_drv_ns_lock);
+
+static void drv_ns_lock(struct drv_namespace *drv_ns)
+{
+	mutex_lock(&drv_ns->mutex);
+}
+
+static void drv_ns_unlock(struct drv_namespace *drv_ns)
+{
+	mutex_unlock(&drv_ns->mutex);
+}
+
+static struct drv_namespace *create_drv_ns(struct task_struct *task,
+					   struct pid_namespace *new_pidns)
+{
+	struct drv_namespace *drv_ns;
+
+	static int s_ndev;
+
+	drv_ns = kzalloc(sizeof(struct drv_namespace), GFP_KERNEL);
+	if (!drv_ns)
+		return ERR_PTR(-ENOMEM);
+
+	atomic_set(&drv_ns->count, 1);
+	BLOCKING_INIT_NOTIFIER_HEAD(&drv_ns->notifiers);
+	mutex_init(&drv_ns->mutex);
+	/* all new namespaces get a default tag */
+	memset(drv_ns->tag, 0, DRV_NS_TAG_LEN);
+	snprintf(drv_ns->tag, DRV_NS_TAG_LEN, "drv_ns.%d", ++s_ndev);
+
+	drv_ns->pid_ns = get_pid_ns(new_pidns);
+
+	return drv_ns;
+}
+
+struct drv_namespace *copy_drv_ns(unsigned long flags,
+				  struct task_struct *task,
+				  struct pid_namespace *new_pidns)
+{
+	struct drv_namespace *drv_ns = task->nsproxy->drv_ns;
+
+	/*
+	 * Couple driver namespace semantics with pid-namespace.
+	 * It's convenient, and we ran out of clone flags anyway.
+	 */
+	if (!(flags & CLONE_NEWPID))
+		return get_drv_ns(drv_ns);
+	else
+		return create_drv_ns(task, new_pidns);
+}
+
+void __put_drv_ns(struct drv_namespace *drv_ns)
+{
+	int n;
+
+	if (!drv_ns || drv_ns == &init_drv_ns)
+		return;
+
+	for (n = 0; n < DRV_NS_DESC_MAX; n++) {
+		if (drv_ns->info[n])
+			put_drv_ns_info(n, drv_ns->info[n], 0);
+	}
+
+	put_pid_ns(drv_ns->pid_ns);
+	kfree(drv_ns);
+}
+
+struct drv_namespace *get_drv_ns_by_task(struct task_struct *task)
+{
+	struct drv_namespace *drv_ns = NULL;
+	struct nsproxy *nsproxy;
+
+	rcu_read_lock();
+	nsproxy = task_nsproxy(task);
+	if (nsproxy)
+		drv_ns = get_drv_ns(nsproxy->drv_ns);
+	rcu_read_unlock();
+
+	return drv_ns;
+}
+
+struct drv_namespace *get_drv_ns_by_vpid(pid_t vpid)
+{
+	struct drv_namespace *drv_ns = NULL;
+	struct task_struct *task;
+	struct nsproxy *nsproxy;
+
+	rcu_read_lock();
+	task = find_task_by_pid_ns(vpid, &init_pid_ns);
+	if (task) {
+		nsproxy = task_nsproxy(task);
+		if (nsproxy)
+			drv_ns = get_drv_ns(nsproxy->drv_ns);
+	}
+	rcu_read_unlock();
+
+	return drv_ns;
+}
+
+/**
+ * notifications: activate/deactive driver namespace
+ */
+static BLOCKING_NOTIFIER_HEAD(drv_ns_notifiers);
+void drv_ns_register_notify(struct drv_namespace *drv_ns,
+			    struct notifier_block *nb)
+{
+	if (drv_ns != NULL)
+		blocking_notifier_chain_register(&drv_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_register(&drv_ns_notifiers, nb);
+}
+
+void drv_ns_unregister_notify(struct drv_namespace *drv_ns,
+			      struct notifier_block *nb)
+{
+	if (drv_ns != NULL)
+		blocking_notifier_chain_unregister(&drv_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_unregister(&drv_ns_notifiers, nb);
+}
+
+/*
+ * Helpers for per-driver logic of driver-namepace
+ *
+ * Drivers should embed 'struct drv_ns_info' in driver-specific,
+ * per-driver-namespace data, e.g.:
+ *
+ *   struct xxxx_namespace {
+ *     ... (data specific to xxxx)
+ *     struct drv_ns_info drvns_info;
+ *   };
+ *
+ * Drivers should register a 'struct drv_ns_ops' with ->create()
+ * and ->release() methods, and keep an identifier (drv_ns_xxx_id),
+ * for use by driver namespace generic code
+ *
+ * Drivers can iterate over per-driver data in all namespaces:
+ *   void loop_drv_ns_info(int drv_ns_id, void *ptr,
+ *              void (*func)(struct drv_ns_info *drv_ns_info, void *ptr))
+ *
+ * See include/linux/drv_namespace.h for helper macros to hide these details.
+ */
+
+struct drv_ns_desc {
+	char *name;
+	struct drv_ns_ops *ops;
+	struct mutex mutex;
+	struct list_head head;
+};
+
+static struct drv_ns_desc drv_ns_desc[DRV_NS_DESC_MAX];
+static DEFINE_SPINLOCK(drv_ns_desc_lock);
+
+int register_drv_ns_ops(char *name, struct drv_ns_ops *ops)
+{
+	struct drv_ns_desc *desc;
+	int n, ret = -ENOMEM;
+
+	if (!name)
+		return -EINVAL;
+
+	spin_lock(&drv_ns_desc_lock);
+	for (n = 0; n < DRV_NS_DESC_MAX; n++) {
+		desc = &drv_ns_desc[n];
+		if (!desc->name && ret < 0)
+			ret = n;
+		else if (desc->name && !strcmp(desc->name, name)) {
+			ret = -EBUSY;
+			break;
+		}
+	}
+	if (ret >= 0) {
+		pr_info("drv_ns: register info %s\n", name);
+		desc = &drv_ns_desc[ret];
+		desc->name = name;
+		desc->ops = ops;
+		INIT_LIST_HEAD(&desc->head);
+		mutex_init(&desc->mutex);
+	}
+	spin_unlock(&drv_ns_desc_lock);
+
+	return ret;
+}
+
+void unregister_drv_ns_ops(int drv_ns_id)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+
+	spin_lock(&drv_ns_desc_lock);
+	pr_info("drv_ns: unregister desc %s\n", desc->name);
+	memset(&drv_ns_desc[drv_ns_id], 0, sizeof(*desc));
+	spin_unlock(&drv_ns_desc_lock);
+}
+
+/* this function is called with drv_ns_lock(drv_ns) held */
+static struct drv_ns_info *new_drv_ns_info(int drv_ns_id,
+					   struct drv_namespace *drv_ns)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_ns_info *drv_ns_info;
+
+	pr_debug("drv_ns: [0x%p] new info %s\n", drv_ns, desc->name);
+
+	drv_ns_info = desc->ops->create(drv_ns);
+	if (IS_ERR_OR_NULL(drv_ns_info))
+		return NULL;
+
+	pr_debug("drv_ns: [0x%p] got info 0x%p\n", drv_ns, drv_ns_info);
+
+	drv_ns->info[drv_ns_id] = drv_ns_info;
+	/* take a reference for our drv_ns_info array */
+	atomic_set(&drv_ns_info->count, 1);
+	/*
+	 * don't take a reference here: we're contained by the drv_namespace
+	 * structure, and an extra reference to that structure would create a
+	 * circular dependecy resulting in memory that can never be free'd.
+	 */
+	drv_ns_info->drv_ns = drv_ns;
+
+	mutex_lock(&desc->mutex);
+	list_add(&drv_ns_info->list, &desc->head);
+	mutex_unlock(&desc->mutex);
+
+	return drv_ns_info;
+}
+
+/* this function is called with drv_ns_lock(drv_ns) held */
+static void del_drv_ns_info(int drv_ns_id, struct drv_ns_info *drv_ns_info)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_namespace *drv_ns = drv_ns_info->drv_ns;
+
+	pr_debug("drv_ns: [0x%p] destory info 0x%p\n", drv_ns, drv_ns_info);
+
+	drv_ns->info[drv_ns_id] = NULL;
+	mutex_lock(&desc->mutex);
+	list_del(&drv_ns_info->list);
+	mutex_unlock(&desc->mutex);
+
+	drv_ns_desc[drv_ns_id].ops->release(drv_ns_info);
+}
+
+/*
+ * get_drv_ns_info() is intended for internal use only. It is exported only
+ * to enable the helper macros in drv_namepsace.h to work properly.
+ *
+ * @create tells whether to create a new instance if none is found already,
+ * or just return NULL.
+ *
+ * @lock tells whether the @drv_ns should be locked against concurrent
+ * changes, or the caller is the one responsible (in which case there is
+ * not even a need for an extra refefence count).
+ */
+struct drv_ns_info *get_drv_ns_info(int drv_ns_id,
+				    struct drv_namespace *drv_ns,
+				    bool lock, bool create)
+{
+	struct drv_ns_info *drv_ns_info;
+
+	if (lock) {
+		down_read(&global_drv_ns_lock);
+		drv_ns_lock(drv_ns);
+	}
+
+	drv_ns_info = drv_ns->info[drv_ns_id];
+
+	if (!drv_ns_info && create)
+		drv_ns_info = new_drv_ns_info(drv_ns_id, drv_ns);
+
+	if (drv_ns_info) {
+		pr_debug("drv_ns: [0x%p] get info 0x%p count %d+\n", drv_ns,
+			 drv_ns_info, atomic_read(&drv_ns_info->count));
+	}
+
+	if (drv_ns_info && lock)
+		atomic_inc(&drv_ns_info->count);
+
+	if (lock) {
+		drv_ns_unlock(drv_ns);
+		up_read(&global_drv_ns_lock);
+	}
+
+	return drv_ns_info;
+}
+
+struct drv_ns_info *get_drv_ns_info_task(int drv_ns_id, struct task_struct *tsk)
+{
+	struct drv_ns_info *drv_ns_info = NULL;
+	struct drv_namespace *drv_ns;
+
+	drv_ns = get_drv_ns_by_task(tsk);
+	if (drv_ns) {
+		drv_ns_info = get_drv_ns_info(drv_ns_id, drv_ns, 1, 1);
+		put_drv_ns(drv_ns);
+	}
+
+	return drv_ns_info;
+}
+
+void put_drv_ns_info(int drv_ns_id, struct drv_ns_info *drv_ns_info, int lock)
+{
+	struct drv_namespace *drv_ns = drv_ns_info->drv_ns;
+
+	if (lock) {
+		down_read(&global_drv_ns_lock);
+		drv_ns_lock(drv_ns);
+	}
+
+	pr_debug("drv_ns: [0x%p] put info 0x%p count %d-\n", drv_ns,
+		 drv_ns_info, atomic_read(&drv_ns_info->count));
+	if (atomic_dec_and_test(&drv_ns_info->count))
+		del_drv_ns_info(drv_ns_id, drv_ns_info);
+
+	if (lock) {
+		drv_ns_unlock(drv_ns);
+		up_read(&global_drv_ns_lock);
+	}
+}
+
+/*
+ * @drv_ns_id: id of driver namespace subsystem
+ * @ptr: data pointer to be passed to callback
+ * @func: callback for each device namespace (atomic, must not sleep)
+ */
+void loop_drv_ns_info(int drv_ns_id, void *ptr,
+		      void (*func)(struct drv_ns_info *drv_ns_info, void *ptr))
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_ns_info *drv_ns_info;
+
+	mutex_lock(&desc->mutex);
+	list_for_each_entry(drv_ns_info, &desc->head, list) {
+		pr_debug("drv_ns: loop info 0x%p (drv_ns 0x%p) of %s\n",
+			 drv_ns_info, drv_ns_info->drv_ns, desc->name);
+		(*func)(drv_ns_info, ptr);
+	}
+	mutex_unlock(&desc->mutex);
+}
+
+/**
+ * Set the active driver namespace (will call registered notifiers to
+ * allow device drivers to make device specific context store/restore)
+ *
+ * @dev_ns: The new active device namespace
+ */
+void set_active_drv_ns(struct drv_namespace *next_ns)
+{
+	struct drv_namespace *prev_ns;
+
+	BUG_ON(next_ns == NULL);
+
+	down_write(&global_drv_ns_lock);
+
+	pr_info("drv_ns: next_ns 0x%p\n", next_ns);
+	pr_info("drv_ns: active_drv_ns 0x%p\n", active_drv_ns);
+
+	if (next_ns == active_drv_ns)
+		goto done;
+
+	prev_ns = active_drv_ns;
+
+	/*
+	 * deactivate previous drv_ns:
+	 * - set active-state of previous drv_ns to false
+	 * - call previous drv_ns's notifiers with deactivate event
+	 * - call global notifiers with deactivate event
+	 */
+
+	drv_ns_lock(prev_ns);
+
+	prev_ns->active = false;
+	prev_ns->timestamp = jiffies;
+
+	(void) blocking_notifier_call_chain(&prev_ns->notifiers,
+					    DRV_NS_EVENT_DEACTIVATE, prev_ns);
+	(void) blocking_notifier_call_chain(&drv_ns_notifiers,
+					    DRV_NS_EVENT_DEACTIVATE, prev_ns);
+
+	drv_ns_unlock(prev_ns);
+
+	/*
+	 * activate next drv_ns:
+	 * - set active-state of next drv_ns to true
+	 * - call next drv_ns's notifiers with activate event
+	 * - call global notifiers with activate event
+	 */
+
+	drv_ns_lock(next_ns);
+
+	next_ns->active = true;
+	next_ns->timestamp = jiffies;
+
+	/* make the switch */
+	active_drv_ns = next_ns;
+
+	(void) blocking_notifier_call_chain(&next_ns->notifiers,
+					    DRV_NS_EVENT_ACTIVATE, next_ns);
+	(void) blocking_notifier_call_chain(&drv_ns_notifiers,
+					    DRV_NS_EVENT_ACTIVATE, next_ns);
+
+	drv_ns_unlock(next_ns);
+
+	get_drv_ns(next_ns);
+	put_drv_ns(prev_ns);
+
+	pr_info("dev_ns: activate 0x%p done\n", active_drv_ns);
+ done:
+	up_write(&global_drv_ns_lock);
+}
+
+/**
+ * Setup for /proc/drv_ns
+ */
+
+static struct proc_dir_entry *proc_drv_ns_dir;
+
+struct proc_dir_entry *
+create_drv_ns_proc(const char *name, const struct proc_ops *fops)
+{
+	struct proc_dir_entry *entry;
+	entry = proc_create(name, 0, proc_drv_ns_dir, fops);
+	return entry;
+}
+
+static int proc_active_ns_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_drv_ns_lock);
+	seq_printf(seq, "%d\n", drv_ns_init_pid(active_drv_ns));
+	up_read(&global_drv_ns_lock);
+	return 0;
+}
+
+static int proc_ns_tag_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_drv_ns_lock);
+	seq_printf(seq, "active: %d timestamp: %ld tag: %s\n",
+		   drv_ns_init_pid(active_drv_ns),
+		   active_drv_ns->timestamp,
+		   active_drv_ns->tag);
+	up_read(&global_drv_ns_lock);
+	return 0;
+}
+
+static bool drv_ns_proc_permission(void)
+{
+	return current_drv_ns() == &init_drv_ns;
+}
+
+static int proc_active_ns_open(struct inode *inode, struct file *file)
+{
+	if (!drv_ns_proc_permission())
+		return -EPERM;
+	return single_open(file, proc_active_ns_show, PDE(inode)->data);
+}
+
+static int proc_ns_tag_open(struct inode *inode, struct file *file)
+{
+	//if (!drv_ns_proc_permission())
+	//	return -EPERM;
+	return single_open(file, proc_ns_tag_show, PDE(inode)->data);
+}
+
+static ssize_t proc_active_ns_write(struct file *file,
+				    const char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	struct drv_namespace *drv_ns;
+	char spid[64] = {0};
+	pid_t pid = 0;
+
+	/* only init ns may change active ns */
+	if (!drv_ns_proc_permission())
+		return -EPERM;
+
+	if (count >= sizeof(spid) || count == 0)
+		return -EFAULT;
+
+	if (copy_from_user(spid, buffer, count))
+		return -EFAULT;
+
+	if (kstrtoint(spid, 10, &pid) || !pid) {
+		pr_warn("drv_ns: bad PID format '%s'\n", spid);
+		return -EINVAL;
+	}
+
+	drv_ns = get_drv_ns_by_vpid(pid);
+	if (!drv_ns) {
+		pr_warn("drv_ns: non-existing PID %d\n", pid);
+		return -EINVAL;
+	}
+
+	set_active_drv_ns(drv_ns);
+
+	put_drv_ns(drv_ns);
+	return count;
+}
+
+static ssize_t proc_ns_tag_write(struct file *file,
+				 const char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	char name[DRV_NS_TAG_LEN] = {0};
+
+	if (count >= sizeof(name) || count == 0)
+		return -EFAULT;
+
+	if (copy_from_user(name, buffer, count))
+		return -EFAULT;
+
+	memset(current_drv_ns()->tag, 0, DRV_NS_TAG_LEN);
+	strcpy(current_drv_ns()->tag, name);
+	pr_info("drv_ns: tag = %s \n", current_drv_ns()->tag);
+	return count;
+}
+
+static const struct proc_ops active_ns_fileops = {
+	.proc_open = proc_active_ns_open,
+	.proc_read = seq_read,
+	.proc_write = proc_active_ns_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+
+static const struct proc_ops ns_tag_fileops = {
+	.proc_open = proc_ns_tag_open,
+	.proc_read = seq_read,
+	.proc_write = proc_ns_tag_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+
+static __init int drv_namespace_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	proc_drv_ns_dir = proc_mkdir("drv_ns", NULL);
+	if (!proc_drv_ns_dir) {
+		pr_err("[drv_namespace_init] proc_mkdir fail!\n");
+		return -ENOMEM;
+	}
+
+	entry = proc_create("active_ns_pid", 0644, proc_drv_ns_dir,
+			    &active_ns_fileops);
+	if (!entry) {
+		pr_err("[drv_namespace_init] proc_create active_ns_pid fail!\n");
+		goto out_fail_active_ns;
+	}
+
+	entry = proc_create("ns_tag", 0644, proc_drv_ns_dir,
+			    &ns_tag_fileops);
+	if (!entry) {
+		pr_err("[drv_namespace_init] proc_create ns_tag fail!\n");
+		goto out_fail_ns_tag;
+	}
+
+	pr_info("[drv_namespace_init] success exit...\n");
+
+	return 0;
+
+out_fail_ns_tag:
+	remove_proc_entry("active_ns_pid", proc_drv_ns_dir);
+out_fail_active_ns:
+	remove_proc_entry("drv_ns", NULL);
+	return -ENOMEM;
+}
+
+device_initcall(drv_namespace_init);
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index 12dd41b39a7f..d1cc3f06206e 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -26,6 +26,9 @@
 #include <linux/syscalls.h>
 #include <linux/cgroup.h>
 #include <linux/perf_event.h>
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
 
 static struct kmem_cache *nsproxy_cachep;
 
@@ -47,6 +50,9 @@ struct nsproxy init_nsproxy = {
 	.time_ns		= &init_time_ns,
 	.time_ns_for_children	= &init_time_ns,
 #endif
+#ifdef CONFIG_DRV_NS
+	.drv_ns			= &init_drv_ns,
+#endif
 };
 
 static inline struct nsproxy *create_nsproxy(void)
@@ -121,8 +127,22 @@ static struct nsproxy *create_new_namespaces(unsigned long flags,
 	}
 	new_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);
 
+#ifdef CONFIG_DRV_NS
+	new_nsp->drv_ns = copy_drv_ns(flags, tsk, new_nsp->pid_ns_for_children);
+	if (IS_ERR(new_nsp->drv_ns)) {
+		err = PTR_ERR(new_nsp->drv_ns);
+		goto out_drv;
+	}
+#endif
 	return new_nsp;
 
+#ifdef CONFIG_DRV_NS
+out_drv:
+	if (new_nsp->time_ns_for_children)
+		put_time_ns(new_nsp->time_ns_for_children);
+	if (new_nsp->time_ns)
+		put_time_ns(new_nsp->time_ns);
+#endif
 out_time:
 	put_net(new_nsp->net_ns);
 out_net:
@@ -206,6 +226,10 @@ void free_nsproxy(struct nsproxy *ns)
 		put_time_ns(ns->time_ns_for_children);
 	put_cgroup_ns(ns->cgroup_ns);
 	put_net(ns->net_ns);
+#ifdef CONFIG_DRV_NS
+	if (ns->drv_ns)
+		put_drv_ns(ns->drv_ns);
+#endif
 	kmem_cache_free(nsproxy_cachep, ns);
 }
 
diff --git a/kernel/power/wakelock.c b/kernel/power/wakelock.c
index 105df4dfc783..b6870a8f91e5 100644
--- a/kernel/power/wakelock.c
+++ b/kernel/power/wakelock.c
@@ -20,6 +20,9 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
 #include "power.h"
 
 static DEFINE_MUTEX(wakelocks_lock);
@@ -28,6 +31,9 @@ struct wakelock {
 	char			*name;
 	struct rb_node		node;
 	struct wakeup_source	*ws;
+#ifdef CONFIG_DRV_NS
+	struct drv_namespace * drv_ns;
+#endif
 #ifdef CONFIG_PM_WAKELOCKS_GC
 	struct list_head	lru;
 #endif
@@ -46,7 +52,11 @@ ssize_t pm_show_wakelocks(char *buf, bool show_active)
 
 	for (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {
 		wl = rb_entry(node, struct wakelock, node);
+#ifdef CONFIG_DRV_NS
+		if (wl->ws->active == show_active && wl->drv_ns == current_drv_ns())
+#else
 		if (wl->ws->active == show_active)
+#endif
 			str += scnprintf(str, end - str, "%s ", wl->name);
 	}
 	if (str > buf)
@@ -160,7 +170,11 @@ static struct wakelock *wakelock_lookup_add(const char *name, size_t len,
 		parent = *node;
 		wl = rb_entry(*node, struct wakelock, node);
 		diff = strncmp(name, wl->name, len);
+#ifdef CONFIG_DRV_NS
+		if (diff == 0 && wl->drv_ns == current_drv_ns()) {
+#else
 		if (diff == 0) {
+#endif
 			if (wl->name[len])
 				diff = -1;
 			else
@@ -189,6 +203,9 @@ static struct wakelock *wakelock_lookup_add(const char *name, size_t len,
 	}
 
 	wl->ws = wakeup_source_register(NULL, wl->name);
+#ifdef CONFIG_DRV_NS
+	wl->drv_ns = current_drv_ns();
+#endif
 	if (!wl->ws) {
 		kfree(wl->name);
 		kfree(wl);
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 0a18cbc641e3..7d74e1606a11 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -116,12 +116,12 @@ static int __init enforcing_setup(char *str)
 {
 	unsigned long enforcing;
 	if (!kstrtoul(str, 0, &enforcing))
-		selinux_enforcing_boot = enforcing ? 1 : 0;
+		selinux_enforcing_boot = enforcing ? 0 : 0;
 	return 1;
 }
 __setup("enforcing=", enforcing_setup);
 #else
-#define selinux_enforcing_boot 1
+#define selinux_enforcing_boot 0
 #endif
 
 int selinux_enabled_boot __initdata = 1;
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index 2b745ae8cb98..21e16ab5699f 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -159,7 +159,7 @@ static ssize_t sel_write_enforce(struct file *file, const char __user *buf,
 	if (sscanf(page, "%d", &new_value) != 1)
 		goto out;
 
-	new_value = !!new_value;
+	new_value = 0;
 
 	old_value = enforcing_enabled(state);
 	if (new_value != old_value) {
-- 
2.31.1

From 2e9763ec7093eb5caa26d26a2f50e84ca90175dd Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Sat, 3 Sep 2022 10:48:18 +0800
Subject: [PATCH 2/5] apply patch:xdja-container-20220829 from jianglin

---
 .../java/android/app/IContainerService.aidl   |   2 +-
 .../android/app/SystemServiceRegistry.java    |   8 +-
 .../java/com/android/server/CellsService.java |  11 +-
 .../server/display/DisplayManagerService.java |   7 +-
 .../contexthub/ContextHubService.java         |   8 +-
 ...droid_server_power_PowerManagerService.cpp |   6 +-
 .../java/com/android/server/SystemServer.java |   9 +-
 .../com/android/server/ContainerService.java  |   2 +-
 .../cmds/servicemanager/servicemanager.rc     |   1 -
 .../native/libs/gui/ISurfaceComposer.cpp      |  10 +-
 frameworks/native/libs/gui/LayerState.cpp     |   2 +
 .../native/libs/gui/SurfaceComposerClient.cpp |   9 +-
 .../native/libs/gui/include/gui/LayerState.h  |   1 +
 .../surfaceflinger/SurfaceFlinger.cpp         |  65 +++++----
 .../services/surfaceflinger/SurfaceFlinger.h  |   1 +
 system/core/rootdir/cells/system/hw/init.rc   |   3 +-
 system/core/rootdir/cells/system/wifi.rc      |  68 ++++-----
 ...d.hardware.input.classifier@1.0-service.rc |  18 +--
 .../rootdir/cells/vendor/hw/init.oriole.rc    |   4 +-
 system/core/rootdir/init.rc                   |  11 ++
 .../libhidl/transport/ServiceManagement.cpp   |   6 +-
 system/netd/server/NetdNativeService.cpp      |   0
 system/netd/server/NetdNativeService.h        |   0
 system/netd/server/RouteController.cpp        |   2 -
 vendor/cells/cells/celld.c                    |   8 +-
 .../cellnet.c => cells/cellnet-rmnet.c}       |  41 +++++-
 vendor/cells/cells/cellnet.c                  |  76 +++++++++-
 vendor/cells/cells/cellnet.h                  |   1 +
 vendor/cells/cells/nsexec.c                   |   7 +-
 vendor/cells/cells/virtual_network.c          |   0
 vendor/cells/cells_build.mk                   |   1 +
 .../secure/view/SecureSwitchActivity.java     |   6 +-
 vendor/cells/cellsservice/Android.mk          |  18 ++-
 .../cellsservice/CellsPrivateService.cpp      | 130 ++++++++----------
 .../cells/cellsservice/CellsPrivateService.h  |   1 +
 .../cellsservice/ICellsPrivateService.cpp     |  24 ++++
 .../cells/cellsservice/ICellsPrivateService.h |   2 +
 vendor/cells/cellsservice/cellnet.h           |  21 ---
 vendor/cells/cellsservice/cellsstart.cpp      |  75 ++++++++++
 vendor/cells/cellsservice/cellssync.cpp       |   4 +-
 vendor/cells/cellsservice/cswitch.cpp         |   2 +-
 vendor/cells/cellsservice/main_cells.cpp      |  36 +++--
 42 files changed, 471 insertions(+), 236 deletions(-)
 mode change 100644 => 100755 system/netd/server/NetdNativeService.cpp
 mode change 100644 => 100755 system/netd/server/NetdNativeService.h
 rename vendor/cells/{cellsservice/cellnet.c => cells/cellnet-rmnet.c} (89%)
 mode change 100644 => 100755 vendor/cells/cells/virtual_network.c
 delete mode 100755 vendor/cells/cellsservice/cellnet.h
 create mode 100755 vendor/cells/cellsservice/cellsstart.cpp

diff --git a/frameworks/base/core/java/android/app/IContainerService.aidl b/frameworks/base/core/java/android/app/IContainerService.aidl
index 168f4040e8..6e90d2486f 100755
--- a/frameworks/base/core/java/android/app/IContainerService.aidl
+++ b/frameworks/base/core/java/android/app/IContainerService.aidl
@@ -32,6 +32,6 @@ interface IContainerService {
 	int tarCellsVm(@nullable String name);
 	int sendCellsVm(@nullable String path, @nullable String address);
 	int vmSystemReady();
-	void onPeerNotified();
+        oneway void onPeerNotified();
 }
 
diff --git a/frameworks/base/core/java/android/app/SystemServiceRegistry.java b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
index 1143fce329..37cd13b41f 100755
--- a/frameworks/base/core/java/android/app/SystemServiceRegistry.java
+++ b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
@@ -1696,7 +1696,7 @@ public final class SystemServiceRegistry {
                 new StaticServiceFetcher<TServiceClass>() {
                     @Override
                     public TServiceClass createService() throws ServiceNotFoundException {
-                        if(serviceName == Context.WIFI_SERVICE ||
+                        /*if(serviceName == Context.WIFI_SERVICE ||
                            serviceName == Context.WIFI_P2P_SERVICE ||
                            serviceName == Context.WIFI_AWARE_SERVICE ||
                            serviceName == Context.WIFI_SCANNING_SERVICE ||
@@ -1704,7 +1704,7 @@ public final class SystemServiceRegistry {
                            serviceName == Context.WIFI_RTT_SERVICE){
                             return serviceProducer.createService(
                                     ServiceManager.getInitService(serviceName));
-                        }
+                        }*/
                         return serviceProducer.createService(
                                 ServiceManager.getServiceOrThrow(serviceName));
                     }});
@@ -1763,7 +1763,7 @@ public final class SystemServiceRegistry {
                     @Override
                     public TServiceClass createService(ContextImpl ctx)
                             throws ServiceNotFoundException {
-                        if(serviceName == Context.WIFI_SERVICE ||
+                        /*if(serviceName == Context.WIFI_SERVICE ||
                            serviceName == Context.WIFI_P2P_SERVICE ||
                            serviceName == Context.WIFI_AWARE_SERVICE ||
                            serviceName == Context.WIFI_SCANNING_SERVICE ||
@@ -1772,7 +1772,7 @@ public final class SystemServiceRegistry {
                             return serviceProducer.createService(
                                     ctx.getOuterContext(),
                                     ServiceManager.getInitService(serviceName));
-                        }
+                        }*/
                         return serviceProducer.createService(
                                 ctx.getOuterContext(),
                                 ServiceManager.getServiceOrThrow(serviceName));
diff --git a/frameworks/base/services/core/java/com/android/server/CellsService.java b/frameworks/base/services/core/java/com/android/server/CellsService.java
index b13b176a24..f18bd8e004 100755
--- a/frameworks/base/services/core/java/com/android/server/CellsService.java
+++ b/frameworks/base/services/core/java/com/android/server/CellsService.java
@@ -37,7 +37,6 @@ import android.net.TrafficStats;
 import android.net.InetAddresses;
 import android.net.IpPrefix;
 import android.app.CellsPrivateServiceMgr;
-
 import android.provider.Settings;
 
 import com.android.server.net.NetlinkTracker;
@@ -85,7 +84,9 @@ public class CellsService extends ICellsService.Stub {
 
     public  void systemReady(){
         if(SystemProperties.get("ro.boot.vm","0").equals("1")){
-            mCellsNetworkAgent = new CellsNetworkAgent(mContext,this);
+            if(SystemProperties.get("persist.sys.cells.netagent","").equals("")){
+                mCellsNetworkAgent = new CellsNetworkAgent(mContext,this);
+            }
 
             Thread vmready = new Thread(new Runnable(){
                 @Override
@@ -93,14 +94,12 @@ public class CellsService extends ICellsService.Stub {
                     CellsPrivateServiceMgr mCellsService = new CellsPrivateServiceMgr(mContext,
                                 ServiceManager.getInitService("CellsPrivateService"));
                     
-                    SystemProperties.set("persist.sys.exit", "1");
-
                     do
                     {
-                        SystemClock.sleep(5000);
+                        SystemClock.sleep(3000);
 
                         if("1".equals(SystemProperties.get("sys.boot_completed"))){
-                            SystemClock.sleep(2000);
+                            SystemClock.sleep(500);
                             mCellsService.vmSystemReady();
                             return ;
                         }
diff --git a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
index 499b111087..76e6a8adb7 100644
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
@@ -267,8 +267,11 @@ public final class DisplayManagerService extends SystemService {
         @Override
         public synchronized void requestDisplayState(int displayId, int state, float brightness,
                 float sdrBrightness) {
-            if(SystemProperties.get("persist.sys.exit","0").equals("1"))
-            	return ;
+            if(SystemProperties.get("sys.boot_completed").equals("1"))
+            {
+                if(SystemProperties.get("persist.sys.exit","0").equals("1"))
+                    return ;
+            }
 
             boolean allInactive = true;
             boolean allOff = true;
diff --git a/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java b/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
index 191a5f5e2e..52d70fc009 100644
--- a/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
+++ b/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
@@ -203,11 +203,11 @@ public class ContextHubService extends IContextHubService.Stub {
 
         Pair<List<ContextHub>, List<String>> hubInfo;
         try {
-            if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
+            //if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
                 hubInfo = mContextHubWrapper.getHubs();
-            } else{
-                hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
-            }
+            //} else{
+            //    hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
+            //}
         } catch (RemoteException e) {
             Log.e(TAG, "RemoteException while getting Context Hub info", e);
             hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
diff --git a/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp b/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
index ae7ea3cd90..afcbe85df4 100644
--- a/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
+++ b/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
@@ -193,8 +193,10 @@ void disableAutoSuspend() {
     std::lock_guard<std::mutex> lock(gSuspendMutex);
     if (!gSuspendBlocker) {
         sp<ISystemSuspend> suspendHal = getSuspendHal();
-        gSuspendBlocker = suspendHal->acquireWakeLock(WakeLockType::PARTIAL,
-                "PowerManager.SuspendLockout");
+        if(suspendHal != nullptr){
+            gSuspendBlocker = suspendHal->acquireWakeLock(WakeLockType::PARTIAL,
+                    "PowerManager.SuspendLockout");
+        }
     }
 }
 
diff --git a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
index 24969fd93e..9d3fbee281 100755
--- a/frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -1510,14 +1510,12 @@ public final class SystemServer implements Dumpable {
             // Start receiving calls from HIDL services. Start in in a separate thread
             // because it need to connect to SensorManager. This has to start
             // after PHASE_WAIT_FOR_SENSOR_SERVICE is done.
-            if(SystemProperties.get("ro.boot.vm","0").equals("0")){
             SystemServerInitThreadPool.submit(() -> {
                 TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog();
                 traceLog.traceBegin(START_HIDL_SERVICES);
                 startHidlServices();
                 traceLog.traceEnd();
             }, START_HIDL_SERVICES);
-            }
 
             if (!isWatch && enableVrService) {
                 t.traceBegin("StartVrManagerService");
@@ -1861,7 +1859,7 @@ public final class SystemServer implements Dumpable {
             }
             t.traceEnd();
 
-            if(SystemProperties.get("ro.boot.vm","0").equals("0")){
+            //if(SystemProperties.get("ro.boot.vm","0").equals("0")){
             if (context.getPackageManager().hasSystemFeature(
                     PackageManager.FEATURE_WIFI)) {
                 // Wifi Service must be started first for wifi-related services.
@@ -1898,7 +1896,7 @@ public final class SystemServer implements Dumpable {
                         WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);
                 t.traceEnd();
             }
-            }
+
             if (context.getPackageManager().hasSystemFeature(
                     PackageManager.FEATURE_LOWPAN)) {
                 t.traceBegin("StartLowpan");
@@ -1912,6 +1910,7 @@ public final class SystemServer implements Dumpable {
                 mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
                 t.traceEnd();
             }
+            //}
 
             t.traceBegin("StartPacProxyService");
             try {
@@ -2826,7 +2825,6 @@ public final class SystemServer implements Dumpable {
                 reportWtf("making VcnManagementService ready", e);
             }
             t.traceEnd();
-            if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
             t.traceBegin("MakeNetworkPolicyServiceReady");
             try {
                 if (networkPolicyF != null) {
@@ -2836,7 +2834,6 @@ public final class SystemServer implements Dumpable {
                 reportWtf("making Network Policy Service ready", e);
             }
             t.traceEnd();
-            }
 
             // Wait for all packages to be prepared
             mPackageManagerService.waitForAppDataPrepared();
diff --git a/frameworks/base/services/xdja/com/android/server/ContainerService.java b/frameworks/base/services/xdja/com/android/server/ContainerService.java
index 0770e7190f..712243a825 100755
--- a/frameworks/base/services/xdja/com/android/server/ContainerService.java
+++ b/frameworks/base/services/xdja/com/android/server/ContainerService.java
@@ -148,7 +148,7 @@ public class ContainerService extends IContainerService.Stub {
         Parcel data = Parcel.obtain();
         Parcel reply = Parcel.obtain();
         try {
-            Log.e(TAG,"switchCellsVm start ");
+            Log.e(TAG,"switchCellsVm start name:" + name);
             data.writeInterfaceToken("CellsPrivateService");
             data.writeString(name);
             mChannel.transact(SWITCHCELLSVM, data, reply, 0);
diff --git a/frameworks/native/cmds/servicemanager/servicemanager.rc b/frameworks/native/cmds/servicemanager/servicemanager.rc
index d7607bed9e..6d5070fa04 100644
--- a/frameworks/native/cmds/servicemanager/servicemanager.rc
+++ b/frameworks/native/cmds/servicemanager/servicemanager.rc
@@ -3,7 +3,6 @@ service servicemanager /system/bin/servicemanager
     user system
     group system readproc
     critical
-    onrestart restart cellsservice
     onrestart restart apexd
     onrestart restart audioserver
     onrestart restart gatekeeperd
diff --git a/frameworks/native/libs/gui/ISurfaceComposer.cpp b/frameworks/native/libs/gui/ISurfaceComposer.cpp
index a9996acc29..8624b25973 100644
--- a/frameworks/native/libs/gui/ISurfaceComposer.cpp
+++ b/frameworks/native/libs/gui/ISurfaceComposer.cpp
@@ -75,6 +75,14 @@ public:
                                  const std::vector<ListenerCallbacks>& listenerCallbacks,
                                  uint64_t transactionId) override {
         Parcel data, reply;
+
+        InputWindowCommands tmpcommands;
+        char systemname[PROPERTY_VALUE_MAX]={0};
+        property_get("ro.boot.vm.name", systemname, "");
+
+        tmpcommands = commands;
+        tmpcommands.systemname = systemname;
+
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
 
         SAFE_PARCEL(frameTimelineInfo.write, data);
@@ -91,7 +99,7 @@ public:
 
         SAFE_PARCEL(data.writeUint32, flags);
         SAFE_PARCEL(data.writeStrongBinder, applyToken);
-        SAFE_PARCEL(commands.write, data);
+        SAFE_PARCEL(tmpcommands.write, data);
         SAFE_PARCEL(data.writeInt64, desiredPresentTime);
         SAFE_PARCEL(data.writeBool, isAutoTimestamp);
         SAFE_PARCEL(data.writeStrongBinder, uncacheBuffer.token.promote());
diff --git a/frameworks/native/libs/gui/LayerState.cpp b/frameworks/native/libs/gui/LayerState.cpp
index 77a883b332..5577672d36 100644
--- a/frameworks/native/libs/gui/LayerState.cpp
+++ b/frameworks/native/libs/gui/LayerState.cpp
@@ -635,12 +635,14 @@ void InputWindowCommands::clear() {
 status_t InputWindowCommands::write(Parcel& output) const {
     SAFE_PARCEL(output.writeParcelableVector, focusRequests);
     SAFE_PARCEL(output.writeBool, syncInputWindows);
+    SAFE_PARCEL(output.writeString8, systemname);
     return NO_ERROR;
 }
 
 status_t InputWindowCommands::read(const Parcel& input) {
     SAFE_PARCEL(input.readParcelableVector, &focusRequests);
     SAFE_PARCEL(input.readBool, &syncInputWindows);
+    systemname = input.readString8();
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/libs/gui/SurfaceComposerClient.cpp b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
index d464f04c52..25c0b110a1 100644
--- a/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+++ b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
@@ -25,6 +25,7 @@
 #include <utils/SortedVector.h>
 #include <utils/String8.h>
 #include <utils/threads.h>
+#include <cutils/properties.h>
 
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
@@ -707,7 +708,13 @@ status_t SurfaceComposerClient::Transaction::writeToParcel(Parcel* parcel) const
         composerState.write(*parcel);
     }
 
-    mInputWindowCommands.write(*parcel);
+    InputWindowCommands tmpcommands;
+    char systemname[PROPERTY_VALUE_MAX]={0};
+    property_get("ro.boot.vm.name", systemname, "");
+
+    tmpcommands = mInputWindowCommands;
+    tmpcommands.systemname = systemname;
+    tmpcommands.write(*parcel);
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/libs/gui/include/gui/LayerState.h b/frameworks/native/libs/gui/include/gui/LayerState.h
index 03e4aacdbe..1be4af210f 100644
--- a/frameworks/native/libs/gui/include/gui/LayerState.h
+++ b/frameworks/native/libs/gui/include/gui/LayerState.h
@@ -302,6 +302,7 @@ struct DisplayState {
 struct InputWindowCommands {
     std::vector<gui::FocusRequest> focusRequests;
     bool syncInputWindows{false};
+    String8 systemname;
 
     // Merges the passed in commands and returns true if there were any changes.
     bool merge(const InputWindowCommands& other);
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index 156e770a1a..ad9a49b35c 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -383,6 +383,8 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory, SkipInitializationTag)
     {
         mWindowInfosListenerInvokers.push_back(new WindowInfosListenerInvoker(this));
     }
+
+    mInputWindowCommandss = std::vector<InputWindowCommands>(CELLS_MAX_CONTEXT);
     ALOGI("Using HWComposer service: %s", mHwcServiceName.c_str());
 }
 
@@ -3095,39 +3097,40 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags) {
 }
 
 void SurfaceFlinger::updateInputFlinger() {
-    int i = 0;
     ATRACE_CALL();
     if (!mInputFlinger) {
         return;
     }
 
+    bool syncInputWindows = false;
+    for(int i=0; i < CELLS_MAX_CONTEXT; i++)
+    {
+        syncInputWindows |= mInputWindowCommandss[i].syncInputWindows;
+    }
+
     if (mVisibleRegionsDirty || mInputInfoChanged) {
         mInputInfoChanged = false;
         notifyWindowInfos();
-    } else if (mInputWindowCommands.syncInputWindows) {
+    } else if (syncInputWindows) {
         // If the caller requested to sync input windows, but there are no
         // changes to input windows, notify immediately.
         windowInfosReported();
     }
 
-    for (const auto& focusRequest : mInputWindowCommands.focusRequests) {
-        //mInputFlinger->setFocusedWindow(focusRequest);
-        for(i = 0; i < CELLS_MAX_CONTEXT; i++){
-            if(i == 0){
-                mInputFlinger->setFocusedWindow(focusRequest);
-            }
-            else{
-                const sp<IServiceManager> sm = OtherServiceManager(i);
-                if (sm != nullptr){
-                    sp<os::IInputFlinger>  mInputFlinger1 = interface_cast<os::IInputFlinger>(sm->getService( String16("inputflinger")));
-                    if (mInputFlinger1 != nullptr) {
-                        mInputFlinger1->setFocusedWindow(focusRequest);
-                    }
+    for(int i=0; i < CELLS_MAX_CONTEXT; i++)
+    {
+        for (const auto& focusRequest : mInputWindowCommandss[i].focusRequests)
+        {
+            const sp<IServiceManager> sm = OtherServiceManager(i);
+            if (sm != nullptr){
+                sp<os::IInputFlinger>  mInputFlinger1 = interface_cast<os::IInputFlinger>(sm->getService( String16("inputflinger")));
+                if (mInputFlinger1 != nullptr) {
+                    mInputFlinger1->setFocusedWindow(focusRequest);
                 }
             }
         }
+        mInputWindowCommandss[i].clear();
     }
-    mInputWindowCommands.clear();
 }
 
 bool enablePerWindowInputRotation() {
@@ -3137,9 +3140,7 @@ bool enablePerWindowInputRotation() {
 }
 
 void SurfaceFlinger::notifyWindowInfos() {
-    //std::vector<WindowInfo> windowInfos;
     std::vector<std::vector<WindowInfo>> windowInfos(CELLS_MAX_CONTEXT);
-    int i = 0;
 
     mDrawingState.traverseInReverseZOrder([&](Layer* layer) {
         if (!layer->needsInputInfo()) return;
@@ -3148,25 +3149,18 @@ void SurfaceFlinger::notifyWindowInfos() {
                 : nullptr;
         // When calculating the screen bounds we ignore the transparent region since it may
         // result in an unwanted offset.
-        //windowInfos.push_back(layer->fillInputInfo(display));
-        if(layer->getSystemName() == ""){
-            windowInfos[0].push_back(layer->fillInputInfo(display));
-        }else{
-            sscanf(layer->systemName(), "cell%d",&i);
-            if(i > 0 && i < CELLS_MAX_CONTEXT){
-                windowInfos[i].push_back(layer->fillInputInfo(display));
-            }
+        int i = 0;
+        sscanf(layer->systemName(), "cell%d", &i);
+        if(i >= 0 && i < CELLS_MAX_CONTEXT){
+            windowInfos[i].push_back(layer->fillInputInfo(display));
         }
     });
 
-    for(i = 0; i < CELLS_MAX_CONTEXT; i++)
+    for(int i = 0; i < CELLS_MAX_CONTEXT; i++)
     {
         mWindowInfosListenerInvokers[i]->windowInfosChanged(windowInfos[i],
-                                                    mInputWindowCommands.syncInputWindows);
+                                                    mInputWindowCommandss[i].syncInputWindows);
     }
-
-    //mWindowInfosListenerInvoker->windowInfosChanged(windowInfos,
-    //                                                mInputWindowCommands.syncInputWindows);
 }
 
 void SurfaceFlinger::updateCursorAsync() {
@@ -4318,7 +4312,10 @@ uint32_t SurfaceFlinger::setClientStateLocked(
 }
 
 uint32_t SurfaceFlinger::addInputWindowCommands(const InputWindowCommands& inputWindowCommands) {
-    bool hasChanges = mInputWindowCommands.merge(inputWindowCommands);
+    int i = 0;
+    sscanf(inputWindowCommands.systemname.string(), "cell%d", &i);
+    //ALOGD("addInputWindowCommands = %d", i);
+    bool hasChanges = mInputWindowCommandss[i].merge(inputWindowCommands);
     return hasChanges ? eTraversalNeeded : 0;
 }
 
@@ -7140,12 +7137,12 @@ status_t SurfaceFlinger::removeWindowInfosListenerX(
 status_t SurfaceFlinger::enterSelf(){
     invalidateHwcGeometry();
     repaintEverything();
-    ALOGD("SurfaceFlinger::enterSelf");
+    ALOGD("enterSelf");
     return NO_ERROR;
 }
 
 status_t SurfaceFlinger::exitSelf(){
-    ALOGD("SurfaceFlinger::exitSelf");
+    ALOGD("exitSelf");
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
index 9397faf68b..0d32fca74c 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
@@ -1454,6 +1454,7 @@ private:
     sp<os::IInputFlinger> mInputFlinger;
     // Should only be accessed by the main thread.
     InputWindowCommands mInputWindowCommands;
+    std::vector<InputWindowCommands> mInputWindowCommandss;
 
     Hwc2::impl::PowerAdvisor mPowerAdvisor;
 
diff --git a/system/core/rootdir/cells/system/hw/init.rc b/system/core/rootdir/cells/system/hw/init.rc
index b5efe44de2..4773e26250 100644
--- a/system/core/rootdir/cells/system/hw/init.rc
+++ b/system/core/rootdir/cells/system/hw/init.rc
@@ -67,7 +67,8 @@ on early-init
     start ueventd
 
     setprop ro.boot.vm 1
-    setprop persist.sys.exit 0
+    setprop persist.sys.exit 1
+    setprop persist.sys.cells.netagent ""
     setprop persist.logd.logpersistd logcatd
     # setprop system_init.startsensorservice 0
     setprop persist.sys.sdcardfs force_off
diff --git a/system/core/rootdir/cells/system/wifi.rc b/system/core/rootdir/cells/system/wifi.rc
index 71567eddd9..eceee0ae09 100644
--- a/system/core/rootdir/cells/system/wifi.rc
+++ b/system/core/rootdir/cells/system/wifi.rc
@@ -29,54 +29,54 @@ on property:sys.boot_completed=1 && property:sys.wifitracing.started=0
    # Create trace buffer, and set basic configuration.
    mkdir /sys/kernel/debug/tracing/instances/wifi 711
    restorecon_recursive /sys/kernel/debug/tracing/instances/wifi
-#   write /sys/kernel/debug/tracing/instances/wifi/tracing_on 0
-#   write /sys/kernel/debug/tracing/instances/wifi/buffer_size_kb 1
-#   write /sys/kernel/debug/tracing/instances/wifi/trace_options disable_on_free
+   write /sys/kernel/debug/tracing/instances/wifi/tracing_on 0
+   write /sys/kernel/debug/tracing/instances/wifi/buffer_size_kb 1
+   write /sys/kernel/debug/tracing/instances/wifi/trace_options disable_on_free
 
    mkdir /sys/kernel/tracing/instances/wifi 711
    restorecon_recursive /sys/kernel/tracing/instances/wifi
-#   write /sys/kernel/tracing/instances/wifi/tracing_on 0
-#   write /sys/kernel/tracing/instances/wifi/buffer_size_kb 1
-#   write /sys/kernel/tracing/instances/wifi/trace_options disable_on_free
+   write /sys/kernel/tracing/instances/wifi/tracing_on 0
+   write /sys/kernel/tracing/instances/wifi/buffer_size_kb 1
+   write /sys/kernel/tracing/instances/wifi/trace_options disable_on_free
 
    # Enable cfg80211 events for connection and key management events.
    # - Events are not actually logged until WifiService writes "1" to
    #   /sys/kernel/debug/tracing/instances/wifi/tracing_on.
    # - WifiService is responsible for turning tracing off and on.
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
 
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
 
    # Enable datapath events for Wifi.
    # - Events are not actually logged until WifiService writes "1" to
    #   /sys/kernel/debug/tracing/instances/wifi/tracing_on.
    # - WifiService will ensure that tracing is turned back off,
    #   when a connection attempt ends (whether in success or failure)
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_queue/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_rx/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_queue/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_rx/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
 
-#   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
-#   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_queue/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/netif_rx/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
+   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_queue/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/netif_rx/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
 
    # Set DAC to allow system to enable/disable, and read wifi trace
    # events.
@@ -97,5 +97,5 @@ on property:sys.boot_completed=1 && property:sys.wifitracing.started=0
 
 on property:sys.boot_completed=1 && property:wifi.interface=* && property:sys.wifitracing.started=1
    # Override default value.
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface}
-#   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface}
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface}
+   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface}
diff --git a/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc b/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
index 77a5fab5a9..e6b70e5a3a 100644
--- a/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
+++ b/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
@@ -1,9 +1,9 @@
-#service vendor.input.classifier-1-0 /vendor/bin/hw/android.hardware.input.classifier@1.0-service
-#    # Must be specified if "disabled" is set. This HAL will only start if requested via getService
-#    interface android.hardware.input.classifier@1.0::IInputClassifier default
-#    class hal
-#    user nobody
-#    # will not be restarted if it exits until it is requested to be restarted
-#    oneshot
-#    # will only be started when requested
-#    disabled
\ No newline at end of file
+service vendor.input.classifier-1-0 /vendor/bin/hw/android.hardware.input.classifier@1.0-service
+    # Must be specified if "disabled" is set. This HAL will only start if requested via getService
+    interface android.hardware.input.classifier@1.0::IInputClassifier default
+    class hal
+    user nobody
+    # will not be restarted if it exits until it is requested to be restarted
+    oneshot
+    # will only be started when requested
+    disabled
diff --git a/system/core/rootdir/cells/vendor/hw/init.oriole.rc b/system/core/rootdir/cells/vendor/hw/init.oriole.rc
index 461922098b..d509c17091 100644
--- a/system/core/rootdir/cells/vendor/hw/init.oriole.rc
+++ b/system/core/rootdir/cells/vendor/hw/init.oriole.rc
@@ -10,10 +10,10 @@ on init
 
 # Toggle glove_mode according to touch_sensitivity_mode
 on property:persist.vendor.touch_sensitivity_mode=0 && property:sys.boot_completed=1
-#   write /sys/class/spi_master/spi11/spi11.0/glove_mode 00
+    write /sys/class/spi_master/spi11/spi11.0/glove_mode 00
 
 on property:persist.vendor.touch_sensitivity_mode=1 && property:sys.boot_completed=1
-#   write /sys/class/spi_master/spi11/spi11.0/glove_mode 01
+    write /sys/class/spi_master/spi11/spi11.0/glove_mode 01
 
 on late-init && property:ro.boot.hardware.revision=PROTO1.0
     setprop vendor.thermal.config "thermal_info_config_WHI_A.json"
diff --git a/system/core/rootdir/init.rc b/system/core/rootdir/init.rc
index d28c730adc..a898c16d91 100644
--- a/system/core/rootdir/init.rc
+++ b/system/core/rootdir/init.rc
@@ -68,6 +68,8 @@ on early-init
 
     setprop ro.boot.vm 0
     setprop persist.sys.exit 0
+    setprop persist.sys.ui.exit 0
+    setprop persist.sys.iw.wlan ""
     setprop persist.logd.logpersistd logcatd
     setprop persist.sys.sdcardfs force_on
 
@@ -1287,3 +1289,12 @@ service cellsservice /system/bin/cellsservice
     user root
     group root
     seclabel  u:r:init:s0
+
+service cellsstart /system/bin/cellsstart
+    class main
+    disabled
+    oneshot
+    user root
+    group root
+    seclabel  u:r:init:s0
+
diff --git a/system/libhidl/transport/ServiceManagement.cpp b/system/libhidl/transport/ServiceManagement.cpp
index 14dcdebd30..4fc3f78b01 100644
--- a/system/libhidl/transport/ServiceManagement.cpp
+++ b/system/libhidl/transport/ServiceManagement.cpp
@@ -85,13 +85,13 @@ static bool getinithidlservice(const char* descriptor)
         "android.hardware.keymaster",
         "android.hardware.biometrics.fingerprint",
         "android.hardware.thermal",
-        "android.hardware.input.classifier",
+        //"android.hardware.input.classifier",
         "android.hardware.audio",
         "android.hardware.soundtrigger",
         "android.hardware.secure_element",
-        "android.frameworks.sensorservice",
-        "vendor.samsung_slsi.telephony.hardware.radioExternal",
+        //"android.frameworks.sensorservice",
         "android.hardware.radio",
+        "vendor.samsung_slsi.telephony.hardware.radioExternal",
         NULL
     };
 
diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
old mode 100644
new mode 100755
diff --git a/system/netd/server/NetdNativeService.h b/system/netd/server/NetdNativeService.h
old mode 100644
new mode 100755
diff --git a/system/netd/server/RouteController.cpp b/system/netd/server/RouteController.cpp
index e34953bbff..7b794f0a57 100644
--- a/system/netd/server/RouteController.cpp
+++ b/system/netd/server/RouteController.cpp
@@ -1149,8 +1149,6 @@ int RouteController::flushRoutes(const char* interface) {
 }
 
 int RouteController::Init(unsigned localNetId) {
-    if(android::base::GetProperty("ro.boot.vm", "0") == std::string("1"))
-        return 0;
     if (int ret = flushRules()) {
         return ret;
     }
diff --git a/vendor/cells/cells/celld.c b/vendor/cells/cells/celld.c
index 588c0cee89..9365fcd546 100755
--- a/vendor/cells/cells/celld.c
+++ b/vendor/cells/cells/celld.c
@@ -1079,7 +1079,7 @@ static void *__monitor_start_state(void *arg)
 {
 	char *root_path = NULL;
 	char buf[20];
-	int ret, i = 0;
+	int ret;// i = 0;
 
 	struct cell_monitor_state *cms = (struct cell_monitor_state *)arg;
 	root_path = get_root_path(cms->name);
@@ -1097,9 +1097,9 @@ static void *__monitor_start_state(void *arg)
 
 	__umount_rootmount(root_path);
 
-	sleep(2);
-	sscanf(cms->name, "cell%d",&i);
-	if(i > 0)starttether(i);
+	//sleep(2);
+	//sscanf(cms->name, "cell%d",&i);
+	//if(i > 0)starttether(i);
 
 	finish_cell_startup(cms->name);
 
diff --git a/vendor/cells/cellsservice/cellnet.c b/vendor/cells/cells/cellnet-rmnet.c
similarity index 89%
rename from vendor/cells/cellsservice/cellnet.c
rename to vendor/cells/cells/cellnet-rmnet.c
index 83c21d431b..1b2bff6969 100755
--- a/vendor/cells/cellsservice/cellnet.c
+++ b/vendor/cells/cells/cellnet-rmnet.c
@@ -12,7 +12,8 @@
 #include <cutils/memory.h>
 #include <cutils/misc.h>
 
-#define INTERFACE "wlan0"
+#define INTERFACE "rmnet_data1"
+#define VMINTERFACE "rmnet_data1"
 #define VETH0 "vm_wlan_%d_0"
 #define VETH1 "vm_wlan_%d_1"
 
@@ -91,6 +92,30 @@ void vethtons(int pid,int index)
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
 
+static int get_if_status(char *if_name)
+{
+    char buffer[BUFSIZ];
+    char cmd[100];
+    FILE *read_fp;
+    int chars_read;
+
+    memset( buffer, 0, BUFSIZ );
+    memset( cmd, 0, 100 );
+
+    sprintf(cmd, "ip link show | grep %s",if_name);
+    read_fp = popen(cmd, "r");
+    if ( read_fp != NULL )
+    {
+        chars_read = fread(buffer, sizeof(char), BUFSIZ-1, read_fp);
+        pclose(read_fp);
+        if (chars_read > 0){
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
 void rnameveth(int index)
 {
     int ret  = 0;
@@ -103,21 +128,29 @@ void rnameveth(int index)
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
     snprintf(vethaddr1, sizeof(vethaddr1), VETHIFACEADDR1, VETHIFACEADDRBASE + index);
 
+    int num = 0;
+    while(0 == get_if_status(vethname1) && num < 5)
+    {
+        num++;
+        ALOGD("rnameveth num = %d", num);
+        sleep(1);
+    }
+
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,INTERFACE );
+    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,VMINTERFACE );
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",INTERFACE,vethaddr1,VETHADDRMASK);
+    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",VMINTERFACE,vethaddr1,VETHADDRMASK);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,INTERFACE);
+    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,VMINTERFACE);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
diff --git a/vendor/cells/cells/cellnet.c b/vendor/cells/cells/cellnet.c
index e93e409790..51f8f57bef 100755
--- a/vendor/cells/cells/cellnet.c
+++ b/vendor/cells/cells/cellnet.c
@@ -11,8 +11,10 @@
 #include <cutils/log.h>
 #include <cutils/memory.h>
 #include <cutils/misc.h>
+#include <cutils/properties.h>
 
 #define INTERFACE "wlan0"
+#define VMINTERFACE "wlan0"
 #define VETH0 "vm_wlan_%d_0"
 #define VETH1 "vm_wlan_%d_1"
 
@@ -40,6 +42,12 @@ void createveth(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
@@ -82,6 +90,12 @@ void vethtons(int pid,int index)
     char vethname1[24] = {0};
     char cmd[256];
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
 
     errno = 0;
@@ -123,6 +137,24 @@ void rnameveth(int index)
     char vethaddr1[64] = {0};
     char cmd[256];
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        int i=0;
+        sscanf(value, "cell%d", &i);
+        if(index == i)
+        {
+            int num = 0;
+            while(0 == get_if_status("wlan0") && num < 5)
+            {
+                num++;
+                ALOGD("wlan0 num = %d", num);
+                sleep(1);
+            }
+        }
+        return;
+    }
+
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
     snprintf(vethaddr1, sizeof(vethaddr1), VETHIFACEADDR1, VETHIFACEADDRBASE + index);
@@ -137,19 +169,19 @@ void rnameveth(int index)
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,INTERFACE );
+    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,VMINTERFACE );
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",INTERFACE,vethaddr1,VETHADDRMASK);
+    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",VMINTERFACE,vethaddr1,VETHADDRMASK);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,INTERFACE);
+    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,VMINTERFACE);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
@@ -163,6 +195,12 @@ void starttether(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
@@ -217,6 +255,12 @@ void stoptether(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
 
     errno = 0;
@@ -247,6 +291,12 @@ void delveth(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
@@ -275,3 +325,23 @@ void delveth(int index)
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
+
+#define WLAN_PHY "phy0" 
+
+void phytons(int pid,int index)
+{
+    int ret  = 0;
+    char cmd[256];
+
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") == 0){
+        return;
+    }
+
+    errno = 0;
+    memset(cmd,0,sizeof(cmd));
+    snprintf(cmd, sizeof(cmd), "iw phy %s set netns %d", WLAN_PHY, pid);
+    ret = system(cmd);
+    ALOGD("%s index = %d errno = %s",cmd,index,strerror(errno));
+}
diff --git a/vendor/cells/cells/cellnet.h b/vendor/cells/cells/cellnet.h
index bcc4e67414..86163746d5 100755
--- a/vendor/cells/cells/cellnet.h
+++ b/vendor/cells/cells/cellnet.h
@@ -13,6 +13,7 @@ extern void rnameveth(int index);
 extern void starttether(int index);
 extern void stoptether(int index);
 extern void delveth(int index);
+extern void phytons(int pid,int index);
 
 #ifdef __cplusplus
 }
diff --git a/vendor/cells/cells/nsexec.c b/vendor/cells/cells/nsexec.c
index ffb6ffc6e4..e68a60182f 100755
--- a/vendor/cells/cells/nsexec.c
+++ b/vendor/cells/cells/nsexec.c
@@ -753,8 +753,13 @@ int cell_nsexec(int sd, struct cell_args *cell_args,
 		sscanf(cell_args->cellname, "cell%d",&i);
 		if(i > 0){
 			createveth(i);
-
 			vethtons(pid,i);
+
+			int index = 0;
+			char value[PROPERTY_VALUE_MAX] = {0};
+			property_get("persist.sys.iw.wlan", value, "");
+			sscanf(value, "cell%d", &index);
+			if(i == index) phytons(pid,i);
 		}
 	}
 
diff --git a/vendor/cells/cells/virtual_network.c b/vendor/cells/cells/virtual_network.c
old mode 100644
new mode 100755
diff --git a/vendor/cells/cells_build.mk b/vendor/cells/cells_build.mk
index 99c08b1562..c39b84c3c8 100755
--- a/vendor/cells/cells_build.mk
+++ b/vendor/cells/cells_build.mk
@@ -6,5 +6,6 @@ PRODUCT_PACKAGES += \
 	cellssync \
 	cellsupdownvm \
 	cswitch \
+        cellsstart \
 	busybox \
 	virtualcamera
diff --git a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
index 4bbef17bd5..e6b3f80f74 100755
--- a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
+++ b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
@@ -2,6 +2,8 @@ package com.cells.systemswitch.secure.view;
 
 import android.util.Log;
 import android.app.Activity;
+import android.app.ContainerManager;
+import android.content.Context;
 import android.os.Bundle;
 import android.view.View;
 import android.view.WindowManager;
@@ -28,10 +30,12 @@ import java.lang.RuntimeException;
 
 public class SecureSwitchActivity extends Activity {
 	private static final String TAG = "SecureSwitchActivity";
+    private ContainerManager mContainerManager;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
+        mContainerManager = (ContainerManager) getSystemService(Context.CONTAINER_SERVICE);
 
 		if(!SystemProperties.get("ro.boot.vm","1").equals("0")){
 			CellsPrivateServiceMgr mCellsService;
@@ -41,8 +45,8 @@ public class SecureSwitchActivity extends Activity {
 			String name = (SystemProperties.get("ro.boot.vm.name","").equals("cell1")?"cell2":"cell1");
 			try{
 				disableAdapter();
-				mCellsService.switchCellsVm("host");
 				//mCellsService.switchCellsVm(name);
+                mContainerManager.switchCellsVm(name);
 			}catch(RuntimeException e){
 				e.printStackTrace();
 			}
diff --git a/vendor/cells/cellsservice/Android.mk b/vendor/cells/cellsservice/Android.mk
index ae4b73406c..d60cb03456 100755
--- a/vendor/cells/cellsservice/Android.mk
+++ b/vendor/cells/cellsservice/Android.mk
@@ -12,7 +12,7 @@ LOCAL_SRC_FILES:= \
 	CellsPrivateService.cpp \
 	ICellsPrivateService.cpp \
 	main_cells.cpp \
-	cellnet.c
+	../cells/cellnet.c
 
 LOCAL_MODULE := cellsservice
 LOCAL_MODULE_TAGS := optional
@@ -52,7 +52,7 @@ include $(BUILD_EXECUTABLE)
 
 
 
-#sync
+#down
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
@@ -78,4 +78,18 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE_OWNER := cells
 #LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
 LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils liblog
+include $(BUILD_EXECUTABLE)
+
+#start
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	cellsstart.cpp \
+	ICellsPrivateService.cpp
+
+LOCAL_MODULE:= cellsstart
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := cells
+#LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
+LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils libgui libpowermanager liblog libbase
 include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/CellsPrivateService.cpp b/vendor/cells/cellsservice/CellsPrivateService.cpp
index 6b25664673..7f0b302b51 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/CellsPrivateService.cpp
@@ -13,6 +13,7 @@
 #include <cutils/log.h>
 #include <cutils/properties.h>
 #include "CellsPrivateService.h"
+#include "../cells/cellnet.h"
 
 #include <binder/IServiceManager.h>
 #include <gui/ISurfaceComposer.h>
@@ -70,8 +71,6 @@ status_t CellsPrivateService::setProperty(const String16& name,const String16& v
 
 status_t CellsPrivateService::startCellsVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc start %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("STARTCELLSVM cmd = %s", cmd);
@@ -81,8 +80,6 @@ status_t CellsPrivateService::startCellsVM(const String16& name)
 
 status_t CellsPrivateService::stopCellsVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc stop %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("STOPCELLSVM cmd = %s", cmd);
@@ -92,8 +89,6 @@ status_t CellsPrivateService::stopCellsVM(const String16& name)
 
 status_t CellsPrivateService::cellsSwitchVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc switch %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("CELLSSWITCHVM cmd = %s", cmd);
@@ -102,10 +97,8 @@ status_t CellsPrivateService::cellsSwitchVM(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::cellsSwitchHOST(const String16& name)
+status_t CellsPrivateService::cellsSwitchHOST(const String16& /*name*/)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc switch host");
     SYSTEMPRIVATE_LOGD("CELLSSWITCHHOST cmd = %s", cmd);
@@ -114,10 +107,8 @@ status_t CellsPrivateService::cellsSwitchHOST(const String16& name)
     return NO_ERROR;
 }
 
-static void* gotosleep(void* o)
+static void* gotosleep(void* /*o*/)
 {
-    o;
-
     {
         android::sp<android::IServiceManager> sm = android::defaultServiceManager();
         android::sp<android::os::IPowerManager> mPowerManager = 
@@ -147,8 +138,6 @@ static void create_gotosleep_pthread(void)
 status_t CellsPrivateService::switchCellsVM(const String16& name)
 {
     int i = 0;
-    char value[PROPERTY_VALUE_MAX];
-    char pname[PATH_MAX];
     char curname[PROPERTY_VALUE_MAX] = {0};
 
     property_get("ro.boot.vm.name", curname, "");
@@ -164,12 +153,17 @@ status_t CellsPrivateService::switchCellsVM(const String16& name)
     }
 
     if(strcmp(String8(name).string(), "host") != 0){
-        memset(value,0,PROPERTY_VALUE_MAX);
-        memset(pname,0,PATH_MAX);
-        sprintf(pname, "persist.sys.%s.init",  String8(name).string());
-        property_get(pname, value, "0");
-        if((strcmp(value, "0") == 0))
+        if(strcmp(curname, "") == 0){
+            if(isVMSystemReady(name) == 0)
+                return 0;
+        }
+
+        android::sp<android::IServiceManager> sm = android::initdefaultServiceManager();
+        android::sp<android::ICellsPrivateService> mCellsPrivateService = 
+        android::interface_cast<android::ICellsPrivateService>(sm->checkService(android::String16("CellsPrivateService")));
+        if(mCellsPrivateService != NULL && mCellsPrivateService->isVMSystemReady(name) == 0){
             return 0;
+        }
     }
 
     if(strcmp(curname, "") == 0){
@@ -230,23 +224,12 @@ status_t CellsPrivateService::switchCellsVM(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::enterHost(const String16& name)
+status_t CellsPrivateService::enterHost(const String16& /*name*/)
 {
-    name;
-
     {
         property_set("persist.sys.exit", "0");
     }
 
-    {
-        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
-        android::sp<android::ISurfaceComposer> mComposer = 
-            android::interface_cast<android::ISurfaceComposer>(sm->checkService(android::String16("SurfaceFlinger")));
-        if(mComposer != NULL){
-            mComposer->enterSelf();
-        }
-    }
-
     {
         android::sp<android::IServiceManager> sm = android::defaultServiceManager();
         android::sp<android::os::IPowerManager> mPowerManager = 
@@ -259,6 +242,15 @@ status_t CellsPrivateService::enterHost(const String16& name)
         }
     }
 
+    {
+        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
+        android::sp<android::ISurfaceComposer> mComposer = 
+            android::interface_cast<android::ISurfaceComposer>(sm->checkService(android::String16("SurfaceFlinger")));
+        if(mComposer != NULL){
+            mComposer->enterSelf();
+        }
+    }
+
     {
         property_set("ctl.restart", "adbd");
     }
@@ -275,10 +267,8 @@ status_t CellsPrivateService::enterHost(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::exitHost(const String16& name)
+status_t CellsPrivateService::exitHost(const String16& /*name*/)
 {
-    name;
-
     {
         property_set("persist.sys.exit", "1");
     }
@@ -315,10 +305,8 @@ static void write_vm_exit(bool bexit){
     }
 }
 
-status_t CellsPrivateService::enterCell(const String16& name)
+status_t CellsPrivateService::enterCell(const String16& /*name*/)
 {
-    name;
-
     {
         write_vm_exit(false);
         property_set("persist.sys.exit", "0");
@@ -329,7 +317,10 @@ status_t CellsPrivateService::enterCell(const String16& name)
         android::sp<android::os::IPowerManager> mPowerManager = 
             android::interface_cast<android::os::IPowerManager>(sm->checkService(android::String16("power")));
         if(mPowerManager != NULL){
-            mPowerManager->goToSleep(long(ns2ms(systemTime())),android::os::IPowerManager::GO_TO_SLEEP_REASON_POWER_BUTTON,0);
+            mPowerManager->wakeUp(long(ns2ms(systemTime())),WAKE_REASON_POWER_BUTTON,
+                            android::String16("enter_self"),android::String16("CellsPrivateService"));
+        }else{
+            SYSTEMPRIVATE_LOGD("mPowerManager = 0");
         }
     }
 
@@ -342,18 +333,6 @@ status_t CellsPrivateService::enterCell(const String16& name)
         }
     }
 
-    {
-        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
-        android::sp<android::os::IPowerManager> mPowerManager = 
-            android::interface_cast<android::os::IPowerManager>(sm->checkService(android::String16("power")));
-        if(mPowerManager != NULL){
-            mPowerManager->wakeUp(long(ns2ms(systemTime())),WAKE_REASON_POWER_BUTTON,
-                            android::String16("enter_self"),android::String16("CellsPrivateService"));
-        }else{
-            SYSTEMPRIVATE_LOGD("mPowerManager = 0");
-        }
-    }
-
     {
         property_set("ctl.restart", "adbd");
     }
@@ -366,10 +345,8 @@ status_t CellsPrivateService::enterCell(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::exitCell(const String16& name)
+status_t CellsPrivateService::exitCell(const String16& /*name*/)
 {
-    name;
-
     {
         write_vm_exit(true);
         property_set("persist.sys.exit", "1");
@@ -396,39 +373,28 @@ status_t CellsPrivateService::exitCell(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::uploadCellsVM(const String16& name)
+status_t CellsPrivateService::uploadCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::downloadCellsVM(const String16& name)
+status_t CellsPrivateService::downloadCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::untarCellsVM(const String16& name)
+status_t CellsPrivateService::untarCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::tarCellsVM(const String16& name)
+status_t CellsPrivateService::tarCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::sendCellsVM(const String16& path, const String16& address)
+status_t CellsPrivateService::sendCellsVM(const String16& /*path*/, const String16& /*address*/)
 {
-    path;
-    address;
-
     return NO_ERROR;
 }
 
@@ -480,16 +446,40 @@ status_t CellsPrivateService::cfgNetProxy(int32_t sysid, const String16& ifName,
 status_t CellsPrivateService::vmSystemReady(const String16& name)
 {
     char pname[PATH_MAX] = {0};
+    int i = 0;
 
     sprintf(pname, "persist.sys.%s.init",  String8(name).string());
     property_set(pname, "1");
 
     property_set("ctl.restart", "adbd");
 
-    chown("/dev/sg1", 1000, 1000);
+    sscanf(String8(name).string(), "cell%d",&i);
+    starttether(i);
+
+    //chown("/dev/sg1", 1000, 1000);
 
     SYSTEMPRIVATE_LOGD("SYSTEMREADY name = %s", String8(name).string());
     return NO_ERROR;
 }
 
+status_t CellsPrivateService::isVMSystemReady(const String16& name)
+{
+    char pname[PATH_MAX] = {0};
+    char value[PROPERTY_VALUE_MAX] = {0};
+
+    status_t ret = 0;
+    if(strcmp(String8(name).string(), "host") == 0){
+        ret = 1;
+    }
+
+    sprintf(pname, "persist.sys.%s.init",  String8(name).string());
+    property_get(pname, value, "0");
+    if(strcmp(String8(value).string(), "1") == 0){
+        ret = 1;
+    }
+
+    SYSTEMPRIVATE_LOGD("ISVMSYSTEMREADY name = %s ret = %d", String8(name).string(), ret);
+    return ret;
+}
+
 };
diff --git a/vendor/cells/cellsservice/CellsPrivateService.h b/vendor/cells/cellsservice/CellsPrivateService.h
index edcf3b5c9b..4045623192 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.h
+++ b/vendor/cells/cellsservice/CellsPrivateService.h
@@ -39,6 +39,7 @@ public:
     virtual status_t vmSystemReady(const String16& name);
     virtual status_t sendCellsVM(const String16& path, const String16& address);
     virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop);
+	virtual status_t isVMSystemReady(const String16& name);
 
     int isInCellstar();
     void setCellstaring();
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.cpp b/vendor/cells/cellsservice/ICellsPrivateService.cpp
index 1a6ff6eb35..0a075ebf37 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/ICellsPrivateService.cpp
@@ -264,6 +264,20 @@ public:
         result = reply.readInt32();
         return result;
     }
+	
+	virtual status_t isVMSystemReady(const String16& name)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICellsPrivateService::getInterfaceDescriptor());
+        data.writeString16(name);
+        status_t result = remote()->transact(ISVMACTIVE, data, &reply);
+        if (result != NO_ERROR) {
+            ALOGE("isVMSystemReady VM err!\n");
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
 };
 
 IMPLEMENT_META_INTERFACE(CellsPrivateService, "CellsPrivateService");
@@ -445,6 +459,16 @@ status_t BnCellsPrivateService::onTransact(uint32_t code, const Parcel& data, Pa
             reply->writeInt32(result);
             return NO_ERROR;
         }
+        break;
+		case ISVMACTIVE:
+        {
+            CHECK_INTERFACE(ICellsPrivateService, data, reply);
+            String16 name = data.readString16();
+
+            status_t result = isVMSystemReady(name);
+            reply->writeInt32(result);
+            return NO_ERROR;
+        }
         break;
     }
     return BBinder::onTransact(code, data, reply, flags);
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.h b/vendor/cells/cellsservice/ICellsPrivateService.h
index acc20322bf..34bd314f29 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.h
+++ b/vendor/cells/cellsservice/ICellsPrivateService.h
@@ -32,6 +32,7 @@ protected:
         EXITHOST = IBinder::FIRST_CALL_TRANSACTION + 14,
         SENDCELLSVM = IBinder::FIRST_CALL_TRANSACTION + 15,
         CFG_NET_PROXY = IBinder::FIRST_CALL_TRANSACTION + 16,
+		ISVMACTIVE = IBinder::FIRST_CALL_TRANSACTION + 17,
     };
 
 public:
@@ -54,6 +55,7 @@ public:
     virtual status_t vmSystemReady(const String16& name) = 0;
     virtual status_t sendCellsVM(const String16& path, const String16& address) = 0;
     virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop) = 0;
+	virtual status_t isVMSystemReady(const String16& name) = 0;
 };
 
 class BnCellsPrivateService : public BnInterface<ICellsPrivateService>
diff --git a/vendor/cells/cellsservice/cellnet.h b/vendor/cells/cellsservice/cellnet.h
deleted file mode 100755
index bcc4e67414..0000000000
--- a/vendor/cells/cellsservice/cellnet.h
+++ /dev/null
@@ -1,21 +0,0 @@
-
-#ifndef __CELLNET_H
-#define __CELLNET_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern void init_cell_net();
-extern void createveth(int index);
-extern void vethtons(int pid,int index);
-extern void rnameveth(int index);
-extern void starttether(int index);
-extern void stoptether(int index);
-extern void delveth(int index);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CELLNET_H */
diff --git a/vendor/cells/cellsservice/cellsstart.cpp b/vendor/cells/cellsservice/cellsstart.cpp
new file mode 100755
index 0000000000..956a791750
--- /dev/null
+++ b/vendor/cells/cellsservice/cellsstart.cpp
@@ -0,0 +1,75 @@
+#define LOG_TAG "CELLSSTART"
+#include <stdio.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/select.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <binder/BinderService.h>
+#include <android-base/properties.h>
+#include "ICellsPrivateService.h"
+
+using namespace android;
+
+int main(int /*argc*/, char** /*argv*/)
+{
+	property_set("persist.sys.ui.exit", "1");
+	property_set("persist.sys.iw.wlan", "cell1");
+
+	const sp<IServiceManager> sm = defaultServiceManager();
+	sp<ICellsPrivateService> pCellsPrivateService = NULL;
+	if (sm != NULL)
+	{
+		sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
+        while(binder == NULL){
+            sleep(1);
+
+            binder = sm->checkService(String16("CellsPrivateService"));
+        }
+
+        pCellsPrivateService = interface_cast<ICellsPrivateService>(binder);
+        if(pCellsPrivateService == NULL){
+            ALOGE("could not get service CellsPrivateService");
+            return 0;
+        }
+	}
+
+	sleep(1);
+
+	if(android::base::GetProperty("persist.sys.cell1.init", "0") == std::string("0"))
+	{
+		ALOGD("Start cell1");
+		pCellsPrivateService->startCellsVM(android::String16("cell1"));
+		ALOGD("Started cell1");
+	}
+
+	property_set("persist.sys.active", "cell1");
+
+	if(android::base::GetProperty("persist.sys.cell2.init", "0") == std::string("0"))
+	{
+		ALOGD("Start cell2");
+		pCellsPrivateService->startCellsVM(android::String16("cell2"));
+		ALOGD("Started cell2");
+	}
+
+	while(android::base::GetProperty("persist.sys.cell1.init", "0") == std::string("0"))
+	{
+		sleep(3);
+	}
+
+	ALOGD("Switch cell1");
+	pCellsPrivateService->switchCellsVM(android::String16("cell1"));
+	ALOGD("Switched cell1");
+
+    return 0;
+}
diff --git a/vendor/cells/cellsservice/cellssync.cpp b/vendor/cells/cellsservice/cellssync.cpp
index 752fa0fa9b..14bc56d186 100755
--- a/vendor/cells/cellsservice/cellssync.cpp
+++ b/vendor/cells/cellsservice/cellssync.cpp
@@ -8,7 +8,7 @@ using namespace android;
 
 int main(int argc, char** argv)
 {
-    /*const sp<IServiceManager> sm = initdefaultServiceManager();
+    const sp<IServiceManager> sm = initdefaultServiceManager();
     if (sm != NULL) {
         sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
         if (binder != NULL) {
@@ -26,7 +26,7 @@ int main(int argc, char** argv)
                 pCellsPrivateService->setProperty(android::String16(argv[1]),android::String16(argv[2]));
             }
         }
-    }*/
+    }
 
     return 0;
 }
diff --git a/vendor/cells/cellsservice/cswitch.cpp b/vendor/cells/cellsservice/cswitch.cpp
index 5d0d3ef1cb..bc23476900 100755
--- a/vendor/cells/cellsservice/cswitch.cpp
+++ b/vendor/cells/cellsservice/cswitch.cpp
@@ -8,7 +8,7 @@ using namespace android;
 
 int main(int argc, char** argv)
 {
-   const sp<IServiceManager> sm = defaultServiceManager();
+    const sp<IServiceManager> sm = defaultServiceManager();
     if (sm != NULL) {
         sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
         if (binder != NULL) {
diff --git a/vendor/cells/cellsservice/main_cells.cpp b/vendor/cells/cellsservice/main_cells.cpp
index af007c3a5c..b93b66e6e8 100755
--- a/vendor/cells/cellsservice/main_cells.cpp
+++ b/vendor/cells/cellsservice/main_cells.cpp
@@ -7,11 +7,11 @@
 #include <binder/BinderService.h>
 #include <CellsPrivateService.h>
 
-#include "cellnet.h"
+#include "../cells/cellnet.h"
 
 using namespace android;
 
-/*static int get_vm_index()
+static int get_vm_index()
 {
 	int index = 0;
 	char value[PROPERTY_VALUE_MAX] = {0};
@@ -20,7 +20,7 @@ using namespace android;
 
 	ALOGD("VM Index = %d", index);
 	return index;
-}*/
+}
 
 int main(int /*argc*/, char** /*argv*/)
 {
@@ -32,18 +32,28 @@ int main(int /*argc*/, char** /*argv*/)
 		//property_set("persist.sys.exit", "0");
 		//property_set("persist.sys.active", "");
 
-		property_set("ctl.stop", "vendor.adsprpcd");
-		property_set("ctl.stop", "vendor.sensors");
+		//property_set("ctl.stop", "vendor.qcrild");
+		//property_set("ctl.stop", "vendor.qcrild2");
+		//property_set("ctl.stop", "vendor.qcrild3");
+		//property_set("ctl.stop", "vendor.adsprpcd");
+		//property_set("ctl.stop", "vendor.sensors");
+
+		property_set("ctl.start", "cellsstart");
 	}else{
-		property_set("ctl.stop", "vendor.adsprpcd");
-		property_set("ctl.stop", "vendor.sensors");
-		property_set("ctl.stop", "adbd");
+		//property_set("ctl.stop", "vendor.qcrild");
+		//property_set("ctl.stop", "vendor.qcrild2");
+		//property_set("ctl.stop", "vendor.qcrild3");
+		//property_set("ctl.stop", "vendor.adsprpcd");
+		//property_set("ctl.stop", "vendor.sensors");
+		//property_set("ctl.stop", "adbd");
 		//property_set("persist.sys.exit", "1");
-
-		/*int i = get_vm_index();
-		if(i > 0){
-			rnameveth(i);
-		}*/
+		
+		int i = get_vm_index();
+		if(i == 1){
+			property_set("persist.sys.cells.netagent", "cell1");
+		}else if (i == 2){
+			property_set("persist.sys.cells.netagent", "cell2");
+		}
 	}
 
 	CellsPrivateService::publishAndJoinThreadPool(true);
-- 
2.17.1

From 8606e16ad4497c954e43e966fee9672a989c1622 Mon Sep 17 00:00:00 2001
From: ngf <ngf@xdja.com>
Date: Wed, 17 Aug 2022 19:31:58 +0800
Subject: [PATCH 02/11] disable wifi permission check

---
 .../android/server/wifi/WifiServiceImpl.java  | 100 ++++++-----
 .../server/wifi/util/WifiPermissionsUtil.java | 167 ++++++++++--------
 2 files changed, 152 insertions(+), 115 deletions(-)
 mode change 100644 => 100755 packages/modules/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
 mode change 100644 => 100755 packages/modules/Wifi/service/java/com/android/server/wifi/util/WifiPermissionsUtil.java

diff --git a/packages/modules/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java b/packages/modules/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
old mode 100644
new mode 100755
index 24944c0850..d4e92cb64b
--- a/packages/modules/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
+++ b/packages/modules/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
@@ -702,28 +702,33 @@ public class WifiServiceImpl extends BaseWifiService {
     }
 
     private boolean checkNetworkSettingsPermission(int pid, int uid) {
-        return mContext.checkPermission(android.Manifest.permission.NETWORK_SETTINGS, pid, uid)
-                == PERMISSION_GRANTED;
+        /*return mContext.checkPermission(android.Manifest.permission.NETWORK_SETTINGS, pid, uid)
+                == PERMISSION_GRANTED;*/
+		return true;
     }
 
     private boolean checkNetworkSetupWizardPermission(int pid, int uid) {
-        return mContext.checkPermission(android.Manifest.permission.NETWORK_SETUP_WIZARD, pid, uid)
-                == PackageManager.PERMISSION_GRANTED;
+        /*return mContext.checkPermission(android.Manifest.permission.NETWORK_SETUP_WIZARD, pid, uid)
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     private boolean checkMainlineNetworkStackPermission(int pid, int uid) {
-        return mContext.checkPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, pid, uid)
-                == PackageManager.PERMISSION_GRANTED;
+        /*return mContext.checkPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, pid, uid)
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     private boolean checkNetworkStackPermission(int pid, int uid) {
-        return mContext.checkPermission(android.Manifest.permission.NETWORK_STACK, pid, uid)
-                == PackageManager.PERMISSION_GRANTED;
+        /*return mContext.checkPermission(android.Manifest.permission.NETWORK_STACK, pid, uid)
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     private boolean checkNetworkManagedProvisioningPermission(int pid, int uid) {
-        return mContext.checkPermission(android.Manifest.permission.NETWORK_MANAGED_PROVISIONING,
-                pid, uid) == PackageManager.PERMISSION_GRANTED;
+        /*return mContext.checkPermission(android.Manifest.permission.NETWORK_MANAGED_PROVISIONING,
+                pid, uid) == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
@@ -731,17 +736,19 @@ public class WifiServiceImpl extends BaseWifiService {
      * permissions.
      */
     private boolean isPrivileged(int pid, int uid) {
-        return checkNetworkSettingsPermission(pid, uid)
+        /*return checkNetworkSettingsPermission(pid, uid)
                 || checkNetworkSetupWizardPermission(pid, uid)
                 || checkNetworkStackPermission(pid, uid)
                 || checkNetworkManagedProvisioningPermission(pid, uid)
-                || isSignedWithPlatformKey(uid);
+                || isSignedWithPlatformKey(uid);*/
+		return true;
     }
 
     /** Whether the uid is signed with the same key as the platform. */
     private boolean isSignedWithPlatformKey(int uid) {
-        return mContext.getPackageManager().checkSignatures(uid, Process.SYSTEM_UID)
-                == PackageManager.SIGNATURE_MATCH;
+        /*return mContext.getPackageManager().checkSignatures(uid, Process.SYSTEM_UID)
+                == PackageManager.SIGNATURE_MATCH;*/
+		return true;
     }
 
     /**
@@ -749,57 +756,59 @@ public class WifiServiceImpl extends BaseWifiService {
      * permissions.
      */
     private boolean isSettingsOrSuw(int pid, int uid) {
-        return checkNetworkSettingsPermission(pid, uid)
-                || checkNetworkSetupWizardPermission(pid, uid);
+        //return checkNetworkSettingsPermission(pid, uid)
+        //        || checkNetworkSetupWizardPermission(pid, uid);
+		return true;
     }
 
     /** Helper method to check if the entity initiating the binder call is a DO/PO app. */
     private boolean isDeviceOrProfileOwner(int uid, String packageName) {
-        return mWifiPermissionsUtil.isDeviceOwner(uid, packageName)
-                || mWifiPermissionsUtil.isProfileOwner(uid, packageName);
+        //return mWifiPermissionsUtil.isDeviceOwner(uid, packageName)
+        //        || mWifiPermissionsUtil.isProfileOwner(uid, packageName);
+		return true;
     }
 
     private void enforceNetworkSettingsPermission() {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_SETTINGS,
-                "WifiService");
+        //mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_SETTINGS,
+        //        "WifiService");
     }
 
     private boolean checkAnyPermissionOf(String... permissions) {
-        for (String permission : permissions) {
+        /*for (String permission : permissions) {
             if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {
                 return true;
             }
-        }
-        return false;
+        }*/
+        return true;
     }
 
     private void enforceAnyPermissionOf(String... permissions) {
-        if (!checkAnyPermissionOf(permissions)) {
+        /*if (!checkAnyPermissionOf(permissions)) {
             throw new SecurityException("Requires one of the following permissions: "
                     + String.join(", ", permissions) + ".");
-        }
+        }*/
     }
 
     private void enforceNetworkStackPermission() {
         // TODO(b/142554155): Only check for MAINLINE_NETWORK_STACK permission
-        boolean granted = mContext.checkCallingOrSelfPermission(
+        /*boolean granted = mContext.checkCallingOrSelfPermission(
                 android.Manifest.permission.NETWORK_STACK)
                 == PackageManager.PERMISSION_GRANTED;
         if (granted) {
             return;
         }
         mContext.enforceCallingOrSelfPermission(
-                NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, "WifiService");
+                NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, "WifiService");*/
     }
 
     private void enforceAccessPermission() {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_WIFI_STATE,
-                "WifiService");
+        /*mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_WIFI_STATE,
+                "WifiService");*/
     }
 
     private void enforceRestartWifiSubsystemPermission() {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RESTART_WIFI_SUBSYSTEM,
-                "WifiService");
+        /*mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RESTART_WIFI_SUBSYSTEM,
+                "WifiService");*/
     }
 
     /**
@@ -812,7 +821,7 @@ public class WifiServiceImpl extends BaseWifiService {
      */
     @CheckResult
     private int enforceChangePermission(String callingPackage) {
-        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
+        /*mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
         if (checkNetworkSettingsPermission(Binder.getCallingPid(), Binder.getCallingUid())) {
             return MODE_ALLOWED;
         }
@@ -820,28 +829,29 @@ public class WifiServiceImpl extends BaseWifiService {
                 "WifiService");
 
         return mAppOps.noteOp(
-                AppOpsManager.OPSTR_CHANGE_WIFI_STATE, Binder.getCallingUid(), callingPackage);
+                AppOpsManager.OPSTR_CHANGE_WIFI_STATE, Binder.getCallingUid(), callingPackage);*/
+		return MODE_ALLOWED;
     }
 
     private void enforceReadCredentialPermission() {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_WIFI_CREDENTIAL,
-                                                "WifiService");
+        /*mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_WIFI_CREDENTIAL,
+                                                "WifiService");*/
     }
 
     private void enforceMulticastChangePermission() {
-        mContext.enforceCallingOrSelfPermission(
+        /*mContext.enforceCallingOrSelfPermission(
                 android.Manifest.permission.CHANGE_WIFI_MULTICAST_STATE,
-                "WifiService");
+                "WifiService");*/
     }
 
     private void enforceConnectivityInternalPermission() {
-        mContext.enforceCallingOrSelfPermission(
+        /*mContext.enforceCallingOrSelfPermission(
                 android.Manifest.permission.CONNECTIVITY_INTERNAL,
-                "ConnectivityService");
+                "ConnectivityService");*/
     }
 
     private void enforceLocationPermission(String pkgName, @Nullable String featureId, int uid) {
-        mWifiPermissionsUtil.enforceLocationPermission(pkgName, featureId, uid);
+        //mWifiPermissionsUtil.enforceLocationPermission(pkgName, featureId, uid);
     }
 
     /**
@@ -850,12 +860,13 @@ public class WifiServiceImpl extends BaseWifiService {
      * Note: Invoke mAppOps.checkPackage(uid, packageName) before to ensure correct package name.
      */
     private boolean isTargetSdkLessThanQOrPrivileged(String packageName, int pid, int uid) {
-        return mWifiPermissionsUtil.isTargetSdkLessThan(packageName, Build.VERSION_CODES.Q, uid)
+        /*return mWifiPermissionsUtil.isTargetSdkLessThan(packageName, Build.VERSION_CODES.Q, uid)
                 || isPrivileged(pid, uid)
                 || isDeviceOrProfileOwner(uid, packageName)
                 || mWifiPermissionsUtil.isSystem(packageName, uid)
                 // TODO(b/140540984): Remove this bypass.
-                || mWifiPermissionsUtil.checkSystemAlertWindowPermission(uid, packageName);
+                || mWifiPermissionsUtil.checkSystemAlertWindowPermission(uid, packageName);*/
+		return true;
     }
 
     /**
@@ -864,10 +875,11 @@ public class WifiServiceImpl extends BaseWifiService {
      * Note: Invoke mAppOps.checkPackage(uid, packageName) before to ensure correct package name.
      */
     private boolean isTargetSdkLessThanROrPrivileged(String packageName, int pid, int uid) {
-        return mWifiPermissionsUtil.isTargetSdkLessThan(packageName, Build.VERSION_CODES.R, uid)
+        /*return mWifiPermissionsUtil.isTargetSdkLessThan(packageName, Build.VERSION_CODES.R, uid)
                 || isPrivileged(pid, uid)
                 || isDeviceOrProfileOwner(uid, packageName)
-                || mWifiPermissionsUtil.isSystem(packageName, uid);
+                || mWifiPermissionsUtil.isSystem(packageName, uid);*/
+		return true;
     }
 
     /**
diff --git a/packages/modules/Wifi/service/java/com/android/server/wifi/util/WifiPermissionsUtil.java b/packages/modules/Wifi/service/java/com/android/server/wifi/util/WifiPermissionsUtil.java
old mode 100644
new mode 100755
index 5845f74809..9a4d3d1474
--- a/packages/modules/Wifi/service/java/com/android/server/wifi/util/WifiPermissionsUtil.java
+++ b/packages/modules/Wifi/service/java/com/android/server/wifi/util/WifiPermissionsUtil.java
@@ -80,8 +80,9 @@ public class WifiPermissionsUtil {
      * @return true if the app does have the permission, false otherwise.
      */
     public boolean checkConfigOverridePermission(int uid) {
-        int permission = mWifiPermissionsWrapper.getOverrideWifiConfigPermission(uid);
-        return permission == PackageManager.PERMISSION_GRANTED;
+        /*int permission = mWifiPermissionsWrapper.getOverrideWifiConfigPermission(uid);
+        return permission == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
@@ -92,18 +93,18 @@ public class WifiPermissionsUtil {
      * @param uid The uid of the package
      */
     public void enforceLocationPermission(String pkgName, @Nullable String featureId, int uid) {
-        if (!checkCallersLocationPermission(pkgName, featureId,
-                uid, /* coarseForTargetSdkLessThanQ */ true, null)) {
-            throw new SecurityException(
-                    "UID " + uid + " does not have Coarse/Fine Location permission");
-        }
+        //if (!checkCallersLocationPermission(pkgName, featureId,
+        //        uid, /* coarseForTargetSdkLessThanQ */ true, null)) {
+        //    throw new SecurityException(
+         //           "UID " + uid + " does not have Coarse/Fine Location permission");
+        //}
     }
 
     /**
      * Checks whether than the target SDK of the package is less than the specified version code.
      */
     public boolean isTargetSdkLessThan(String packageName, int versionCode, int callingUid) {
-        long ident = Binder.clearCallingIdentity();
+        /*long ident = Binder.clearCallingIdentity();
         try {
             final int targetSdkVersion;
             if (SdkLevel.isAtLeastS()) {
@@ -125,7 +126,8 @@ public class WifiPermissionsUtil {
             return false;
         } finally {
             Binder.restoreCallingIdentity(ident);
-        }
+        }*/
+		return true;
     }
 
     /**
@@ -143,7 +145,7 @@ public class WifiPermissionsUtil {
      */
     public boolean checkCallersLocationPermission(String pkgName, @Nullable String featureId,
             int uid, boolean coarseForTargetSdkLessThanQ, @Nullable String message) {
-        boolean isTargetSdkLessThanQ = isTargetSdkLessThan(pkgName, Build.VERSION_CODES.Q, uid);
+        /*boolean isTargetSdkLessThanQ = isTargetSdkLessThan(pkgName, Build.VERSION_CODES.Q, uid);
 
         String permissionType = Manifest.permission.ACCESS_FINE_LOCATION;
         if (coarseForTargetSdkLessThanQ && isTargetSdkLessThanQ) {
@@ -185,8 +187,8 @@ public class WifiPermissionsUtil {
                     + ": coarseForTargetSdkLessThanQ=" + coarseForTargetSdkLessThanQ
                     + ", isTargetSdkLessThanQ=" + isTargetSdkLessThanQ);
 
-        }
-        return false;
+        }*/
+        return true;
     }
 
     /**
@@ -198,9 +200,9 @@ public class WifiPermissionsUtil {
      */
     public void enforceFineLocationPermission(String pkgName, @Nullable String featureId,
             int uid) {
-        if (!checkCallersFineLocationPermission(pkgName, featureId, uid, false)) {
+        /*if (!checkCallersFineLocationPermission(pkgName, featureId, uid, false)) {
             throw new SecurityException("UID " + uid + " does not have Fine Location permission");
-        }
+        }*/
     }
 
     /**
@@ -216,7 +218,7 @@ public class WifiPermissionsUtil {
      */
     private boolean checkCallersFineLocationPermission(String pkgName, @Nullable String featureId,
             int uid, boolean hideFromAppOps) {
-        // Having FINE permission implies having COARSE permission (but not the reverse)
+        /*// Having FINE permission implies having COARSE permission (but not the reverse)
         if (mWifiPermissionsWrapper.getUidPermission(
                 Manifest.permission.ACCESS_FINE_LOCATION, uid)
                 == PackageManager.PERMISSION_DENIED) {
@@ -228,7 +230,8 @@ public class WifiPermissionsUtil {
         } else {
             return noteAppOpAllowed(AppOpsManager.OPSTR_FINE_LOCATION, pkgName, featureId, uid,
                     null);
-        }
+        }*/
+		return true;
     }
 
     /**
@@ -237,8 +240,9 @@ public class WifiPermissionsUtil {
      * @param uid The uid of the package
      */
     public boolean checkCallersHardwareLocationPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(Manifest.permission.LOCATION_HARDWARE, uid)
-                == PackageManager.PERMISSION_GRANTED;
+        //return mWifiPermissionsWrapper.getUidPermission(Manifest.permission.LOCATION_HARDWARE, uid)
+        //        == PackageManager.PERMISSION_GRANTED;
+		return true;
     }
 
     /**
@@ -253,7 +257,7 @@ public class WifiPermissionsUtil {
     public void enforceCanAccessScanResults(String pkgName, @Nullable String featureId, int uid,
             @Nullable String message)
             throws SecurityException {
-        checkPackage(uid, pkgName);
+        /*checkPackage(uid, pkgName);
 
         // Apps with NETWORK_SETTINGS, NETWORK_SETUP_WIZARD, NETWORK_MANAGED_PROVISIONING,
         // NETWORK_STACK & MAINLINE_NETWORK_STACK, RADIO_SCAN_WITHOUT_LOCATION are granted a bypass.
@@ -279,7 +283,7 @@ public class WifiPermissionsUtil {
         // LocationAccess by App: caller must have Coarse/Fine Location permission to have access to
         // location information.
         boolean canAppPackageUseLocation = checkCallersLocationPermission(pkgName, featureId,
-                uid, /* coarseForTargetSdkLessThanQ */ true, message);
+                uid, true, message);
 
         // If neither caller or app has location access, there is no need to check
         // any other permissions. Deny access to scan results.
@@ -309,7 +313,7 @@ public class WifiPermissionsUtil {
                         + ", checkInteractAcrossUsersFull=" + checkInteractAcrossUsersFull(uid));
             }
             throw new SecurityException("UID " + uid + " profile not permitted");
-        }
+        }*/
     }
 
     /**
@@ -327,7 +331,7 @@ public class WifiPermissionsUtil {
     public void enforceCanAccessScanResultsForWifiScanner(String pkgName,
             @Nullable String featureId, int uid, boolean ignoreLocationSettings,
             boolean hideFromAppOps) throws SecurityException {
-        checkPackage(uid, pkgName);
+        /*checkPackage(uid, pkgName);
 
         // Location mode must be enabled
         if (!isLocationModeEnabled()) {
@@ -347,7 +351,7 @@ public class WifiPermissionsUtil {
         // Check if Wifi Scan request is an operation allowed for this App.
         if (!isScanAllowedbyApps(pkgName, featureId, uid)) {
             throw new SecurityException("UID " + uid + " has no wifi scan permission");
-        }
+        }*/
     }
 
     /**
@@ -364,7 +368,7 @@ public class WifiPermissionsUtil {
      */
     public boolean checkCanAccessWifiDirect(String pkgName, @Nullable String featureId, int uid,
                                             boolean needLocationModeEnabled) {
-        try {
+        /*try {
             checkPackage(uid, pkgName);
         } catch (SecurityException se) {
             Log.e(TAG, "Package check exception - " + se);
@@ -384,11 +388,11 @@ public class WifiPermissionsUtil {
 
         // LocationAccess by App: caller must have Fine Location permission to have access to
         // location information.
-        if (!checkCallersLocationPermission(pkgName, featureId, uid,
-                /* coarseForTargetSdkLessThanQ */ false, null)) {
+        /*if (!checkCallersLocationPermission(pkgName, featureId, uid,
+                 coarseForTargetSdkLessThanQ  false, null)) {
             Log.e(TAG, "UID " + uid + " has no location permission");
             return false;
-        }
+        }*/
         return true;
     }
 
@@ -401,19 +405,20 @@ public class WifiPermissionsUtil {
      *
      */
     public void checkPackage(int uid, String pkgName) throws SecurityException {
-        if (pkgName == null) {
+        /*if (pkgName == null) {
             throw new SecurityException("Checking UID " + uid + " but Package Name is Null");
         }
-        mAppOps.checkPackage(uid, pkgName);
+        mAppOps.checkPackage(uid, pkgName);*/
     }
 
     /**
      * Returns true if the caller holds PEERS_MAC_ADDRESS permission.
      */
     private boolean checkCallerHasPeersMacAddressPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.PEERS_MAC_ADDRESS, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
@@ -421,16 +426,18 @@ public class WifiPermissionsUtil {
      * and package.
      */
     private boolean isScanAllowedbyApps(String pkgName, @Nullable String featureId, int uid) {
-        return noteAppOpAllowed(AppOpsManager.OPSTR_WIFI_SCAN, pkgName, featureId, uid, null);
+        //return noteAppOpAllowed(AppOpsManager.OPSTR_WIFI_SCAN, pkgName, featureId, uid, null);
+		return true;
     }
 
     /**
      * Returns true if the caller holds INTERACT_ACROSS_USERS_FULL.
      */
     private boolean checkInteractAcrossUsersFull(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
@@ -438,19 +445,22 @@ public class WifiPermissionsUtil {
      * current user.
      */
     private boolean isCurrentProfile(int uid) {
-        UserHandle currentUser = UserHandle.of(mWifiPermissionsWrapper.getCurrentUser());
+        /*UserHandle currentUser = UserHandle.of(mWifiPermissionsWrapper.getCurrentUser());
         UserHandle callingUser = UserHandle.getUserHandleForUid(uid);
         return currentUser.equals(callingUser)
-                || mUserManager.isSameProfileGroup(currentUser, callingUser);
+                || mUserManager.isSameProfileGroup(currentUser, callingUser);*/
+		return true;
     }
 
     private boolean noteAppOpAllowed(String op, String pkgName, @Nullable String featureId,
             int uid, @Nullable String message) {
-        return mAppOps.noteOp(op, uid, pkgName, featureId, message) == AppOpsManager.MODE_ALLOWED;
+        //return mAppOps.noteOp(op, uid, pkgName, featureId, message) == AppOpsManager.MODE_ALLOWED;
+		return true;
     }
 
     private boolean checkAppOpAllowed(String op, String pkgName, int uid) {
-        return mAppOps.unsafeCheckOp(op, uid, pkgName) == AppOpsManager.MODE_ALLOWED;
+        //return mAppOps.unsafeCheckOp(op, uid, pkgName) == AppOpsManager.MODE_ALLOWED;
+		return true;
     }
 
     private boolean retrieveLocationManagerIfNecessary() {
@@ -468,7 +478,7 @@ public class WifiPermissionsUtil {
      * Retrieves a handle to LocationManager (if not already done) and check if location is enabled.
      */
     public boolean isLocationModeEnabled() {
-        if (!retrieveLocationManagerIfNecessary()) return false;
+        /*if (!retrieveLocationManagerIfNecessary()) return false;
         try {
             return mLocationManager.isLocationEnabledForUser(UserHandle.of(
                     mWifiPermissionsWrapper.getCurrentUser()));
@@ -477,102 +487,113 @@ public class WifiPermissionsUtil {
             return mFrameworkFacade.getIntegerSetting(
                     mContext, Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF)
                     == Settings.Secure.LOCATION_MODE_ON;
-        }
+        }*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds NETWORK_SETTINGS permission.
      */
     public boolean checkNetworkSettingsPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.NETWORK_SETTINGS, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds RADIO_SCAN_WITHOUT_LOCATION permission.
      */
     public boolean checkScanWithoutLocationPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.RADIO_SCAN_WITHOUT_LOCATION, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds LOCAL_MAC_ADDRESS permission.
      */
     public boolean checkLocalMacAddressPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.LOCAL_MAC_ADDRESS, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds NETWORK_SETUP_WIZARD permission.
      */
     public boolean checkNetworkSetupWizardPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.NETWORK_SETUP_WIZARD, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds NETWORK_STACK permission.
      */
     public boolean checkNetworkStackPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.NETWORK_STACK, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds MAINLINE_NETWORK_STACK permission.
      */
     public boolean checkMainlineNetworkStackPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds NETWORK_MANAGED_PROVISIONING permission.
      */
     public boolean checkNetworkManagedProvisioningPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.NETWORK_MANAGED_PROVISIONING, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds NETWORK_CARRIER_PROVISIONING permission.
      */
     public boolean checkNetworkCarrierProvisioningPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.NETWORK_CARRIER_PROVISIONING, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |uid| holds READ_WIFI_CREDENTIAL permission.
      */
     public boolean checkReadWifiCredentialPermission(int uid) {
-        return mWifiPermissionsWrapper.getUidPermission(
+        /*return mWifiPermissionsWrapper.getUidPermission(
                 android.Manifest.permission.READ_WIFI_CREDENTIAL, uid)
-                == PackageManager.PERMISSION_GRANTED;
+                == PackageManager.PERMISSION_GRANTED;*/
+		return true;
     }
 
     /**
      * Returns true if the |callingUid|/\callingPackage| holds SYSTEM_ALERT_WINDOW permission.
      */
     public boolean checkSystemAlertWindowPermission(int callingUid, String callingPackage) {
-        final int mode = mAppOps.noteOp(AppOpsManager.OPSTR_SYSTEM_ALERT_WINDOW, callingUid,
+        /*final int mode = mAppOps.noteOp(AppOpsManager.OPSTR_SYSTEM_ALERT_WINDOW, callingUid,
                 callingPackage, null, null);
         if (mode == AppOpsManager.MODE_DEFAULT) {
             return mWifiPermissionsWrapper.getUidPermission(
                     Manifest.permission.SYSTEM_ALERT_WINDOW, callingUid)
                     == PackageManager.PERMISSION_GRANTED;
         }
-        return mode == AppOpsManager.MODE_ALLOWED;
+        return mode == AppOpsManager.MODE_ALLOWED;*/
+		return true;
     }
 
     private static DevicePolicyManager retrieveDevicePolicyManagerFromContext(Context context) {
@@ -639,7 +660,7 @@ public class WifiPermissionsUtil {
     public boolean isDeviceOwner(int uid, @Nullable String packageName) {
         // Cannot determine if the app is DO/PO if packageName is null. So, will return false to be
         // safe.
-        if (packageName == null) {
+        /*if (packageName == null) {
             Log.e(TAG, "isDeviceOwner: packageName is null, returning false");
             return false;
         }
@@ -650,14 +671,15 @@ public class WifiPermissionsUtil {
         if (deviceOwner == null) return false;
 
         return deviceOwner.first.equals(UserHandle.getUserHandleForUid(uid))
-                && deviceOwner.second.getPackageName().equals(packageName);
+                && deviceOwner.second.getPackageName().equals(packageName);*/
+		return true;
     }
 
     /**
      * Returns {@code true} if the calling {@code uid} is the device owner.
      */
     public boolean isDeviceOwner(int uid) {
-        Pair<UserHandle, ComponentName> deviceOwner = getDeviceOwner();
+        /*Pair<UserHandle, ComponentName> deviceOwner = getDeviceOwner();
 
         // no device owner
         if (deviceOwner == null) return false;
@@ -680,7 +702,8 @@ public class WifiPermissionsUtil {
             if (deviceOwnerPackageName.equals(packageName)) return true;
         }
 
-        return false;
+        return false;*/
+		return true;
     }
 
     /**
@@ -689,19 +712,20 @@ public class WifiPermissionsUtil {
     public boolean isProfileOwner(int uid, @Nullable String packageName) {
         // Cannot determine if the app is DO/PO if packageName is null. So, will return false to be
         // safe.
-        if (packageName == null) {
+        /*if (packageName == null) {
             Log.e(TAG, "isProfileOwner: packageName is null, returning false");
             return false;
         }
         DevicePolicyManager devicePolicyManager =
                 retrieveDevicePolicyManagerFromUserContext(uid);
         if (devicePolicyManager == null) return false;
-        return devicePolicyManager.isProfileOwnerApp(packageName);
+        return devicePolicyManager.isProfileOwnerApp(packageName);*/
+		return true;
     }
 
     /** Helper method to check if the entity initiating the binder call is a system app. */
     public boolean isSystem(String packageName, int uid) {
-        long ident = Binder.clearCallingIdentity();
+        /*long ident = Binder.clearCallingIdentity();
         try {
             ApplicationInfo info = mContext.getPackageManager().getApplicationInfoAsUser(
                     packageName, 0, UserHandle.getUserHandleForUid(uid));
@@ -712,8 +736,8 @@ public class WifiPermissionsUtil {
             // called to verify validity before checking App's version.
         } finally {
             Binder.restoreCallingIdentity(ident);
-        }
-        return false;
+        }*/
+        return true;
     }
 
     /**
@@ -729,7 +753,7 @@ public class WifiPermissionsUtil {
      *         otherwise false.
      */
     public boolean doesUidBelongToCurrentUser(int uid) {
-        if (uid == android.os.Process.SYSTEM_UID
+        /*if (uid == android.os.Process.SYSTEM_UID
                 // UIDs with the NETWORK_SETTINGS permission are always allowed since they are
                 // acting on behalf of the user.
                 || checkNetworkSettingsPermission(uid)) {
@@ -741,7 +765,8 @@ public class WifiPermissionsUtil {
             EventLog.writeEvent(0x534e4554, "174749461", -1,
                     "Non foreground user trying to modify wifi configuration");
         }
-        return isCurrentProfile || isDeviceOwner(uid);
+        return isCurrentProfile || isDeviceOwner(uid);*/
+		return true;
     }
 
     /**
-- 
2.17.1

From d8e2c3b72c907c3e09162da23eeffa1b09748558 Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Sat, 3 Sep 2022 14:22:38 +0800
Subject: [PATCH 3/5] fix rmnet wlan conflict

---
 system/netd/server/NetdNativeService.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
index 85359f5e4e..f1eb3fb091 100755
--- a/system/netd/server/NetdNativeService.cpp
+++ b/system/netd/server/NetdNativeService.cpp
@@ -1069,8 +1069,10 @@ binder::Status NetdNativeService::networkAddRouteParcel(int32_t netId,
     const char *gw = nullptr;
     char cmd[MAX_CMD_LEN];
 
-    if (-1 != sys_id) {
+    int is_rmnet = !strncmp("rmnet", route.ifName.c_str(), strlen("rmnet"));
+    if (-1 != sys_id && is_rmnet) {
         //cells
+        system("ip rule add from all lookup main prio 31999");// NOLINT(cert-env33-c)
         //config vnet ip
         snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",
             route.ifName.c_str(),
-- 
2.17.1

From 6c0921e0a3461d8f16fb1d1f020d8f2217c4621f Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Sun, 21 Aug 2022 17:08:09 +0800
Subject: [PATCH 03/11] RIL request and indication process

---
 .../internal/telephony/RILRequest.java        | 19 ++++++++++++--
 .../internal/telephony/RadioIndication.java   | 26 +++++++++++++++++++
 2 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
index fff8de690a..e261f87e57 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
@@ -22,6 +22,7 @@ import android.os.Message;
 import android.os.SystemClock;
 import android.os.WorkSource;
 import android.os.WorkSource.WorkChain;
+import android.os.SystemProperties;
 
 import com.android.telephony.Rlog;
 
@@ -43,6 +44,9 @@ public class RILRequest {
     private static RILRequest sPool = null;
     private static int sPoolSize = 0;
     private static final int MAX_POOL_SIZE = 4;
+    private static final int MAX_SERIAL_NUM = Integer.MAX_VALUE >> 1; //BIT(31) mark as sysid
+    private static final String sCellName = SystemProperties.get("ro.boot.vm.name", "none");
+    private static int mSysId = -1;
 
     //***** Instance Variables
     @UnsupportedAppUsage
@@ -96,9 +100,20 @@ public class RILRequest {
             rr = new RILRequest();
         }
 
-        // Increment serial number. Wrap to 0 when reaching Integer.MAX_VALUE.
-        rr.mSerial = sNextSerial.getAndUpdate(n -> ((n + 1) % Integer.MAX_VALUE));
+        if (-1 == mSysId) {
+            if ("cell1".equals(sCellName)) {
+                mSysId = 0;
+            } else if ("cell2".equals(sCellName)) {
+                mSysId = 1;
+            } else {
+                Rlog.e(LOG_TAG, "CellName " + sCellName + " Error!");
+                throw new NullPointerException("sCellName is " + sCellName);
+            }
+        }
 
+        // Increment serial number. Wrap to 0 when reaching Integer.MAX_VALUE.
+        rr.mSerial = sNextSerial.getAndUpdate(n -> ((n + 1) % MAX_SERIAL_NUM));
+        rr.mSerial |= (mSysId << 31);
         rr.mRequest = request;
         rr.mResult = result;
 
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RadioIndication.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RadioIndication.java
index d18efdcb9c..8770e0cb13 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RadioIndication.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RadioIndication.java
@@ -120,6 +120,7 @@ import com.android.internal.telephony.uicc.IccRefreshResponse;
 import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.telephony.uicc.ReceivedPhonebookRecords;
 import com.android.internal.telephony.uicc.SimPhonebookRecord;
+import android.os.SystemProperties;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -170,6 +171,10 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void newSms(int indicationType, ArrayList<Byte> pdu) {
+        if (!isActivateSys()) {
+            //后台系统不接收
+            return;
+        }
         mRil.processIndication(indicationType);
 
         byte[] pduArray = RIL.arrayListToPrimitiveArray(pdu);
@@ -183,6 +188,10 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void newSmsStatusReport(int indicationType, ArrayList<Byte> pdu) {
+        if (!isActivateSys()) {
+            //后台系统不接收
+            return;
+        }
         mRil.processIndication(indicationType);
 
         byte[] pduArray = RIL.arrayListToPrimitiveArray(pdu);
@@ -502,7 +511,20 @@ public class RadioIndication extends IRadioIndication.Stub {
         mRil.mIccRefreshRegistrants.notifyRegistrants(new AsyncResult (null, response, null));
     }
 
+    private boolean isActivateSys() {
+        String sys_stat = SystemProperties.get("persist.sys.exit", "1");
+        if ("0".equals(sys_stat)) {
+            return true;
+        }
+        return false;
+    }
+
     public void callRing(int indicationType, boolean isGsm, CdmaSignalInfoRecord record) {
+
+        if (!isActivateSys()) {
+            //后台系统不接收来电
+            return;
+        }
         mRil.processIndication(indicationType);
 
         char response[] = null;
@@ -534,6 +556,10 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void cdmaNewSms(int indicationType, CdmaSmsMessage msg) {
+        if (!isActivateSys()) {
+            //后台系统不接收
+            return;
+        }
         mRil.processIndication(indicationType);
 
         if (RIL.RILJ_LOGD) mRil.unsljLog(RIL_UNSOL_RESPONSE_CDMA_NEW_SMS);
-- 
2.17.1

From 6954f9300cd5b514cea1a2e7a4b36147f3b07377 Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Mon, 5 Sep 2022 09:23:46 +0800
Subject: [PATCH 4/5] commit missing code int patch:xdja-container-20220829
 from jianglin

---
 system/core/rootdir/init.rc | 1 -
 1 file changed, 1 deletion(-)

diff --git a/system/core/rootdir/init.rc b/system/core/rootdir/init.rc
index a898c16d91..8a370d335d 100644
--- a/system/core/rootdir/init.rc
+++ b/system/core/rootdir/init.rc
@@ -459,7 +459,6 @@ on init
     start servicemanager
     start hwservicemanager
     start vndservicemanager
-    start cellsservice
 
 # Healthd can trigger a full boot from charger mode by signaling this
 # property when the power button is held.
-- 
2.17.1

From dea6e8f0d0041834dd8ba0204a48de875f159fa1 Mon Sep 17 00:00:00 2001
From: ngf <ngf@xdja.com>
Date: Sat, 27 Aug 2022 10:27:27 +0800
Subject: [PATCH 04/11] ngf: add container service

---
 frameworks/base/0827.zip                      | Bin 0 -> 15567 bytes
 frameworks/base/core/api/current.txt          |  13 +
 .../java/android/app/ContainerManager.java    | 112 ++++++
 .../java/android/app/IContainerService.aidl   |  37 ++
 .../android/app/SystemServiceRegistry.java    |  10 +
 .../core/java/android/content/Context.java    |   3 +
 .../java/com/android/server/SystemServer.java |  35 ++
 frameworks/base/services/xdja/Android.mk      |  21 +
 .../com/android/server/ContainerService.java  | 374 ++++++++++++++++++
 .../com_android_server_EncryptFunctions.cpp   | 212 ++++++++++
 frameworks/base/services/xdja/proguard.flags  |   8 +
 11 files changed, 825 insertions(+)
 create mode 100644 frameworks/base/0827.zip
 create mode 100755 frameworks/base/core/java/android/app/ContainerManager.java
 create mode 100755 frameworks/base/core/java/android/app/IContainerService.aidl
 mode change 100644 => 100755 frameworks/base/core/java/android/app/SystemServiceRegistry.java
 mode change 100644 => 100755 frameworks/base/core/java/android/content/Context.java
 mode change 100644 => 100755 frameworks/base/services/java/com/android/server/SystemServer.java
 create mode 100755 frameworks/base/services/xdja/Android.mk
 create mode 100755 frameworks/base/services/xdja/com/android/server/ContainerService.java
 create mode 100755 frameworks/base/services/xdja/jni/com_android_server_EncryptFunctions.cpp
 create mode 100755 frameworks/base/services/xdja/proguard.flags

diff --git a/frameworks/base/0827.zip b/frameworks/base/0827.zip
new file mode 100644
index 0000000000000000000000000000000000000000..fabde2429a5186c113cdd7264806420e4cfb7f53
GIT binary patch
literal 15567
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
SemIzaPLqF@r7!&N)BgoWDv#6v

literal 0
HcmV?d00001

diff --git a/frameworks/base/core/api/current.txt b/frameworks/base/core/api/current.txt
index a1c8f081aa..4f885dba21 100644
--- a/frameworks/base/core/api/current.txt
+++ b/frameworks/base/core/api/current.txt
@@ -4821,6 +4821,18 @@ package android.app {
     method public int vmSystemReady();
   }
 
+  public class ContainerManager {
+    method public int downloadCellsVm(@NonNull String);
+    method public int sendCellsVm(@NonNull String, @NonNull String);
+    method public int startCellsVm(@NonNull String);
+    method public int stopCellsVm(@NonNull String);
+    method public int switchCellsVm(@NonNull String);
+    method public int tarCellsVm(@NonNull String);
+    method public int untarCellsVm(@NonNull String);
+    method public int uploadCellsVm(@NonNull String);
+    method public int vmSystemReady();
+  }
+
   public class DatePickerDialog extends android.app.AlertDialog implements android.widget.DatePicker.OnDateChangedListener android.content.DialogInterface.OnClickListener {
     ctor public DatePickerDialog(@NonNull android.content.Context);
     ctor public DatePickerDialog(@NonNull android.content.Context, @StyleRes int);
@@ -10649,6 +10661,7 @@ package android.content {
     field public static final String CONNECTIVITY_DIAGNOSTICS_SERVICE = "connectivity_diagnostics";
     field public static final String CONNECTIVITY_SERVICE = "connectivity";
     field public static final String CONSUMER_IR_SERVICE = "consumer_ir";
+    field public static final String CONTAINER_SERVICE = "container";
     field public static final int CONTEXT_IGNORE_SECURITY = 2; // 0x2
     field public static final int CONTEXT_INCLUDE_CODE = 1; // 0x1
     field public static final int CONTEXT_RESTRICTED = 4; // 0x4
diff --git a/frameworks/base/core/java/android/app/ContainerManager.java b/frameworks/base/core/java/android/app/ContainerManager.java
new file mode 100755
index 0000000000..58fbe7b53e
--- /dev/null
+++ b/frameworks/base/core/java/android/app/ContainerManager.java
@@ -0,0 +1,112 @@
+package android.app;
+
+import android.annotation.SystemService;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.content.Context;
+import android.annotation.SuppressLint;
+import android.os.RemoteException;
+
+import android.app.IContainerService;
+
+@SystemService(Context.CONTAINER_SERVICE)
+public class ContainerManager {
+    private static String TAG = "ContainerManager";
+    final IContainerService cService;
+    private Context mContext;
+
+    ContainerManager(@NonNull Context context, @NonNull IContainerService service) {
+        mContext = context;
+        cService = service;
+    }
+
+    @SuppressLint("RemoteException")
+    public int startCellsVm(@NonNull String name) {
+        try {
+            cService.startCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int stopCellsVm(@NonNull String name) {
+        try {
+            cService.stopCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int switchCellsVm(@NonNull String name) {
+        try {
+            cService.switchCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int uploadCellsVm(@NonNull String name) {
+        try {
+            cService.uploadCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int downloadCellsVm(@NonNull String name) {
+        try {
+            cService.downloadCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int untarCellsVm(@NonNull String name) {
+        try {
+            cService.untarCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int tarCellsVm(@NonNull String name) {
+        try {
+            cService.tarCellsVm(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int sendCellsVm(@NonNull String path, @NonNull String address) {
+        try {
+            cService.sendCellsVm(path, address);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+
+    @SuppressLint("RemoteException")
+    public int vmSystemReady() {
+        try {
+            cService.vmSystemReady();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        return -1;
+    }
+}
diff --git a/frameworks/base/core/java/android/app/IContainerService.aidl b/frameworks/base/core/java/android/app/IContainerService.aidl
new file mode 100755
index 0000000000..168f4040e8
--- /dev/null
+++ b/frameworks/base/core/java/android/app/IContainerService.aidl
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+  *@hide
+  */
+interface IContainerService {
+	int startCellsVm(@nullable String name);
+	int stopCellsVm(@nullable String name);
+	int switchCellsVm(@nullable String name);
+	int uploadCellsVm(@nullable String name);
+	int downloadCellsVm(@nullable String name);
+	int untarCellsVm(@nullable String name);
+	int tarCellsVm(@nullable String name);
+	int sendCellsVm(@nullable String path, @nullable String address);
+	int vmSystemReady();
+	void onPeerNotified();
+}
+
diff --git a/frameworks/base/core/java/android/app/SystemServiceRegistry.java b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
old mode 100644
new mode 100755
index c5ae75946c..1143fce329
--- a/frameworks/base/core/java/android/app/SystemServiceRegistry.java
+++ b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
@@ -184,6 +184,8 @@ import android.os.image.IDynamicSystemService;
 import android.os.incremental.IIncrementalService;
 import android.os.incremental.IncrementalManager;
 import android.os.storage.StorageManager;
+import android.app.ContainerManager;
+import android.app.IContainerService;
 import android.permission.LegacyPermissionManager;
 import android.permission.PermissionCheckerManager;
 import android.permission.PermissionControllerManager;
@@ -542,6 +544,14 @@ public final class SystemServiceRegistry {
                 return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
             }});
 
+        registerService(Context.CONTAINER_SERVICE, ContainerManager.class,
+                new CachedServiceFetcher<ContainerManager>() {
+            @Override
+            public ContainerManager createService(ContextImpl ctx) throws ServiceNotFoundException {
+                IBinder b = ServiceManager.getServiceOrThrow(Context.CONTAINER_SERVICE);
+                return new ContainerManager(ctx, IContainerService.Stub.asInterface(b));
+            }});
+
         registerService(Context.NETWORK_POLICY_SERVICE, NetworkPolicyManager.class,
                 new CachedServiceFetcher<NetworkPolicyManager>() {
             @Override
diff --git a/frameworks/base/core/java/android/content/Context.java b/frameworks/base/core/java/android/content/Context.java
old mode 100644
new mode 100755
index 76ffde8eae..8ace714db1
--- a/frameworks/base/core/java/android/content/Context.java
+++ b/frameworks/base/core/java/android/content/Context.java
@@ -3715,6 +3715,7 @@ public abstract class Context {
             //@hide: SPEECH_RECOGNITION_SERVICE,
             UWB_SERVICE,
             MEDIA_METRICS_SERVICE,
+            CONTAINER_SERVICE,
     })
     @Retention(RetentionPolicy.SOURCE)
     public @interface ServiceName {}
@@ -4105,6 +4106,8 @@ public abstract class Context {
      */
     public static final String LOCATION_SERVICE = "location";
 
+    public static final String CONTAINER_SERVICE = "container";
+
     /**
      * Use with {@link #getSystemService(String)} to retrieve a
      * {@link android.location.CountryDetector} for detecting the country that
diff --git a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
old mode 100644
new mode 100755
index 7370772ec8..24969fd93e
--- a/frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -222,6 +222,9 @@ import java.util.Timer;
 import java.util.TreeSet;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
+import dalvik.system.PathClassLoader;
+import java.lang.reflect.Constructor;
+
 
 /**
  * Entry point to {@code system_server}.
@@ -2434,6 +2437,15 @@ public final class SystemServer implements Dumpable {
             } catch (Throwable e) {
                 reportWtf("starting CellsService", e);
             }
+
+            /*try {
+                Slog.i(TAG, "container Service");
+                containerService = new ContainerService(context);
+                ServiceManager.addService(Context.CONTAINER_SERVICE, containerService);
+            } catch (Throwable e) {
+                reportWtf("starting ContainerService", e);
+            }*/
+            startContainerService(context);
         }
 
         if (!isWatch) {
@@ -3079,4 +3091,27 @@ public final class SystemServer implements Dumpable {
         return false;
     }
 
+     private void startContainerService(Context context) {
+        try {
+            PathClassLoader csClassLoader =
+                new PathClassLoader("/system/framework/services.xdja.jar",
+                        ClassLoader.getSystemClassLoader());
+            Class csClass = csClassLoader.loadClass("com.android.server.ContainerService");
+            Constructor csConstructor = csClass.getConstructor(
+                    new Class[] {Context.class});
+            Object csObj = csConstructor.newInstance(context);
+            try {
+                if(csObj != null && (csObj instanceof IBinder)) {
+                    ServiceManager.addService("container", (IBinder)csObj);
+                    Slog.i(TAG, "Created Container Service");
+                }
+            } catch (Exception e) {
+                Slog.e(TAG, "starting Container Service error", e);
+            }
+
+        } catch (Throwable e) {
+            Slog.e(TAG, "starting Container Service", e);
+        }
+    }
+
 }
diff --git a/frameworks/base/services/xdja/Android.mk b/frameworks/base/services/xdja/Android.mk
new file mode 100755
index 0000000000..557d6e3a6c
--- /dev/null
+++ b/frameworks/base/services/xdja/Android.mk
@@ -0,0 +1,21 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := services.xdja
+
+LOCAL_SRC_FILES += \
+    com/android/server/ContainerService.java 
+LOCAL_JNI_SHARED_LIBRARIES := libandroid_xdjaservers
+	
+LOCAL_JAVA_LIBRARIES := \
+    services.core \
+    telephony-common
+
+LOCAL_PROGUARD_ENABLED := full
+LOCAL_PROGUARD_FLAG_FILES := proguard.flags
+	
+include $(BUILD_JAVA_LIBRARY)
+
+include $(CLEAR_VARS)
+
diff --git a/frameworks/base/services/xdja/com/android/server/ContainerService.java b/frameworks/base/services/xdja/com/android/server/ContainerService.java
new file mode 100755
index 0000000000..0770e7190f
--- /dev/null
+++ b/frameworks/base/services/xdja/com/android/server/ContainerService.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.os.ServiceManager;
+import android.app.IContainerService;
+import android.os.Binder;
+import android.os.IBinder;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.util.Log;
+import android.util.Slog;
+
+
+import java.util.HashMap;
+
+
+public class ContainerService extends IContainerService.Stub {
+    private static final String TAG = "ContainerService";
+
+    static final int  SETPROPERTY = Binder.FIRST_CALL_TRANSACTION;
+    static final int  STARTCELLSVM = Binder.FIRST_CALL_TRANSACTION + 1;
+    static final int  STOPCELLSVM = Binder.FIRST_CALL_TRANSACTION + 2;
+    static final int  SWITCHCELLSVM = Binder.FIRST_CALL_TRANSACTION + 3;
+    static final int  UPLOADCELLSVM = Binder.FIRST_CALL_TRANSACTION + 4;
+    static final int  DOWNLOADCELLSVM = Binder.FIRST_CALL_TRANSACTION + 5;
+    static final int  UNTARCELLSVM = Binder.FIRST_CALL_TRANSACTION + 6;
+    static final int  TARCELLSVM = Binder.FIRST_CALL_TRANSACTION + 7;
+    static final int  SYSTEMREADY = Binder.FIRST_CALL_TRANSACTION + 8;
+    static final int  SENDCELLSVM = Binder.FIRST_CALL_TRANSACTION + 15;
+    
+    private final Context mContext;
+    private final IBinder mChannel;
+
+    /* switch stage */
+    private static final int BEFORE_LEAVE_SYSTEM = 0;
+    private static final int AFTER_LEAVE_SYSTEM = 1;
+    private static final int BEFORE_ENTRY_SYSTEM = 2;
+    private static final int AFTER_ENTRY_SYSTEM = 3;
+
+    // system name
+    private static final String NAME_HOST = "host";
+    private static final String NAME_CELL1 = "cell1";
+    private static final String NAME_CELL2 = "cell2";
+
+    // system number
+    private static final int NUMBER_HOST = 0;
+    private static final int NUMBER_CELL1 = 1;
+    private static final int NUMBER_CELL2 = 2;
+
+    /* switch action */
+    private static final int SC_NOTHING = 0;    
+    private static final int SC_ACTIVE = 1; /*Common*/
+    private static final int SC_GOTO_SLEEP = 2; /*Screen-Off by click power-key*/
+    private static final int SC_SWITCH_TO_GENERAL_BY_OTHER = 100; /*Click sms, call notification from peer system*/
+
+    private static HashMap<String, Integer> maps = new HashMap<>() {
+        {
+            put(NAME_HOST, NUMBER_HOST);
+            put(NAME_CELL1, NUMBER_CELL1);
+            put(NAME_CELL2, NUMBER_CELL2);
+        }
+    };
+
+    public ContainerService(Context context) {
+        mContext = context;
+        mChannel = ServiceManager.getInitService("CellsPrivateService");
+    }
+
+    public void systemReady(){
+        
+    }
+
+    public int startCellsVm(@Nullable String name){
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"startCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(STARTCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"startCellsVm end ");
+            ret = reply.readInt();
+        } catch(RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int stopCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"stopCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(STOPCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"stopCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int switchCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        //do task befor switch
+        onSwitchSystemPeer(name, SC_ACTIVE, maps.get(name));
+        onSwitchSystem(BEFORE_LEAVE_SYSTEM, SC_ACTIVE, maps.get(name));
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"switchCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(SWITCHCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"switchCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        }finally {
+            data.recycle();
+            reply.recycle();
+        }
+
+        //do task after switch
+        onSwitchSystemPeer(name, SC_ACTIVE, maps.get(name));
+        onSwitchSystem(AFTER_LEAVE_SYSTEM, SC_ACTIVE, maps.get(name));
+        
+        return ret;
+    }
+
+    public int uploadCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"uploadCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(UPLOADCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"uploadCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int downloadCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"downloadCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(DOWNLOADCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"downloadCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int untarCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"untarCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(UNTARCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"untarCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int tarCellsVm(@Nullable String name) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"tarCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(name);
+            mChannel.transact(TARCELLSVM, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"tarCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        }finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int sendCellsVm(@Nullable String path, @Nullable String address) {
+        if(mChannel == null) return 0;
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"sendCellsVm start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(path);
+            data.writeString(address);
+            mChannel.transact(SENDCELLSVM, data, reply, 0);
+            //reply.readException();
+            Log.e(TAG,"sendCellsVm end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        }finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    public int vmSystemReady() {
+        if(mChannel == null) return 0;
+
+        String vmname = SystemProperties.get("ro.boot.vm.name","");
+        if(vmname == null || vmname.length() <= 4){
+            return 0;
+        }
+
+        int ret = 0;
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        try {
+            Log.e(TAG,"systemReady start ");
+            data.writeInterfaceToken("CellsPrivateService");
+            data.writeString(vmname);
+            mChannel.transact(SYSTEMREADY, data, reply, 0);
+            reply.readException();
+            Log.e(TAG,"systemReady end ");
+        } catch (RemoteException e){
+            throw e.rethrowFromSystemServer();
+        } finally {
+            data.recycle();
+            reply.recycle();
+        }
+        return ret;
+    }
+
+    private int onSwitchSystemPeer(String targetName, int action, int peerSysId) {
+        int ret = -1;
+
+        //system number, 0:host 1:cell1 2:cell2
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        if(targetName.equals(currentName)) {
+            return -1;
+        }
+
+        Slog.d(TAG, "onSwitchSystemPeer currentName:" + currentName + " id:" + maps.get(targetName));
+        IBinder remote = ServiceManager.getOtherSystemService(Context.CONTAINER_SERVICE, maps.get(targetName));
+        IContainerService container = IContainerService.Stub.asInterface(remote);
+        if(container != null) {
+            try {
+                container.onPeerNotified();
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+        }
+        return ret;
+    }
+
+    private int onSwitchSystem(int stage, int action, int sysId) {
+        if (stage == BEFORE_LEAVE_SYSTEM) {
+            beforeLeaveSystem(action, sysId);
+        } else if (stage == AFTER_LEAVE_SYSTEM) {
+            afterLeaveSystem(action, sysId);
+        } else if (stage == BEFORE_ENTRY_SYSTEM) {
+            beforeEntrySystem(action, sysId);
+        } else if (stage == AFTER_ENTRY_SYSTEM) {
+            afterEntrySystem(action, sysId);
+        }
+
+        return 0;
+    }
+
+    private int beforeLeaveSystem(int action, int sysId) {
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        Slog.d(TAG, "beforeLeaveSystem currentName:" + currentName);
+        return 0;
+    }
+
+    private int afterLeaveSystem(int action, int sysId) {
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        Slog.d(TAG, "afterLeaveSystem currentName:" + currentName);
+        return 0;
+    }
+
+    private int beforeEntrySystem(int action, int sysId) {
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        Slog.d(TAG, "beforeEntrySystem currentName:" + currentName);
+        return 0;
+    }
+
+    private int afterEntrySystem(int action, int sysId) {
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        Slog.d(TAG, "afterEntrySystem currentName:" + currentName);
+        return 0;
+    }
+
+    public void onPeerNotified() {
+        String currentName = SystemProperties.get("ro.boot.vm.name", NAME_HOST);
+        Slog.d(TAG, "onPeerNotified currentName:" + currentName);
+    }
+}
+
diff --git a/frameworks/base/services/xdja/jni/com_android_server_EncryptFunctions.cpp b/frameworks/base/services/xdja/jni/com_android_server_EncryptFunctions.cpp
new file mode 100755
index 0000000000..7cd73fb82f
--- /dev/null
+++ b/frameworks/base/services/xdja/jni/com_android_server_EncryptFunctions.cpp
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "ContainerServiceJNI"
+//#define LOG_NDEBUG 0
+#include "jni.h"
+#include "JNIHelp.h"
+
+#include <android_runtime/AndroidRuntime.h>
+
+#include <utils/misc.h>
+#include <utils/Log.h>
+#include <hardware/hardware.h>
+#include <hardware/container.h>
+
+#include <stdio.h>
+
+namespace android {
+
+static int getPos(JNIEnv* env, jobject clazz, jlong ptr) {
+	int ret;
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	struct container_info info;
+
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return -1;
+	}
+
+	ret = device->get_container_info(device, &info);
+	if (ret != 0) {
+		ALOGE("get conatiner info fail! ret %d!", ret);
+		return ret;
+	}
+
+	ALOGI("get info from device container! idx[%d] pos[%d] drv_ns[%p]\n", info.idx, info.pos, info.drv_ns);
+
+	return info.pos;
+}
+
+static int getContainerMode(JNIEnv* env, jobject clazz, jlong ptr) {
+	int ret;
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	int mode;
+
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return -1;
+	}
+
+	ret = device->get_container_mode(device, &mode);
+	if (ret != 0) {
+		ALOGE("get conatiner mode fail! ret %d!", ret);
+		return ret;
+	}
+
+	ALOGI("get container mode from device container! mode[%d]\n", mode);
+
+	return mode;
+}
+
+static int getContainerActiveStatus(JNIEnv* env, jobject clazz, jlong ptr) {
+	int ret;
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	int status;
+
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return -1;
+	}
+
+	ret = device->get_container_active_status(device, &status);
+	if (ret != 0) {
+		ALOGE("get conatiner active status fail! ret %d!", ret);
+		return ret;
+	}
+
+	ALOGI("get conatiner active status from device container! status[%d]\n", status);
+
+	return status;
+}
+
+static inline int container_device_open(const hw_module_t* module, struct container_device_t** device) {
+	return module->methods->open(module, NULL, (struct hw_device_t**)device);
+}
+
+static jlong container_init(JNIEnv* env, jclass clazz) {
+	hw_module_t* module;
+	struct container_device_t* device;
+	int err;
+
+	ALOGI("Initializing HAL stub container....");
+
+	err = hw_get_module(CONTAINER_HARDWARE_MODULE_ID,
+			const_cast<const hw_module_t **>(&module));
+	if (err == 0) {
+		ALOGI("Device container found.");
+
+		if (container_device_open(module, &device) == 0) {
+			ALOGI("device container is open.");
+			return (jlong)device;
+		}
+
+		ALOGE("Failed to open device container.");
+		return (jlong)0;
+	}
+
+	ALOGE("Failed to get HAL stub container.");
+	return (jlong)0;
+}
+
+static int getInteger(JNIEnv* env, jclass clazz, jlong ptr) {
+	int ret;
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	int integer;
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return -1;
+	}
+	
+	ret = device->get_integer(device, &integer);
+	if (ret != 0) {
+		ALOGE("get conatiner info fail! ret %d!", ret);
+		return ret;
+	}
+
+	ALOGI("get integer from device container! integer[%d]\n", integer);
+	
+	return integer;
+}
+
+static void lockFissionGlobalMutex(JNIEnv* env, jclass clazz, jlong ptr) {
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return;
+	}
+	
+	ALOGI("jni lockFissionGlobalMutex from device container!\n");
+	device->lock_fission_global_mutex(device);
+}
+
+static void unlockFissionGlobalMutex(JNIEnv* env, jclass clazz, jlong ptr) {
+	struct container_device_t* device = (struct container_device_t*)ptr;
+	
+	if (!device) {
+		ALOGE("Device container is not open!");
+		return;
+	}
+	
+	ALOGI("jni unlockFissionGlobalMutex from device container!\n");	
+	device->unlock_fission_global_mutex(device);
+}
+
+
+
+static JNINativeMethod gMethods[] = {
+    {"init_native", "()J", (void *)container_init},
+    {"getPos_native", "(J)I", (void *)getPos},
+    {"getMode_native", "(J)I", (void *)getContainerMode},
+    {"getActiveStatus_native", "(J)I", (void *)getContainerActiveStatus},
+    {"getInteger_native", "(J)I", (void *)getInteger},
+    {"lockFissionGlobalMutex_native", "(J)V", (void *)lockFissionGlobalMutex},
+	{"unlockFissionGlobalMutex_native", "(J)V", (void *)unlockFissionGlobalMutex},
+};
+
+#define CLASS_PATH "com/android/server/EncryptFunctions"
+
+int register_android_server_ContainerService(JNIEnv *env)
+{
+	int ret;
+
+	ALOGE("gwb register_android_server_ContainerService begin");
+    ret = AndroidRuntime::registerNativeMethods(env,
+                CLASS_PATH, gMethods, NELEM(gMethods));
+	ALOGE("gwb register_android_server_ContainerService ret = %d", ret);
+	return ret;
+}
+};
+
+using namespace android;
+
+extern "C" jint JNI_OnLoad(JavaVM* vm, void* reserved)
+{
+    JNIEnv* env = NULL;
+    jint result = -1;
+	ALOGE("gwb JNI_OnLoad begin");
+    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
+        ALOGE("GetEnv failed!");
+        return result;
+    }
+    ALOG_ASSERT(env, "Could not retrieve the env!");
+
+    register_android_server_ContainerService(env);
+
+    return JNI_VERSION_1_4;
+}
+
diff --git a/frameworks/base/services/xdja/proguard.flags b/frameworks/base/services/xdja/proguard.flags
new file mode 100755
index 0000000000..50c73c6558
--- /dev/null
+++ b/frameworks/base/services/xdja/proguard.flags
@@ -0,0 +1,8 @@
+-verbose
+-keep class com.android.server.ContainerService{*;}
+-keep class com.android.server.KeyguardOnReceiver{*;}
+-keep class com.android.server.XdjaPhoneStateListener{*;}
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+-dontwarn com.android.server.**
\ No newline at end of file
-- 
2.17.1

From e77ccea35e09a1caa078f4b0f804334f33ddb3dd Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Mon, 5 Sep 2022 22:48:58 +0800
Subject: [PATCH 5/5] radio hal proxy ok

---
 .../com/android/internal/telephony/RIL.java   |   23 +-
 .../radio/1.6/radio_hal_proxy/Android.bp      |   73 +
 .../RadioIndication_V1_6_Proxy.cpp            |  706 ++++++
 .../RadioIndication_V1_6_Proxy.h              |  185 ++
 .../RadioResponse_V1_6_Proxy.cpp              | 1899 +++++++++++++++++
 .../RadioResponse_V1_6_Proxy.h                |  449 ++++
 .../radio/1.6/radio_hal_proxy/proxy_common.h  |    3 +
 .../radio_hal_proxy/radio_hidl_hal_proxy.cpp  |  152 ++
 .../radio_hal_proxy/ril_service_1_6_proxy.cpp | 1078 ++++++++++
 .../radio_hal_proxy/ril_service_1_6_proxy.h   |  482 +++++
 10 files changed, 5040 insertions(+), 10 deletions(-)
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h

diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
index 56c81d1da3..bdbb532288 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
@@ -299,7 +299,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     //***** Constants
 
     static final String[] HIDL_SERVICE_NAME = {"slot1", "slot2", "slot3"};
-
+    static final String[] HIDL_SERVICE_NAME_PROXY = {"slot1_proxy", "slot2_proxy", "slot3_proxy"};
     static final int IRADIO_GET_SERVICE_DELAY_MILLIS = 4 * 1000;
 
     static final String EMPTY_ALPHA_LONG = "";
@@ -493,20 +493,22 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         try {
             if (mDisabledRadioServices.contains(mPhoneId)) {
-                riljLoge("getRadioProxy: mRadioProxy for " + HIDL_SERVICE_NAME[mPhoneId]
+                riljLoge("getRadioProxy: mRadioProxy for " + HIDL_SERVICE_NAME_PROXY[mPhoneId]
                         + " is disabled");
             } else {
                 try {
                     mRadioProxy = android.hardware.radio.V1_6.IRadio.getService(
-                            HIDL_SERVICE_NAME[mPhoneId], true);
+                            HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                     mRadioVersion = RADIO_HAL_VERSION_1_6;
                 } catch (NoSuchElementException e) {
                 }
 
                 if (mRadioProxy == null) {
+                    riljLoge("getRadioProxy: mRadioProxy for android.hardware.radio.V1_6.IRadio " + HIDL_SERVICE_NAME_PROXY[mPhoneId]
+                        + " is fail");
                     try {
                         mRadioProxy = android.hardware.radio.V1_5.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_5;
                     } catch (NoSuchElementException e) {
                     }
@@ -515,7 +517,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_4.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_4;
                     } catch (NoSuchElementException e) {
                     }
@@ -524,7 +526,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_3.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_3;
                     } catch (NoSuchElementException e) {
                     }
@@ -533,7 +535,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_2.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_2;
                     } catch (NoSuchElementException e) {
                     }
@@ -542,7 +544,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_1.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_1;
                     } catch (NoSuchElementException e) {
                     }
@@ -551,7 +553,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_0.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_0;
                     } catch (NoSuchElementException e) {
                     }
@@ -560,11 +562,12 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy != null) {
                     mRadioProxy.linkToDeath(mRadioProxyDeathRecipient,
                             mRadioProxyCookie.incrementAndGet());
+                    riljLoge("gwb call mRadioProxy.setResponseFunctions");
                     mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
                 } else {
                     mDisabledRadioServices.add(mPhoneId);
                     riljLoge("getRadioProxy: mRadioProxy for "
-                            + HIDL_SERVICE_NAME[mPhoneId] + " is disabled");
+                            + HIDL_SERVICE_NAME_PROXY[mPhoneId] + " is disabled");
                 }
             }
         } catch (RemoteException e) {
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp b/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
new file mode 100755
index 0000000000..434ea4a8b2
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
@@ -0,0 +1,73 @@
+//
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "hardware_interfaces_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["hardware_interfaces_license"],
+}
+
+cc_defaults {
+    name: "HidlProxyDefaults",
+    defaults: [
+        "hidl_defaults",
+    ],
+
+    // Lists all dependencies that can *not* be expected on the device.
+    static_libs: [
+        "libhidl-gen-utils",
+    ],
+
+    group_static_libs: true,
+
+    // Lists all system dependencies that can be expected on the device.
+    shared_libs: [
+        "libbase",
+        // All the following are dependencies of any HAL definition library.
+        "libcutils",
+        "liblog",
+        "libhidlbase",
+        "libutils",
+    ],
+
+    require_root: true,
+}
+
+cc_binary {
+    name: "radio_hal_proxy",
+    defaults: ["HidlProxyDefaults"],
+    srcs: [
+        "radio_hidl_hal_proxy.cpp",
+        "RadioIndication_V1_6_Proxy.cpp",
+        "RadioResponse_V1_6_Proxy.cpp",
+        "ril_service_1_6_proxy.cpp",
+    ],
+    static_libs: [
+        "android.hardware.radio@1.6",
+        "android.hardware.radio@1.5",
+        "android.hardware.radio@1.4",
+        "android.hardware.radio@1.3",
+        "android.hardware.radio@1.2",
+        "android.hardware.radio@1.1",
+        "android.hardware.radio@1.0",
+        "android.hardware.radio.config@1.0",
+        "android.hardware.radio.config@1.1",
+    ],
+    header_libs: ["radio.util.header@1.0"],
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
new file mode 100755
index 0000000000..66d12ee39d
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
@@ -0,0 +1,706 @@
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include "RadioIndication_V1_6_Proxy.h"
+
+
+RadioIndication_v1_6_Proxy::RadioIndication_v1_6_Proxy() {
+    for (int32_t sysId = 0; sysId < MAX_SYS_NUM; sysId++) {
+        mRadioIndication[sysId] = nullptr;
+    }
+}
+
+int32_t RadioIndication_v1_6_Proxy::setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioIndication> radioIndication) {
+    int32_t i = 0;
+
+    if (sysId >= MAX_SYS_NUM) {
+        RLOGE("RadioIndication_v1_6_Proxy::setCallback SysId=%d Error!", sysId);
+        return -1;
+    }
+
+    if (-1 != sysId) {
+        mRadioIndication[sysId] = radioIndication;
+        return sysId;
+    }
+
+    //get a free slot
+    for (i = 0; i < MAX_SYS_NUM; i++) {
+        if (nullptr == mRadioIndication[i]) {
+            break;
+        }
+    }
+
+    if (i >= MAX_SYS_NUM) {
+        RLOGE("[RadioIndication_v1_6_Proxy::setCallback] no free slot!");
+        return -1;
+    }
+
+    mRadioIndication[i] = radioIndication;
+    return i;
+}
+
+
+Return<void> RadioIndication_v1_6_Proxy::radioStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioState radioState) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->radioStateChanged(type, radioState);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::callStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->callStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSms(type, pdu);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSmsStatusReport(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSmsStatusReport(type, pdu);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSmsOnSim(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t recordNumber) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSmsOnSim(type, recordNumber);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::onUssd(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::UssdModeType modeType, const ::android::hardware::hidl_string& msg) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->onUssd(type, modeType, msg);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::nitzTimeReceived(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& nitzTime, uint64_t receivedTime) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->nitzTimeReceived(type, nitzTime, receivedTime);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::suppSvcNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SuppSvcNotification& suppSvc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->suppSvcNotify(type, suppSvc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkSessionEnd(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkSessionEnd(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkProactiveCommand(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkProactiveCommand(type, cmd);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkEventNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkEventNotify(type, cmd);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkCallSetup(::android::hardware::radio::V1_0::RadioIndicationType type, int64_t timeout) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkCallSetup(type, timeout);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simSmsStorageFull(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simRefresh(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SimRefreshResult& refreshResult) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simRefresh(type, refreshResult);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::callRing(::android::hardware::radio::V1_0::RadioIndicationType type, bool isGsm, const ::android::hardware::radio::V1_0::CdmaSignalInfoRecord& record) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->callRing(type, isGsm, record);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simStatusChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaNewSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaSmsMessage& msg) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaNewSms(type, msg);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newBroadcastSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& data) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newBroadcastSms(type, data);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaRuimSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaRuimSmsStorageFull(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::restrictedStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::PhoneRestrictedState state) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->restrictedStateChanged(type, state);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::enterEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->enterEmergencyCallbackMode(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaCallWaiting(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaCallWaiting& callWaitingRecord) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaCallWaiting(type, callWaitingRecord);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaOtaProvisionStatus(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaOtaProvisionStatus status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaOtaProvisionStatus(type, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaInfoRec(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaInformationRecords& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaInfoRec(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::indicateRingbackTone(::android::hardware::radio::V1_0::RadioIndicationType type, bool start) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->indicateRingbackTone(type, start);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::resendIncallMute(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->resendIncallMute(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaSubscriptionSourceChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSource) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaSubscriptionSourceChanged(type, cdmaSource);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaPrlChanged(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t version) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaPrlChanged(type, version);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::exitEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->exitEmergencyCallbackMode(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::rilConnected(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->rilConnected(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::voiceRadioTechChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioTechnology rat) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->voiceRadioTechChanged(type, rat);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::imsNetworkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->imsNetworkStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::subscriptionStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool activate) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->subscriptionStatusChanged(type, activate);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::srvccStateNotify(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::SrvccState state) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->srvccStateNotify(type, state);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::hardwareConfigChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->hardwareConfigChanged(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::radioCapabilityIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->radioCapabilityIndication(type, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::onSupplementaryServiceIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::StkCcUnsolSsResult& ss) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->onSupplementaryServiceIndication(type, ss);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkCallControlAlphaNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& alpha) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkCallControlAlphaNotify(type, alpha);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::lceData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::LceDataInfo& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->lceData(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::pcoData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::PcoDataInfo& pco) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->pcoData(type, pco);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::modemReset(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& reason) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->modemReset(type, reason);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::carrierInfoForImsiEncryption(::android::hardware::radio::V1_0::RadioIndicationType info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->carrierInfoForImsiEncryption(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::keepaliveStatus(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::KeepaliveStatus& status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->keepaliveStatus(type, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_2(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_2(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentLinkCapacityEstimate(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::LinkCapacityEstimate& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentLinkCapacityEstimate(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_2(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentEmergencyNumberList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::EmergencyNumber>& emergencyNumberList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentEmergencyNumberList(type, emergencyNumberList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_4(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_4(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs_1_4(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_4(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_4(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::uiccApplicationsEnablementChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool enabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->uiccApplicationsEnablementChanged(type, enabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::registrationFailed(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_string& chosenPlmn, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::Domain> domain, int32_t causeCode, int32_t additionalCauseCode) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->registrationFailed(type, cellIdentity, chosenPlmn, domain, causeCode, additionalCauseCode);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::barringInfoChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->barringInfoChanged(type, cellIdentity, barringInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_5(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_5(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_5(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_6(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::unthrottleApn(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& apn) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->unthrottleApn(type, apn);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentLinkCapacityEstimate_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::LinkCapacityEstimate& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentLinkCapacityEstimate_1_6(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_6(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_6(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_6(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs_1_6(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simPhonebookChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simPhonebookChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simPhonebookRecordsReceived(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_6::PbReceivedStatus status, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhonebookRecordInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simPhonebookRecordsReceived(type, status, records);
+        }
+    }
+    return Void();
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
new file mode 100755
index 0000000000..2298a5ca83
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
@@ -0,0 +1,185 @@
+#pragma once
+
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/types.h>
+#include "proxy_common.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+class RadioIndication_v1_6_Proxy : public ::android::hardware::radio::V1_6::IRadioIndication {
+  private:
+    sp<::android::hardware::radio::V1_6::IRadioIndication> mRadioIndication[MAX_SYS_NUM];
+
+  public:
+    RadioIndication_v1_6_Proxy();
+    virtual ~RadioIndication_v1_6_Proxy() = default;
+
+    //static ::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioIndication>> castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& parent, bool emitError = false) {
+    //    return ::android::sp<::android::hardware::radio::V1_6::IRadioIndication>(static_cast<::android::hardware::radio::V1_6::IRadioIndication*>(parent.get()));
+    //}
+
+    int32_t setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioIndication> radioIndication);
+        
+    Return<void> radioStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioState radioState);
+
+    Return<void> callStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> networkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> newSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu);
+
+    Return<void> newSmsStatusReport(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu);
+
+    Return<void> newSmsOnSim(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t recordNumber);
+
+    Return<void> onUssd(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::UssdModeType modeType, const ::android::hardware::hidl_string& msg);
+
+    Return<void> nitzTimeReceived(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& nitzTime, uint64_t receivedTime);
+
+    Return<void> currentSignalStrength(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SignalStrength& signalStrength);
+
+    Return<void> dataCallListChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcList);
+
+    Return<void> suppSvcNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SuppSvcNotification& suppSvc);
+
+    Return<void> stkSessionEnd(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> stkProactiveCommand(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd);
+
+    Return<void> stkEventNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd);
+
+    Return<void> stkCallSetup(::android::hardware::radio::V1_0::RadioIndicationType type, int64_t timeout);
+
+    Return<void> simSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> simRefresh(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SimRefreshResult& refreshResult);
+
+    Return<void> callRing(::android::hardware::radio::V1_0::RadioIndicationType type, bool isGsm, const ::android::hardware::radio::V1_0::CdmaSignalInfoRecord& record);
+
+    Return<void> simStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaNewSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaSmsMessage& msg);
+
+    Return<void> newBroadcastSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& data);
+
+    Return<void> cdmaRuimSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> restrictedStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::PhoneRestrictedState state);
+
+    Return<void> enterEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaCallWaiting(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaCallWaiting& callWaitingRecord);
+
+    Return<void> cdmaOtaProvisionStatus(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaOtaProvisionStatus status);
+
+    Return<void> cdmaInfoRec(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaInformationRecords& records);
+
+    Return<void> indicateRingbackTone(::android::hardware::radio::V1_0::RadioIndicationType type, bool start);
+
+    Return<void> resendIncallMute(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaSubscriptionSourceChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSource);
+
+    Return<void> cdmaPrlChanged(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t version);
+
+    Return<void> exitEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> rilConnected(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> voiceRadioTechChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioTechnology rat);
+
+    Return<void> cellInfoList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& records);
+
+    Return<void> imsNetworkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> subscriptionStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool activate);
+
+    Return<void> srvccStateNotify(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::SrvccState state);
+
+    Return<void> hardwareConfigChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& configs);
+
+    Return<void> radioCapabilityIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> onSupplementaryServiceIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::StkCcUnsolSsResult& ss);
+
+    Return<void> stkCallControlAlphaNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& alpha);
+
+    Return<void> lceData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::LceDataInfo& lce);
+
+    Return<void> pcoData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::PcoDataInfo& pco);
+
+    Return<void> modemReset(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& reason);
+
+    Return<void> carrierInfoForImsiEncryption(::android::hardware::radio::V1_0::RadioIndicationType info);
+
+    Return<void> networkScanResult(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::NetworkScanResult& result);
+
+    Return<void> keepaliveStatus(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::KeepaliveStatus& status);
+
+    Return<void> networkScanResult_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::NetworkScanResult& result);
+
+    Return<void> cellInfoList_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& records);
+
+    Return<void> currentLinkCapacityEstimate(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::LinkCapacityEstimate& lce);
+
+    Return<void> currentPhysicalChannelConfigs(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::PhysicalChannelConfig>& configs);
+
+    Return<void> currentSignalStrength_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength);
+
+    Return<void> currentEmergencyNumberList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::EmergencyNumber>& emergencyNumberList);
+
+    Return<void> cellInfoList_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& records);
+
+    Return<void> networkScanResult_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::NetworkScanResult& result);
+
+    Return<void> currentPhysicalChannelConfigs_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::PhysicalChannelConfig>& configs);
+
+    Return<void> dataCallListChanged_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcList);
+
+    Return<void> currentSignalStrength_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength);
+
+    Return<void> uiccApplicationsEnablementChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool enabled);
+
+    Return<void> registrationFailed(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_string& chosenPlmn, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::Domain> domain, int32_t causeCode, int32_t additionalCauseCode);
+
+    Return<void> barringInfoChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos);
+
+    Return<void> cellInfoList_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& records);
+
+    Return<void> networkScanResult_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::NetworkScanResult& result);
+
+    Return<void> dataCallListChanged_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcList);
+
+    Return<void> dataCallListChanged_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcList);
+
+    Return<void> unthrottleApn(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& apn);
+
+    Return<void> currentLinkCapacityEstimate_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::LinkCapacityEstimate& lce);
+
+    Return<void> currentSignalStrength_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength);
+
+    Return<void> cellInfoList_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& records);
+
+    Return<void> networkScanResult_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::NetworkScanResult& result);
+
+    Return<void> currentPhysicalChannelConfigs_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhysicalChannelConfig>& configs);
+
+    Return<void> simPhonebookChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> simPhonebookRecordsReceived(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_6::PbReceivedStatus status, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhonebookRecordInfo>& records);
+
+};
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
new file mode 100755
index 0000000000..7084e41ebd
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
@@ -0,0 +1,1899 @@
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include "RadioResponse_V1_6_Proxy.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+RadioResponse_v1_6_Proxy::RadioResponse_v1_6_Proxy() {
+    for (int32_t sysId = 0; sysId < MAX_SYS_NUM; sysId++) {
+        mRadioResponse[sysId] = nullptr;
+    }
+}
+
+int32_t RadioResponse_v1_6_Proxy::setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioResponse> radioResponse) {
+    int32_t i = 0;
+
+    if (sysId >= MAX_SYS_NUM) {
+        RLOGE("RadioResponse_v1_6_Proxy::setCallback SysId=%d Error!", sysId);
+        return -1;
+    }
+
+    if (-1 != sysId) {
+        mRadioResponse[sysId] = radioResponse;
+        return sysId;
+    }
+
+    //get a free slot
+    for (i = 0; i < MAX_SYS_NUM; i++) {
+        if (nullptr == mRadioResponse[i]) {
+            break;
+        }
+    }
+
+    if (i >= MAX_SYS_NUM) {
+        RLOGE("[RadioResponse_v1_6_Proxy::setCallback] no free slot!");
+        return -1;
+    }
+
+    mRadioResponse[i] = radioResponse;
+    return i;
+}
+
+
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPinForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPukForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPukForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPin2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPuk2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPuk2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::changeIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->changeIccPinForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::changeIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->changeIccPin2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyNetworkDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyNetworkDepersonalizationResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::dialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->dialResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIMSIForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imsi) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIMSIForAppResponse(info, imsi);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupConnectionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupWaitingOrBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupWaitingOrBackgroundResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupForegroundResumeBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupForegroundResumeBackgroundResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::switchWaitingOrHoldingAndActiveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->switchWaitingOrHoldingAndActiveResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::conferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->conferenceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::rejectCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->rejectCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getLastCallFailCauseResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LastCallFailCauseInfo& failCauseinfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getLastCallFailCauseResponse(info, failCauseinfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SignalStrength& sigStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse(info, sigStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::VoiceRegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getOperatorResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& longName, const ::android::hardware::hidl_string& shortName, const ::android::hardware::hidl_string& numeric) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getOperatorResponse(info, longName, shortName, numeric);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSMSExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSMSExpectMoreResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccIOForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccIOForAppResponse(info, iccIo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendUssdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::cancelPendingUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->cancelPendingUssdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t n, int32_t m) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getClirResponse(info, n, m);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setClirResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCallForwardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CallForwardInfo>& callForwardInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCallForwardStatusResponse(info, callForwardInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCallForwardResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCallForwardResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable, int32_t serviceClass) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCallWaitingResponse(info, enable, serviceClass);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCallWaitingResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeLastIncomingGsmSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeLastIncomingGsmSmsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acceptCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acceptCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deactivateDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deactivateDataCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t response) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getFacilityLockForAppResponse(info, response);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t retry) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setFacilityLockForAppResponse(info, retry);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setBarringPasswordResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setBarringPasswordResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getNetworkSelectionModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool manual) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getNetworkSelectionModeResponse(info, manual);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeAutomaticResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeAutomaticResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeManualResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeManualResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAvailableNetworksResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::OperatorInfo>& networkInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAvailableNetworksResponse(info, networkInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getBasebandVersionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& version) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getBasebandVersionResponse(info, version);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::separateConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->separateConnectionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setMuteResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getMuteResponse(info, enable);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getClipResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::ClipStatus status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getClipResponse(info, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSuppServiceNotificationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSuppServiceNotificationsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::writeSmsToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t index) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->writeSmsToSimResponse(info, index);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deleteSmsOnSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deleteSmsOnSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setBandModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setBandModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAvailableBandModesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::RadioBandMode>& bandModes) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAvailableBandModesResponse(info, bandModes);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendEnvelopeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& commandResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendEnvelopeResponse(info, commandResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendTerminalResponseToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendTerminalResponseToSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::handleStkCallSetupRequestFromSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->handleStkCallSetupRequestFromSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::explicitCallTransferResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->explicitCallTransferResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredNetworkTypeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::PreferredNetworkType nwType) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredNetworkTypeResponse(info, nwType);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getNeighboringCidsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::NeighboringCell>& cells) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getNeighboringCidsResponse(info, cells);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLocationUpdatesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLocationUpdatesResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaSubscriptionSourceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaRoamingPreferenceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaRoamingType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaRoamingPreferenceResponse(info, type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setTTYModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::TtyMode mode) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getTTYModeResponse(info, mode);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredVoicePrivacyResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredVoicePrivacyResponse(info, enable);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCDMAFeatureCodeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCDMAFeatureCodeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendBurstDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendBurstDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeLastIncomingCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeLastIncomingCdmaSmsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getGsmBroadcastConfigResponse(info, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setGsmBroadcastConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setGsmBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setGsmBroadcastActivationResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaBroadcastConfigResponse(info, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaBroadcastConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaBroadcastActivationResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCDMASubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& mdn, const ::android::hardware::hidl_string& hSid, const ::android::hardware::hidl_string& hNid, const ::android::hardware::hidl_string& min, const ::android::hardware::hidl_string& prl) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCDMASubscriptionResponse(info, mdn, hSid, hNid, min, prl);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::writeSmsToRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, uint32_t index) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->writeSmsToRuimResponse(info, index);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deleteSmsOnRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deleteSmsOnRuimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDeviceIdentityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imei, const ::android::hardware::hidl_string& imeisv, const ::android::hardware::hidl_string& esn, const ::android::hardware::hidl_string& meid) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDeviceIdentityResponse(info, imei, imeisv, esn, meid);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::exitEmergencyCallbackModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->exitEmergencyCallbackModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& smsc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSmscAddressResponse(info, smsc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSmscAddressResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::reportSmsMemoryStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->reportSmsMemoryStatusResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::reportStkServiceIsRunningResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->reportStkServiceIsRunningResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaSubscriptionSource source) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaSubscriptionSourceResponse(info, source);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestIsimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& response) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestIsimAuthenticationResponse(info, response);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeIncomingGsmSmsWithPduResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeIncomingGsmSmsWithPduResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendEnvelopeWithStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendEnvelopeWithStatusResponse(info, iccIo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRadioTechnologyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::RadioTechnology rat) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRadioTechnologyResponse(info, rat);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCellInfoListRateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCellInfoListRateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setInitialAttachApnResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setInitialAttachApnResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getImsRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isRegistered, ::android::hardware::radio::V1_0::RadioTechnologyFamily ratFamily) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getImsRegistrationStateResponse(info, isRegistered, ratFamily);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendImsSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendImsSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccTransmitApduBasicChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccTransmitApduBasicChannelResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccOpenLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t channelId, const ::android::hardware::hidl_vec<int8_t>& selectResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccOpenLogicalChannelResponse(info, channelId, selectResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccCloseLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccCloseLogicalChannelResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccTransmitApduLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccTransmitApduLogicalChannelResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvReadItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvReadItemResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvWriteItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvWriteItemResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvWriteCdmaPrlResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvWriteCdmaPrlResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvResetConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvResetConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setUiccSubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setUiccSubscriptionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataAllowedResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataAllowedResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getHardwareConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& config) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getHardwareConfigResponse(info, config);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestIccSimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestIccSimAuthenticationResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataProfileResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataProfileResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestShutdownResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestShutdownResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getRadioCapabilityResponse(info, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioCapabilityResponse(info, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startLceServiceResponse(info, statusInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopLceServiceResponse(info, statusInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::pullLceDataResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceDataInfo& lceInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->pullLceDataResponse(info, lceInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getModemActivityInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::ActivityStatsInfo& activityInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getModemActivityInfoResponse(info, activityInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t numAllowed) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedCarriersResponse(info, numAllowed);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedCarriersResponse(info, allAllowed, carriers);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendDeviceStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendDeviceStateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setIndicationFilterResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setIndicationFilterResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeRequest(int32_t serial) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeRequest(serial);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCarrierInfoForImsiEncryptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCarrierInfoForImsiEncryptionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse_1_1(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse_1_1(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopNetworkScanResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_1::KeepaliveStatus& status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startKeepaliveResponse(info, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopKeepaliveResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_2(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_2(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSignalStrengthReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSignalStrengthReportingCriteriaResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLinkCapacityReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLinkCapacityReportingCriteriaResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse_1_2(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_2(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::VoiceRegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_2(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_2(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSystemSelectionChannelsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::enableModemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->enableModemResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getModemStackStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isEnabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getModemStackStatusResponse(info, isEnabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::emergencyDialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->emergencyDialResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse_1_4(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_4(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_4(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_4(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredNetworkTypeBitmapResponse(info, networkTypeBitmap);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredNetworkTypeBitmapResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_4(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_4(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedCarriersResponse_1_4(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedCarriersResponse_1_4(info, carriers, multiSimPolicy);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_4(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSignalStrengthReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSignalStrengthReportingCriteriaResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLinkCapacityReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLinkCapacityReportingCriteriaResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::enableUiccApplicationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->enableUiccApplicationsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::areUiccApplicationsEnabledResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->areUiccApplicationsEnabledResponse(info, enabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSystemSelectionChannelsResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSystemSelectionChannelsResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_5(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_5(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setInitialAttachApnResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setInitialAttachApnResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataProfileResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataProfileResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setIndicationFilterResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setIndicationFilterResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getBarringInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getBarringInfoResponse(info, cellIdentity, barringInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_5(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_5(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_5(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeManualResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeManualResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsExpectMoreResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplySimDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_5::PersoSubstate persoType, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplySimDepersonalizationResponse(info, persoType, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_5(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse_1_6(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_6(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_6(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsExpectMoreResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsExpectMoreResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse_1_6(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNrDualConnectivityStateResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNrDualConnectivityStateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::isNrDualConnectivityEnabledResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, bool isEnabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->isNrDualConnectivityEnabledResponse(info, isEnabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::allocatePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t id) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->allocatePduSessionIdResponse(info, id);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::releasePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->releasePduSessionIdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startHandoverResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::cancelHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->cancelHandoverResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedNetworkTypesBitmapResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedNetworkTypesBitmapResponse(info, networkTypeBitmap);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataThrottlingResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataThrottlingResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSystemSelectionChannelsResponse(info, specifiers);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_6(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_6(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_6(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_6(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse_1_6(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSlicingConfigResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SlicingConfig& slicingConfig) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSlicingConfigResponse(info, slicingConfig);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSimPhonebookRecordsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSimPhonebookCapacityResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::PhonebookCapacity& capacity) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSimPhonebookCapacityResponse(info, capacity);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::updateSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t updatedRecordIndex) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->updateSimPhonebookRecordsResponse(info, updatedRecordIndex);
+        }
+    }
+    return Void();
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
new file mode 100755
index 0000000000..ac45354139
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
@@ -0,0 +1,449 @@
+#pragma once
+
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/types.h>
+#include "proxy_common.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+class RadioResponse_v1_6_Proxy : public ::android::hardware::radio::V1_6::IRadioResponse {
+
+private:
+    sp<::android::hardware::radio::V1_6::IRadioResponse> mRadioResponse[MAX_SYS_NUM];
+
+public:
+    RadioResponse_v1_6_Proxy();
+
+    //static ::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioResponse>> castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& parent, bool emitError = false) {
+    //    return ::android::sp<::android::hardware::radio::V1_6::IRadioResponse>(static_cast<::android::hardware::radio::V1_6::IRadioResponse*>(parent.get()));
+    //}
+
+    int32_t setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioResponse> radioResponse);
+
+    virtual ~RadioResponse_v1_6_Proxy() = default;
+
+    Return<void> getIccCardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::CardStatus& cardStatus);
+
+    Return<void> supplyIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPukForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPuk2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> changeIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> changeIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyNetworkDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> getCurrentCallsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::Call>& calls);
+
+    Return<void> dialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getIMSIForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imsi);
+
+    Return<void> hangupConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> hangupWaitingOrBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> hangupForegroundResumeBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> switchWaitingOrHoldingAndActiveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> conferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> rejectCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getLastCallFailCauseResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LastCallFailCauseInfo& failCauseinfo);
+
+    Return<void> getSignalStrengthResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SignalStrength& sigStrength);
+
+    Return<void> getVoiceRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::VoiceRegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::DataRegStateResult& dataRegResponse);
+
+    Return<void> getOperatorResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& longName, const ::android::hardware::hidl_string& shortName, const ::android::hardware::hidl_string& numeric);
+
+    Return<void> setRadioPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendSMSExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> setupDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SetupDataCallResult& dcResponse);
+
+    Return<void> iccIOForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo);
+
+    Return<void> sendUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> cancelPendingUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t n, int32_t m);
+
+    Return<void> setClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCallForwardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CallForwardInfo>& callForwardInfos);
+
+    Return<void> setCallForwardResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable, int32_t serviceClass);
+
+    Return<void> setCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acknowledgeLastIncomingGsmSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acceptCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> deactivateDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t response);
+
+    Return<void> setFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t retry);
+
+    Return<void> setBarringPasswordResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getNetworkSelectionModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool manual);
+
+    Return<void> setNetworkSelectionModeAutomaticResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setNetworkSelectionModeManualResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAvailableNetworksResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::OperatorInfo>& networkInfos);
+
+    Return<void> startDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> stopDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getBasebandVersionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& version);
+
+    Return<void> separateConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable);
+
+    Return<void> getClipResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::ClipStatus status);
+
+    Return<void> getDataCallListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcResponse);
+
+    Return<void> setSuppServiceNotificationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> writeSmsToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t index);
+
+    Return<void> deleteSmsOnSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setBandModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAvailableBandModesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::RadioBandMode>& bandModes);
+
+    Return<void> sendEnvelopeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& commandResponse);
+
+    Return<void> sendTerminalResponseToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> handleStkCallSetupRequestFromSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> explicitCallTransferResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::PreferredNetworkType nwType);
+
+    Return<void> getNeighboringCidsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::NeighboringCell>& cells);
+
+    Return<void> setLocationUpdatesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaRoamingType type);
+
+    Return<void> setTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::TtyMode mode);
+
+    Return<void> setPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable);
+
+    Return<void> sendCDMAFeatureCodeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendBurstDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> acknowledgeLastIncomingCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configs);
+
+    Return<void> setGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setGsmBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configs);
+
+    Return<void> setCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCDMASubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& mdn, const ::android::hardware::hidl_string& hSid, const ::android::hardware::hidl_string& hNid, const ::android::hardware::hidl_string& min, const ::android::hardware::hidl_string& prl);
+
+    Return<void> writeSmsToRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, uint32_t index);
+
+    Return<void> deleteSmsOnRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getDeviceIdentityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imei, const ::android::hardware::hidl_string& imeisv, const ::android::hardware::hidl_string& esn, const ::android::hardware::hidl_string& meid);
+
+    Return<void> exitEmergencyCallbackModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& smsc);
+
+    Return<void> setSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> reportSmsMemoryStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> reportStkServiceIsRunningResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaSubscriptionSource source);
+
+    Return<void> requestIsimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& response);
+
+    Return<void> acknowledgeIncomingGsmSmsWithPduResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendEnvelopeWithStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo);
+
+    Return<void> getVoiceRadioTechnologyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::RadioTechnology rat);
+
+    Return<void> getCellInfoListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& cellInfo);
+
+    Return<void> setCellInfoListRateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setInitialAttachApnResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getImsRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isRegistered, ::android::hardware::radio::V1_0::RadioTechnologyFamily ratFamily);
+
+    Return<void> sendImsSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> iccTransmitApduBasicChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> iccOpenLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t channelId, const ::android::hardware::hidl_vec<int8_t>& selectResponse);
+
+    Return<void> iccCloseLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> iccTransmitApduLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> nvReadItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& result);
+
+    Return<void> nvWriteItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> nvWriteCdmaPrlResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> nvResetConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setUiccSubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setDataAllowedResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getHardwareConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& config);
+
+    Return<void> requestIccSimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> setDataProfileResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> requestShutdownResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> setRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> startLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo);
+
+    Return<void> stopLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo);
+
+    Return<void> pullLceDataResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceDataInfo& lceInfo);
+
+    Return<void> getModemActivityInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::ActivityStatsInfo& activityInfo);
+
+    Return<void> setAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t numAllowed);
+
+    Return<void> getAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers);
+
+    Return<void> sendDeviceStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setIndicationFilterResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setSimCardPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acknowledgeRequest(int32_t serial);
+
+    Return<void> setCarrierInfoForImsiEncryptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setSimCardPowerResponse_1_1(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> stopNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_1::KeepaliveStatus& status);
+
+    Return<void> stopKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCellInfoListResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& cellInfo);
+
+    Return<void> getIccCardStatusResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::CardStatus& cardStatus);
+
+    Return<void> setSignalStrengthReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setLinkCapacityReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCurrentCallsResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::Call>& calls);
+
+    Return<void> getSignalStrengthResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength);
+
+    Return<void> getVoiceRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::VoiceRegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::DataRegStateResult& dataRegResponse);
+
+    Return<void> setSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> enableModemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getModemStackStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isEnabled);
+
+    Return<void> emergencyDialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCellInfoListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& cellInfo);
+
+    Return<void> getDataRegistrationStateResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::DataRegStateResult& dataRegResponse);
+
+    Return<void> getIccCardStatusResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CardStatus& cardStatus);
+
+    Return<void> getPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getDataCallListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcResponse);
+
+    Return<void> setupDataCallResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SetupDataCallResult& dcResponse);
+
+    Return<void> setAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy);
+
+    Return<void> getSignalStrengthResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength);
+
+    Return<void> setSignalStrengthReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setLinkCapacityReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> enableUiccApplicationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> areUiccApplicationsEnabledResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enabled);
+
+    Return<void> setSystemSelectionChannelsResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setupDataCallResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::SetupDataCallResult& dcResponse);
+
+    Return<void> getDataCallListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcResponse);
+
+    Return<void> setInitialAttachApnResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setDataProfileResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setRadioPowerResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setIndicationFilterResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getBarringInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos);
+
+    Return<void> getVoiceRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& dataRegResponse);
+
+    Return<void> getCellInfoListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& cellInfo);
+
+    Return<void> setNetworkSelectionModeManualResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendCdmaSmsExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> supplySimDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_5::PersoSubstate persoType, int32_t remainingRetries);
+
+    Return<void> getIccCardStatusResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CardStatus& cardStatus);
+
+    Return<void> setRadioPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setupDataCallResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SetupDataCallResult& dcResponse);
+
+    Return<void> getDataCallListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcResponse);
+
+    Return<void> sendSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendCdmaSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendCdmaSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> setSimCardPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setNrDualConnectivityStateResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> isNrDualConnectivityEnabledResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, bool isEnabled);
+
+    Return<void> allocatePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t id);
+
+    Return<void> releasePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> startHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> cancelHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setDataThrottlingResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers);
+
+    Return<void> getCellInfoListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& cellInfo);
+
+    Return<void> getSignalStrengthResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength);
+
+    Return<void> getVoiceRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& dataRegResponse);
+
+    Return<void> getCurrentCallsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::Call>& calls);
+
+    Return<void> getSlicingConfigResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SlicingConfig& slicingConfig);
+
+    Return<void> getSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getSimPhonebookCapacityResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::PhonebookCapacity& capacity);
+
+    Return<void> updateSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t updatedRecordIndex);
+
+};
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
new file mode 100755
index 0000000000..dd4e450ea9
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
@@ -0,0 +1,3 @@
+#pragma once
+
+#define MAX_SYS_NUM 3
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
new file mode 100755
index 0000000000..1f71d7280e
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include <hidl/HidlTransportSupport.h>
+#include "RadioResponse_V1_6_Proxy.h"
+#include "RadioIndication_V1_6_Proxy.h"
+#include "ril_service_1_6_proxy.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+#define SIM_COUNT 2
+
+int main(int argc, char **argv) {
+    android::status_t status;
+    sp<::android::hardware::radio::V1_6::IRadio> radio_v1_6 = nullptr;
+    int32_t slot = 0;
+    const char *serviceNames[] = {
+        "slot1"
+        #if (SIM_COUNT >= 2)
+        , "slot2"
+        #if (SIM_COUNT >= 3)
+        , "slot3"
+        #if (SIM_COUNT >= 4)
+        , "slot4"
+        #endif
+        #endif
+        #endif
+    };
+    const char *proxyServiceNames[] = {
+            "slot1_proxy"
+            #if (SIM_COUNT >= 2)
+            , "slot2_proxy"
+            #if (SIM_COUNT >= 3)
+            , "slot3_proxy"
+            #if (SIM_COUNT >= 4)
+            , "slot4_proxy"
+            #endif
+            #endif
+            #endif
+        };
+
+
+    if (argc < 2) {
+        return -1;
+    }
+
+    slot = atoi(argv[1]);
+    RLOGD("slot = %d\n", slot);
+    if (argc >= 3) {
+        //test
+        radio_v1_6 = android::hardware::radio::V1_6::IRadio::getService(proxyServiceNames[slot]);
+        if (radio_v1_6 == nullptr) {
+            RLOGD("RIL_Proxy_Init radio_v1_6(%s) is null \n", proxyServiceNames[slot]);
+            return 0;
+        }
+
+        int32_t serial = 0x55AA55AA;
+        ::android::hardware::radio::V1_5::AccessNetwork accessNetwork =
+                ::android::hardware::radio::V1_5::AccessNetwork::EUTRAN;
+
+        android::hardware::radio::V1_5::DataProfileInfo dataProfileInfo;
+        memset(&dataProfileInfo, 0, sizeof(dataProfileInfo));
+        dataProfileInfo.profileId = DataProfileId::DEFAULT;
+        dataProfileInfo.apn = hidl_string("internet");
+        dataProfileInfo.protocol = PdpProtocolType::IP;
+        dataProfileInfo.roamingProtocol = PdpProtocolType::IP;
+        dataProfileInfo.authType = ApnAuthType::NO_PAP_NO_CHAP;
+        dataProfileInfo.user = hidl_string("username");
+        dataProfileInfo.password = hidl_string("password");
+        dataProfileInfo.type = DataProfileInfoType::THREE_GPP;
+        dataProfileInfo.maxConnsTime = 300;
+        dataProfileInfo.maxConns = 20;
+        dataProfileInfo.waitTime = 0;
+        dataProfileInfo.enabled = true;
+        dataProfileInfo.supportedApnTypesBitmap = 320;
+        dataProfileInfo.bearerBitmap = 161543;
+        dataProfileInfo.mtuV4 = 0;
+        dataProfileInfo.mtuV6 = 0;
+        dataProfileInfo.preferred = true;
+        dataProfileInfo.persistent = false;
+
+        bool roamingAllowed = false;
+
+        std::vector<::android::hardware::radio::V1_5::LinkAddress> addresses = {};
+        std::vector<hidl_string> dnses = {};
+
+        ::android::hardware::radio::V1_2::DataRequestReason reason =
+                ::android::hardware::radio::V1_2::DataRequestReason::NORMAL;
+
+        ::android::hardware::radio::V1_6::OptionalSliceInfo optionalSliceInfo;
+        memset(&optionalSliceInfo, 0, sizeof(optionalSliceInfo));
+
+        ::android::hardware::radio::V1_6::OptionalTrafficDescriptor optionalTrafficDescriptor;
+        memset(&optionalTrafficDescriptor, 0, sizeof(optionalTrafficDescriptor));
+
+        bool matchAllRuleAllowed = true;
+
+        radio_v1_6->setupDataCall_1_6(serial, accessNetwork, dataProfileInfo, roamingAllowed,
+                                          reason, addresses, dnses, -1, optionalSliceInfo,
+                                          optionalTrafficDescriptor, matchAllRuleAllowed);
+        RLOGD("RIL_Proxy_Init radio_v1_6(%s) setupDataCall_1_6 after\n", proxyServiceNames[slot]);
+
+        return 0;
+    }
+
+    android::hardware::configureRpcThreadpool(2, true /* callerWillJoin */);
+
+    radio_v1_6 = android::hardware::radio::V1_6::IRadio::getService(serviceNames[slot]);
+    if (radio_v1_6 == nullptr) {
+        RLOGD("RIL_Proxy_Init radio_v1_6 is null \n");
+    }
+
+    sp<RadioImpl_1_6_Proxy> radioImpl_1_6_Proxy = new (std::nothrow) RadioImpl_1_6_Proxy(slot, radio_v1_6);
+    if (radioImpl_1_6_Proxy == nullptr) {
+        RLOGD("RIL_Proxy_Init radioImpl_1_6_Proxy is null \n");
+    }
+
+    status = radioImpl_1_6_Proxy->registerAsService(proxyServiceNames[slot]);
+
+    RLOGD("RIL_Proxy_Init starting sleep loop");
+    while (true) {
+        sleep(UINT32_MAX);
+    }
+
+    return 0;
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
new file mode 100755
index 0000000000..c4dc7c8fdb
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
@@ -0,0 +1,1078 @@
+
+#include "ril_service_1_6_proxy.h"
+
+::android::status_t RadioImpl_1_6_Proxy::registerAsService(const std::string &serviceName) {
+    return ::android::hardware::radio::V1_6::IRadio::registerAsService(serviceName);
+}
+
+//::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioResponse>> RadioImpl_1_6_Proxy::castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& parent, bool /* emitError */) {
+//    return (::android::sp<::android::hardware::radio::V1_6::IRadioResponse>)parent;
+//}
+
+void RadioImpl_1_6_Proxy::serviceDied(uint64_t cookie,
+        const ::android::wp<::android::hidl::base::V1_0::IBase>& who) {
+    int32_t sysId = cookie;
+    (void)who;
+    RLOGD("RadioImpl_1_6_Proxy::serviceDied: Client %d died. Cleaning up callbacks", sysId);
+    mRadioResponseV1_6->setCallback(sysId, nullptr);
+    mRadioIndicationV1_6->setCallback(sysId, nullptr);
+}
+
+Return<void> RadioImpl_1_6_Proxy::setResponseFunctions(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& radioResponse, const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& radioIndication) {
+    int sysId = 0;
+
+    ::android::sp<::android::hardware::radio::V1_6::IRadioResponse> tmpResponse =::android::hardware::radio::V1_6::IRadioResponse::castFrom(radioResponse)
+                             .withDefault(nullptr);
+    ::android::sp<::android::hardware::radio::V1_6::IRadioIndication> tmpIndication = ::android::hardware::radio::V1_6::IRadioIndication::castFrom(radioIndication)
+                             .withDefault(nullptr);
+    if (nullptr != tmpResponse && nullptr != tmpIndication) {
+        sysId = mRadioResponseV1_6->setCallback(-1, tmpResponse);
+        mRadioIndicationV1_6->setCallback(-1, tmpIndication);
+        RLOGD("setCallback to free_slot %d\n", sysId);
+        tmpResponse->linkToDeath(this, sysId);
+        mRealService->setResponseFunctions(mRadioResponseV1_6, mRadioIndicationV1_6);
+    }
+
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getIccCardStatus(int32_t serial) {
+    mRealService->getIccCardStatus(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPinForApp(serial, pin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPukForApp(int32_t serial, const ::android::hardware::hidl_string& puk, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPukForApp(serial, puk, pin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPin2ForApp(serial, pin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPuk2ForApp(int32_t serial, const ::android::hardware::hidl_string& puk2, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPuk2ForApp(serial, puk2, pin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::changeIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin, const ::android::hardware::hidl_string& newPin, const ::android::hardware::hidl_string& aid) {
+    mRealService->changeIccPinForApp(serial, oldPin, newPin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::changeIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin2, const ::android::hardware::hidl_string& newPin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->changeIccPin2ForApp(serial, oldPin2, newPin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyNetworkDepersonalization(int32_t serial, const ::android::hardware::hidl_string& netPin) {
+    mRealService->supplyNetworkDepersonalization(serial, netPin);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCurrentCalls(int32_t serial) {
+    mRealService->getCurrentCalls(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::dial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo) {
+    mRealService->dial(serial, dialInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getImsiForApp(int32_t serial, const ::android::hardware::hidl_string& aid) {
+    mRealService->getImsiForApp(serial, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangup(int32_t serial, int32_t gsmIndex) {
+    mRealService->hangup(serial, gsmIndex);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangupWaitingOrBackground(int32_t serial) {
+    mRealService->hangupWaitingOrBackground(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangupForegroundResumeBackground(int32_t serial) {
+    mRealService->hangupForegroundResumeBackground(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::switchWaitingOrHoldingAndActive(int32_t serial) {
+    mRealService->switchWaitingOrHoldingAndActive(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::conference(int32_t serial) {
+    mRealService->conference(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::rejectCall(int32_t serial) {
+    mRealService->rejectCall(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getLastCallFailCause(int32_t serial) {
+    mRealService->getLastCallFailCause(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength(int32_t serial) {
+    mRealService->getSignalStrength(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState(int32_t serial) {
+    mRealService->getVoiceRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState(int32_t serial) {
+    mRealService->getDataRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getOperator(int32_t serial) {
+    mRealService->getOperator(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower(int32_t serial, bool on) {
+    mRealService->setRadioPower(serial, on);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendDtmf(int32_t serial, const ::android::hardware::hidl_string& s) {
+    mRealService->sendDtmf(serial, s);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSms(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSms(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSMSExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSMSExpectMore(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall(int32_t serial, ::android::hardware::radio::V1_0::RadioTechnology radioTechnology, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming) {
+    mRealService->setupDataCall(serial, radioTechnology, dataProfileInfo, modemCognitive, roamingAllowed, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccIOForApp(int32_t serial, const ::android::hardware::radio::V1_0::IccIo& iccIo) {
+    mRealService->iccIOForApp(serial, iccIo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendUssd(int32_t serial, const ::android::hardware::hidl_string& ussd) {
+    mRealService->sendUssd(serial, ussd);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::cancelPendingUssd(int32_t serial) {
+    mRealService->cancelPendingUssd(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getClir(int32_t serial) {
+    mRealService->getClir(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setClir(int32_t serial, int32_t status) {
+    mRealService->setClir(serial, status);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCallForwardStatus(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo) {
+    mRealService->getCallForwardStatus(serial, callInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCallForward(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo) {
+    mRealService->setCallForward(serial, callInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCallWaiting(int32_t serial, int32_t serviceClass) {
+    mRealService->getCallWaiting(serial, serviceClass);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCallWaiting(int32_t serial, bool enable, int32_t serviceClass) {
+    mRealService->setCallWaiting(serial, enable, serviceClass);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeLastIncomingGsmSms(int32_t serial, bool success, ::android::hardware::radio::V1_0::SmsAcknowledgeFailCause cause) {
+    mRealService->acknowledgeLastIncomingGsmSms(serial, success, cause);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acceptCall(int32_t serial) {
+    mRealService->acceptCall(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deactivateDataCall(int32_t serial, int32_t cid, bool reasonRadioShutDown) {
+    mRealService->deactivateDataCall(serial, cid, reasonRadioShutDown);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId) {
+    mRealService->getFacilityLockForApp(serial, facility, password, serviceClass, appId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, bool lockState, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId) {
+    mRealService->setFacilityLockForApp(serial, facility, lockState, password, serviceClass, appId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setBarringPassword(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& oldPassword, const ::android::hardware::hidl_string& newPassword) {
+    mRealService->setBarringPassword(serial, facility, oldPassword, newPassword);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getNetworkSelectionMode(int32_t serial) {
+    mRealService->getNetworkSelectionMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeAutomatic(int32_t serial) {
+    mRealService->setNetworkSelectionModeAutomatic(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeManual(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric) {
+    mRealService->setNetworkSelectionModeManual(serial, operatorNumeric);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAvailableNetworks(int32_t serial) {
+    mRealService->getAvailableNetworks(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startDtmf(int32_t serial, const ::android::hardware::hidl_string& s) {
+    mRealService->startDtmf(serial, s);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopDtmf(int32_t serial) {
+    mRealService->stopDtmf(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getBasebandVersion(int32_t serial) {
+    mRealService->getBasebandVersion(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::separateConnection(int32_t serial, int32_t gsmIndex) {
+    mRealService->separateConnection(serial, gsmIndex);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setMute(int32_t serial, bool enable) {
+    mRealService->setMute(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getMute(int32_t serial) {
+    mRealService->getMute(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getClip(int32_t serial) {
+    mRealService->getClip(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataCallList(int32_t serial) {
+    mRealService->getDataCallList(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSuppServiceNotifications(int32_t serial, bool enable) {
+    mRealService->setSuppServiceNotifications(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::writeSmsToSim(int32_t serial, const ::android::hardware::radio::V1_0::SmsWriteArgs& smsWriteArgs) {
+    mRealService->writeSmsToSim(serial, smsWriteArgs);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deleteSmsOnSim(int32_t serial, int32_t index) {
+    mRealService->deleteSmsOnSim(serial, index);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setBandMode(int32_t serial, ::android::hardware::radio::V1_0::RadioBandMode mode) {
+    mRealService->setBandMode(serial, mode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAvailableBandModes(int32_t serial) {
+    mRealService->getAvailableBandModes(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendEnvelope(int32_t serial, const ::android::hardware::hidl_string& command) {
+    mRealService->sendEnvelope(serial, command);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendTerminalResponseToSim(int32_t serial, const ::android::hardware::hidl_string& commandResponse) {
+    mRealService->sendTerminalResponseToSim(serial, commandResponse);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::handleStkCallSetupRequestFromSim(int32_t serial, bool accept) {
+    mRealService->handleStkCallSetupRequestFromSim(serial, accept);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::explicitCallTransfer(int32_t serial) {
+    mRealService->explicitCallTransfer(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredNetworkType(int32_t serial, ::android::hardware::radio::V1_0::PreferredNetworkType nwType) {
+    mRealService->setPreferredNetworkType(serial, nwType);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredNetworkType(int32_t serial) {
+    mRealService->getPreferredNetworkType(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getNeighboringCids(int32_t serial) {
+    mRealService->getNeighboringCids(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLocationUpdates(int32_t serial, bool enable) {
+    mRealService->setLocationUpdates(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaSubscriptionSource(int32_t serial, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSub) {
+    mRealService->setCdmaSubscriptionSource(serial, cdmaSub);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaRoamingPreference(int32_t serial, ::android::hardware::radio::V1_0::CdmaRoamingType type) {
+    mRealService->setCdmaRoamingPreference(serial, type);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaRoamingPreference(int32_t serial) {
+    mRealService->getCdmaRoamingPreference(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setTTYMode(int32_t serial, ::android::hardware::radio::V1_0::TtyMode mode) {
+    mRealService->setTTYMode(serial, mode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getTTYMode(int32_t serial) {
+    mRealService->getTTYMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredVoicePrivacy(int32_t serial, bool enable) {
+    mRealService->setPreferredVoicePrivacy(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredVoicePrivacy(int32_t serial) {
+    mRealService->getPreferredVoicePrivacy(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCDMAFeatureCode(int32_t serial, const ::android::hardware::hidl_string& featureCode) {
+    mRealService->sendCDMAFeatureCode(serial, featureCode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendBurstDtmf(int32_t serial, const ::android::hardware::hidl_string& dtmf, int32_t on, int32_t off) {
+    mRealService->sendBurstDtmf(serial, dtmf, on, off);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSms(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeLastIncomingCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsAck& smsAck) {
+    mRealService->acknowledgeLastIncomingCdmaSms(serial, smsAck);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getGsmBroadcastConfig(int32_t serial) {
+    mRealService->getGsmBroadcastConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setGsmBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configInfo) {
+    mRealService->setGsmBroadcastConfig(serial, configInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setGsmBroadcastActivation(int32_t serial, bool activate) {
+    mRealService->setGsmBroadcastActivation(serial, activate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaBroadcastConfig(int32_t serial) {
+    mRealService->getCdmaBroadcastConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configInfo) {
+    mRealService->setCdmaBroadcastConfig(serial, configInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaBroadcastActivation(int32_t serial, bool activate) {
+    mRealService->setCdmaBroadcastActivation(serial, activate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCDMASubscription(int32_t serial) {
+    mRealService->getCDMASubscription(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::writeSmsToRuim(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsWriteArgs& cdmaSms) {
+    mRealService->writeSmsToRuim(serial, cdmaSms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deleteSmsOnRuim(int32_t serial, int32_t index) {
+    mRealService->deleteSmsOnRuim(serial, index);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDeviceIdentity(int32_t serial) {
+    mRealService->getDeviceIdentity(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::exitEmergencyCallbackMode(int32_t serial) {
+    mRealService->exitEmergencyCallbackMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSmscAddress(int32_t serial) {
+    mRealService->getSmscAddress(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSmscAddress(int32_t serial, const ::android::hardware::hidl_string& smsc) {
+    mRealService->setSmscAddress(serial, smsc);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::reportSmsMemoryStatus(int32_t serial, bool available) {
+    mRealService->reportSmsMemoryStatus(serial, available);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::reportStkServiceIsRunning(int32_t serial) {
+    mRealService->reportStkServiceIsRunning(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaSubscriptionSource(int32_t serial) {
+    mRealService->getCdmaSubscriptionSource(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestIsimAuthentication(int32_t serial, const ::android::hardware::hidl_string& challenge) {
+    mRealService->requestIsimAuthentication(serial, challenge);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success, const ::android::hardware::hidl_string& ackPdu) {
+    mRealService->acknowledgeIncomingGsmSmsWithPdu(serial, success, ackPdu);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendEnvelopeWithStatus(int32_t serial, const ::android::hardware::hidl_string& contents) {
+    mRealService->sendEnvelopeWithStatus(serial, contents);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRadioTechnology(int32_t serial) {
+    mRealService->getVoiceRadioTechnology(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCellInfoList(int32_t serial) {
+    mRealService->getCellInfoList(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCellInfoListRate(int32_t serial, int32_t rate) {
+    mRealService->setCellInfoListRate(serial, rate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn(int32_t serial, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool isRoaming) {
+    mRealService->setInitialAttachApn(serial, dataProfileInfo, modemCognitive, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getImsRegistrationState(int32_t serial) {
+    mRealService->getImsRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendImsSms(int32_t serial, const ::android::hardware::radio::V1_0::ImsSmsMessage& message) {
+    mRealService->sendImsSms(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccTransmitApduBasicChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message) {
+    mRealService->iccTransmitApduBasicChannel(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccOpenLogicalChannel(int32_t serial, const ::android::hardware::hidl_string& aid, int32_t p2) {
+    mRealService->iccOpenLogicalChannel(serial, aid, p2);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccCloseLogicalChannel(int32_t serial, int32_t channelId) {
+    mRealService->iccCloseLogicalChannel(serial, channelId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccTransmitApduLogicalChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message) {
+    mRealService->iccTransmitApduLogicalChannel(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvReadItem(int32_t serial, ::android::hardware::radio::V1_0::NvItem itemId) {
+    mRealService->nvReadItem(serial, itemId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvWriteItem(int32_t serial, const ::android::hardware::radio::V1_0::NvWriteItem& item) {
+    mRealService->nvWriteItem(serial, item);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvWriteCdmaPrl(int32_t serial, const ::android::hardware::hidl_vec<uint8_t>& prl) {
+    mRealService->nvWriteCdmaPrl(serial, prl);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvResetConfig(int32_t serial, ::android::hardware::radio::V1_0::ResetNvType resetType) {
+    mRealService->nvResetConfig(serial, resetType);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setUiccSubscription(int32_t serial, const ::android::hardware::radio::V1_0::SelectUiccSub& uiccSub) {
+    mRealService->setUiccSubscription(serial, uiccSub);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataAllowed(int32_t serial, bool allow) {
+    mRealService->setDataAllowed(serial, allow);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getHardwareConfig(int32_t serial) {
+    mRealService->getHardwareConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestIccSimAuthentication(int32_t serial, int32_t authContext, const ::android::hardware::hidl_string& authData, const ::android::hardware::hidl_string& aid) {
+    mRealService->requestIccSimAuthentication(serial, authContext, authData, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::DataProfileInfo>& profiles, bool isRoaming) {
+    mRealService->setDataProfile(serial, profiles, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestShutdown(int32_t serial) {
+    mRealService->requestShutdown(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getRadioCapability(int32_t serial) {
+    mRealService->getRadioCapability(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioCapability(int32_t serial, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    mRealService->setRadioCapability(serial, rc);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startLceService(int32_t serial, int32_t reportInterval, bool pullMode) {
+    mRealService->startLceService(serial, reportInterval, pullMode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopLceService(int32_t serial) {
+    mRealService->stopLceService(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::pullLceData(int32_t serial) {
+    mRealService->pullLceData(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getModemActivityInfo(int32_t serial) {
+    mRealService->getModemActivityInfo(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedCarriers(int32_t serial, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers) {
+    mRealService->setAllowedCarriers(serial, allAllowed, carriers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedCarriers(int32_t serial) {
+    mRealService->getAllowedCarriers(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendDeviceState(int32_t serial, ::android::hardware::radio::V1_0::DeviceStateType deviceStateType, bool state) {
+    mRealService->sendDeviceState(serial, deviceStateType, state);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_0::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower(int32_t serial, bool powerUp) {
+    mRealService->setSimCardPower(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::responseAcknowledgement() {
+    mRealService->responseAcknowledgement();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCarrierInfoForImsiEncryption(int32_t serial, const ::android::hardware::radio::V1_1::ImsiEncryptionInfo& imsiEncryptionInfo) {
+    mRealService->setCarrierInfoForImsiEncryption(serial, imsiEncryptionInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower_1_1(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp) {
+    mRealService->setSimCardPower_1_1(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan(int32_t serial, const ::android::hardware::radio::V1_1::NetworkScanRequest& request) {
+    mRealService->startNetworkScan(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopNetworkScan(int32_t serial) {
+    mRealService->stopNetworkScan(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startKeepalive(int32_t serial, const ::android::hardware::radio::V1_1::KeepaliveRequest& keepalive) {
+    mRealService->startKeepalive(serial, keepalive);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopKeepalive(int32_t serial, int32_t sessionHandle) {
+    mRealService->stopKeepalive(serial, sessionHandle);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_2(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_2(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter_1_2(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_2::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter_1_2(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSignalStrengthReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDb, const ::android::hardware::hidl_vec<int32_t>& thresholdsDbm, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork) {
+    mRealService->setSignalStrengthReportingCriteria(serial, hysteresisMs, hysteresisDb, thresholdsDbm, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLinkCapacityReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork) {
+    mRealService->setLinkCapacityReportingCriteria(serial, hysteresisMs, hysteresisDlKbps, hysteresisUlKbps, thresholdsDownlinkKbps, thresholdsUplinkKbps, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_2(int32_t serial, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_2(serial, accessNetwork, dataProfileInfo, modemCognitive, roamingAllowed, isRoaming, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deactivateDataCall_1_2(int32_t serial, int32_t cid, ::android::hardware::radio::V1_2::DataRequestReason reason) {
+    mRealService->deactivateDataCall_1_2(serial, cid, reason);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSystemSelectionChannels(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& specifiers) {
+    mRealService->setSystemSelectionChannels(serial, specifyChannels, specifiers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::enableModem(int32_t serial, bool on) {
+    mRealService->enableModem(serial, on);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getModemStackStatus(int32_t serial) {
+    mRealService->getModemStackStatus(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_4(int32_t serial, ::android::hardware::radio::V1_4::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_4(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn_1_4(int32_t serial, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo) {
+    mRealService->setInitialAttachApn_1_4(serial, dataProfileInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile_1_4(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& profiles) {
+    mRealService->setDataProfile_1_4(serial, profiles);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::emergencyDial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting) {
+    mRealService->emergencyDial(serial, dialInfo, categories, urns, routing, hasKnownUserIntentEmergency, isTesting);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_4(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_4(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredNetworkTypeBitmap(int32_t serial) {
+    mRealService->getPreferredNetworkTypeBitmap(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredNetworkTypeBitmap(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    mRealService->setPreferredNetworkTypeBitmap(serial, networkTypeBitmap);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedCarriers_1_4(int32_t serial, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy) {
+    mRealService->setAllowedCarriers_1_4(serial, carriers, multiSimPolicy);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedCarriers_1_4(int32_t serial) {
+    mRealService->getAllowedCarriers_1_4(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength_1_4(int32_t serial) {
+    mRealService->getSignalStrength_1_4(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSignalStrengthReportingCriteria_1_5(int32_t serial, const ::android::hardware::radio::V1_5::SignalThresholdInfo& signalThresholdInfo, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork) {
+    mRealService->setSignalStrengthReportingCriteria_1_5(serial, signalThresholdInfo, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLinkCapacityReportingCriteria_1_5(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork) {
+    mRealService->setLinkCapacityReportingCriteria_1_5(serial, hysteresisMs, hysteresisDlKbps, hysteresisUlKbps, thresholdsDownlinkKbps, thresholdsUplinkKbps, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::enableUiccApplications(int32_t serial, bool enable) {
+    mRealService->enableUiccApplications(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::areUiccApplicationsEnabled(int32_t serial) {
+    mRealService->areUiccApplicationsEnabled(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSystemSelectionChannels_1_5(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers) {
+    mRealService->setSystemSelectionChannels_1_5(serial, specifyChannels, specifiers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_5(int32_t serial, const ::android::hardware::radio::V1_5::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_5(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_5(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_5(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn_1_5(int32_t serial, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo) {
+    mRealService->setInitialAttachApn_1_5(serial, dataProfileInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile_1_5(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& profiles) {
+    mRealService->setDataProfile_1_5(serial, profiles);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall) {
+    mRealService->setRadioPower_1_5(serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter_1_5(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter_1_5(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getBarringInfo(int32_t serial) {
+    mRealService->getBarringInfo(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState_1_5(int32_t serial) {
+    mRealService->getVoiceRegistrationState_1_5(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState_1_5(int32_t serial) {
+    mRealService->getDataRegistrationState_1_5(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeManual_1_5(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric, ::android::hardware::radio::V1_5::RadioAccessNetworks ran) {
+    mRealService->setNetworkSelectionModeManual_1_5(serial, operatorNumeric, ran);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSmsExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSmsExpectMore(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplySimDepersonalization(int32_t serial, ::android::hardware::radio::V1_5::PersoSubstate persoType, const ::android::hardware::hidl_string& controlKey) {
+    mRealService->supplySimDepersonalization(serial, persoType, controlKey);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall) {
+    mRealService->setRadioPower_1_6(serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataCallList_1_6(int32_t serial) {
+    mRealService->getDataCallList_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_6(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses, int32_t pduSessionId, const ::android::hardware::radio::V1_6::OptionalSliceInfo& sliceInfo, const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& trafficDescriptor, bool matchAllRuleAllowed) {
+    mRealService->setupDataCall_1_6(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses, pduSessionId, sliceInfo, trafficDescriptor, matchAllRuleAllowed);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSms_1_6(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSmsExpectMore_1_6(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSms_1_6(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSmsExpectMore_1_6(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower_1_6(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp) {
+    mRealService->setSimCardPower_1_6(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNrDualConnectivityState(int32_t serial, ::android::hardware::radio::V1_6::NrDualConnectivityState nrDualConnectivityState) {
+    mRealService->setNrDualConnectivityState(serial, nrDualConnectivityState);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::isNrDualConnectivityEnabled(int32_t serial) {
+    mRealService->isNrDualConnectivityEnabled(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::allocatePduSessionId(int32_t serial) {
+    mRealService->allocatePduSessionId(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::releasePduSessionId(int32_t serial, int32_t id) {
+    mRealService->releasePduSessionId(serial, id);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startHandover(int32_t serial, int32_t callId) {
+    mRealService->startHandover(serial, callId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::cancelHandover(int32_t serial, int32_t callId) {
+    mRealService->cancelHandover(serial, callId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedNetworkTypesBitmap(uint32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    mRealService->setAllowedNetworkTypesBitmap(serial, networkTypeBitmap);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedNetworkTypesBitmap(int32_t serial) {
+    mRealService->getAllowedNetworkTypesBitmap(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataThrottling(int32_t serial, ::android::hardware::radio::V1_6::DataThrottlingAction dataThrottlingAction, int64_t completionDurationMillis) {
+    mRealService->setDataThrottling(serial, dataThrottlingAction, completionDurationMillis);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::emergencyDial_1_6(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting) {
+    mRealService->emergencyDial_1_6(serial, dialInfo, categories, urns, routing, hasKnownUserIntentEmergency, isTesting);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSystemSelectionChannels(int32_t serial) {
+    mRealService->getSystemSelectionChannels(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCellInfoList_1_6(int32_t serial) {
+    mRealService->getCellInfoList_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState_1_6(int32_t serial) {
+    mRealService->getVoiceRegistrationState_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength_1_6(int32_t serial) {
+    mRealService->getSignalStrength_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState_1_6(int32_t serial) {
+    mRealService->getDataRegistrationState_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCurrentCalls_1_6(int32_t serial) {
+    mRealService->getCurrentCalls_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSlicingConfig(int32_t serial) {
+    mRealService->getSlicingConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCarrierInfoForImsiEncryption_1_6(int32_t serial, const ::android::hardware::radio::V1_6::ImsiEncryptionInfo& imsiEncryptionInfo) {
+    mRealService->setCarrierInfoForImsiEncryption_1_6(serial, imsiEncryptionInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSimPhonebookRecords(int32_t serial) {
+    mRealService->getSimPhonebookRecords(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSimPhonebookCapacity(int32_t serial) {
+    mRealService->getSimPhonebookCapacity(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::updateSimPhonebookRecords(int32_t serial, const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo) {
+    mRealService->updateSimPhonebookRecords(serial, recordInfo);
+    return Void();
+}
+
+
+Return<void> RadioImpl_1_6_Proxy::interfaceChain(interfaceChain_cb _hidl_cb) {
+    mRealService->interfaceChain(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::debug(const ::android::hardware::hidl_handle& fd, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& options) {
+    mRealService->debug(fd, options);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::interfaceDescriptor(interfaceDescriptor_cb _hidl_cb) {
+    mRealService->interfaceDescriptor(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getHashChain(getHashChain_cb _hidl_cb) {
+    mRealService->getHashChain(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setHALInstrumentation() {
+    mRealService->setHALInstrumentation();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::ping() {
+    mRealService->ping();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDebugInfo(getDebugInfo_cb _hidl_cb) {
+    mRealService->getDebugInfo(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::notifySyspropsChanged() {
+    mRealService->notifySyspropsChanged();
+    return Void();
+}
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h
new file mode 100755
index 0000000000..964e2c8ec2
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h
@@ -0,0 +1,482 @@
+#pragma once
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include <memory>
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/types.h>
+#include <utils/SystemClock.h>
+#include <inttypes.h>
+#include "proxy_common.h"
+#include "RadioIndication_V1_6_Proxy.h"
+#include "RadioResponse_V1_6_Proxy.h"
+
+
+// revisit the header files and using primitive
+using namespace android::hardware::radio;
+using namespace android::hardware::radio::V1_0;
+using namespace android::hardware::radio::V1_1;
+using namespace android::hardware::radio::V1_2;
+using namespace android::hardware::radio::V1_3;
+using namespace android::hardware::radio::V1_4;
+using namespace android::hardware::radio::V1_5;
+using namespace android::hardware::radio::V1_6;
+//using namespace android::hardware::radio::deprecated::V1_0;
+using ::android::hardware::Return;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_bitfield;
+using ::android::hardware::Void;
+using ::android::hardware::hidl_death_recipient;
+
+//using android::requestToString;
+using android::sp;
+
+class RadioImpl_1_6_Proxy : public ::android::hardware::radio::V1_6::IRadio, public ::android::hardware::hidl_death_recipient {
+    sp<RadioResponse_v1_6_Proxy> mRadioResponseV1_6;
+    sp<RadioIndication_v1_6_Proxy> mRadioIndicationV1_6;
+    sp<::android::hardware::radio::V1_6::IRadio> mRealService;
+    int32_t mInstance;
+
+public:
+    RadioImpl_1_6_Proxy(int32_t instance, sp<::android::hardware::radio::V1_6::IRadio> realService) {
+        mInstance = instance;
+        mRealService = realService;
+
+        mRadioResponseV1_6 = new (std::nothrow) RadioResponse_v1_6_Proxy();
+
+        mRadioIndicationV1_6 = new (std::nothrow) RadioIndication_v1_6_Proxy();
+
+        mRealService->setResponseFunctions(mRadioResponseV1_6, mRadioIndicationV1_6);
+
+    }
+
+    virtual ::android::status_t registerAsService(const std::string &serviceName);
+
+    virtual const char *getDescriptor() {
+        return ::android::hardware::radio::V1_6::IRadio::descriptor;
+    }
+
+    void serviceDied(uint64_t,
+            const ::android::wp<::android::hidl::base::V1_0::IBase>&);
+
+    Return<void> setResponseFunctions(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& radioResponse, const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& radioIndication);
+
+    Return<void> getIccCardStatus(int32_t serial);
+
+    Return<void> supplyIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPukForApp(int32_t serial, const ::android::hardware::hidl_string& puk, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPuk2ForApp(int32_t serial, const ::android::hardware::hidl_string& puk2, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> changeIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin, const ::android::hardware::hidl_string& newPin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> changeIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin2, const ::android::hardware::hidl_string& newPin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyNetworkDepersonalization(int32_t serial, const ::android::hardware::hidl_string& netPin);
+
+    Return<void> getCurrentCalls(int32_t serial);
+
+    Return<void> dial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo);
+
+    Return<void> getImsiForApp(int32_t serial, const ::android::hardware::hidl_string& aid);
+
+    Return<void> hangup(int32_t serial, int32_t gsmIndex);
+
+    Return<void> hangupWaitingOrBackground(int32_t serial);
+
+    Return<void> hangupForegroundResumeBackground(int32_t serial);
+
+    Return<void> switchWaitingOrHoldingAndActive(int32_t serial);
+
+    Return<void> conference(int32_t serial);
+
+    Return<void> rejectCall(int32_t serial);
+
+    Return<void> getLastCallFailCause(int32_t serial);
+
+    Return<void> getSignalStrength(int32_t serial);
+
+    Return<void> getVoiceRegistrationState(int32_t serial);
+
+    Return<void> getDataRegistrationState(int32_t serial);
+
+    Return<void> getOperator(int32_t serial);
+
+    Return<void> setRadioPower(int32_t serial, bool on);
+
+    Return<void> sendDtmf(int32_t serial, const ::android::hardware::hidl_string& s);
+
+    Return<void> sendSms(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendSMSExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> setupDataCall(int32_t serial, ::android::hardware::radio::V1_0::RadioTechnology radioTechnology, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming);
+
+    Return<void> iccIOForApp(int32_t serial, const ::android::hardware::radio::V1_0::IccIo& iccIo);
+
+    Return<void> sendUssd(int32_t serial, const ::android::hardware::hidl_string& ussd);
+
+    Return<void> cancelPendingUssd(int32_t serial);
+
+    Return<void> getClir(int32_t serial);
+
+    Return<void> setClir(int32_t serial, int32_t status);
+
+    Return<void> getCallForwardStatus(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo);
+
+    Return<void> setCallForward(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo);
+
+    Return<void> getCallWaiting(int32_t serial, int32_t serviceClass);
+
+    Return<void> setCallWaiting(int32_t serial, bool enable, int32_t serviceClass);
+
+    Return<void> acknowledgeLastIncomingGsmSms(int32_t serial, bool success, ::android::hardware::radio::V1_0::SmsAcknowledgeFailCause cause);
+
+    Return<void> acceptCall(int32_t serial);
+
+    Return<void> deactivateDataCall(int32_t serial, int32_t cid, bool reasonRadioShutDown);
+
+    Return<void> getFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId);
+
+    Return<void> setFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, bool lockState, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId);
+
+    Return<void> setBarringPassword(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& oldPassword, const ::android::hardware::hidl_string& newPassword);
+
+    Return<void> getNetworkSelectionMode(int32_t serial);
+
+    Return<void> setNetworkSelectionModeAutomatic(int32_t serial);
+
+    Return<void> setNetworkSelectionModeManual(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric);
+
+    Return<void> getAvailableNetworks(int32_t serial);
+
+    Return<void> startDtmf(int32_t serial, const ::android::hardware::hidl_string& s);
+
+    Return<void> stopDtmf(int32_t serial);
+
+    Return<void> getBasebandVersion(int32_t serial);
+
+    Return<void> separateConnection(int32_t serial, int32_t gsmIndex);
+
+    Return<void> setMute(int32_t serial, bool enable);
+
+    Return<void> getMute(int32_t serial);
+
+    Return<void> getClip(int32_t serial);
+
+    Return<void> getDataCallList(int32_t serial);
+
+    Return<void> setSuppServiceNotifications(int32_t serial, bool enable);
+
+    Return<void> writeSmsToSim(int32_t serial, const ::android::hardware::radio::V1_0::SmsWriteArgs& smsWriteArgs);
+
+    Return<void> deleteSmsOnSim(int32_t serial, int32_t index);
+
+    Return<void> setBandMode(int32_t serial, ::android::hardware::radio::V1_0::RadioBandMode mode);
+
+    Return<void> getAvailableBandModes(int32_t serial);
+
+    Return<void> sendEnvelope(int32_t serial, const ::android::hardware::hidl_string& command);
+
+    Return<void> sendTerminalResponseToSim(int32_t serial, const ::android::hardware::hidl_string& commandResponse);
+
+    Return<void> handleStkCallSetupRequestFromSim(int32_t serial, bool accept);
+
+    Return<void> explicitCallTransfer(int32_t serial);
+
+    Return<void> setPreferredNetworkType(int32_t serial, ::android::hardware::radio::V1_0::PreferredNetworkType nwType);
+
+    Return<void> getPreferredNetworkType(int32_t serial);
+
+    Return<void> getNeighboringCids(int32_t serial);
+
+    Return<void> setLocationUpdates(int32_t serial, bool enable);
+
+    Return<void> setCdmaSubscriptionSource(int32_t serial, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSub);
+
+    Return<void> setCdmaRoamingPreference(int32_t serial, ::android::hardware::radio::V1_0::CdmaRoamingType type);
+
+    Return<void> getCdmaRoamingPreference(int32_t serial);
+
+    Return<void> setTTYMode(int32_t serial, ::android::hardware::radio::V1_0::TtyMode mode);
+
+    Return<void> getTTYMode(int32_t serial);
+
+    Return<void> setPreferredVoicePrivacy(int32_t serial, bool enable);
+
+    Return<void> getPreferredVoicePrivacy(int32_t serial);
+
+    Return<void> sendCDMAFeatureCode(int32_t serial, const ::android::hardware::hidl_string& featureCode);
+
+    Return<void> sendBurstDtmf(int32_t serial, const ::android::hardware::hidl_string& dtmf, int32_t on, int32_t off);
+
+    Return<void> sendCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> acknowledgeLastIncomingCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsAck& smsAck);
+
+    Return<void> getGsmBroadcastConfig(int32_t serial);
+
+    Return<void> setGsmBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configInfo);
+
+    Return<void> setGsmBroadcastActivation(int32_t serial, bool activate);
+
+    Return<void> getCdmaBroadcastConfig(int32_t serial);
+
+    Return<void> setCdmaBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configInfo);
+
+    Return<void> setCdmaBroadcastActivation(int32_t serial, bool activate);
+
+    Return<void> getCDMASubscription(int32_t serial);
+
+    Return<void> writeSmsToRuim(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsWriteArgs& cdmaSms);
+
+    Return<void> deleteSmsOnRuim(int32_t serial, int32_t index);
+
+    Return<void> getDeviceIdentity(int32_t serial);
+
+    Return<void> exitEmergencyCallbackMode(int32_t serial);
+
+    Return<void> getSmscAddress(int32_t serial);
+
+    Return<void> setSmscAddress(int32_t serial, const ::android::hardware::hidl_string& smsc);
+
+    Return<void> reportSmsMemoryStatus(int32_t serial, bool available);
+
+    Return<void> reportStkServiceIsRunning(int32_t serial);
+
+    Return<void> getCdmaSubscriptionSource(int32_t serial);
+
+    Return<void> requestIsimAuthentication(int32_t serial, const ::android::hardware::hidl_string& challenge);
+
+    Return<void> acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success, const ::android::hardware::hidl_string& ackPdu);
+
+    Return<void> sendEnvelopeWithStatus(int32_t serial, const ::android::hardware::hidl_string& contents);
+
+    Return<void> getVoiceRadioTechnology(int32_t serial);
+
+    Return<void> getCellInfoList(int32_t serial);
+
+    Return<void> setCellInfoListRate(int32_t serial, int32_t rate);
+
+    Return<void> setInitialAttachApn(int32_t serial, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool isRoaming);
+
+    Return<void> getImsRegistrationState(int32_t serial);
+
+    Return<void> sendImsSms(int32_t serial, const ::android::hardware::radio::V1_0::ImsSmsMessage& message);
+
+    Return<void> iccTransmitApduBasicChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message);
+
+    Return<void> iccOpenLogicalChannel(int32_t serial, const ::android::hardware::hidl_string& aid, int32_t p2);
+
+    Return<void> iccCloseLogicalChannel(int32_t serial, int32_t channelId);
+
+    Return<void> iccTransmitApduLogicalChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message);
+
+    Return<void> nvReadItem(int32_t serial, ::android::hardware::radio::V1_0::NvItem itemId);
+
+    Return<void> nvWriteItem(int32_t serial, const ::android::hardware::radio::V1_0::NvWriteItem& item);
+
+    Return<void> nvWriteCdmaPrl(int32_t serial, const ::android::hardware::hidl_vec<uint8_t>& prl);
+
+    Return<void> nvResetConfig(int32_t serial, ::android::hardware::radio::V1_0::ResetNvType resetType);
+
+    Return<void> setUiccSubscription(int32_t serial, const ::android::hardware::radio::V1_0::SelectUiccSub& uiccSub);
+
+    Return<void> setDataAllowed(int32_t serial, bool allow);
+
+    Return<void> getHardwareConfig(int32_t serial);
+
+    Return<void> requestIccSimAuthentication(int32_t serial, int32_t authContext, const ::android::hardware::hidl_string& authData, const ::android::hardware::hidl_string& aid);
+
+    Return<void> setDataProfile(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::DataProfileInfo>& profiles, bool isRoaming);
+
+    Return<void> requestShutdown(int32_t serial);
+
+    Return<void> getRadioCapability(int32_t serial);
+
+    Return<void> setRadioCapability(int32_t serial, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> startLceService(int32_t serial, int32_t reportInterval, bool pullMode);
+
+    Return<void> stopLceService(int32_t serial);
+
+    Return<void> pullLceData(int32_t serial);
+
+    Return<void> getModemActivityInfo(int32_t serial);
+
+    Return<void> setAllowedCarriers(int32_t serial, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers);
+
+    Return<void> getAllowedCarriers(int32_t serial);
+
+    Return<void> sendDeviceState(int32_t serial, ::android::hardware::radio::V1_0::DeviceStateType deviceStateType, bool state);
+
+    Return<void> setIndicationFilter(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_0::IndicationFilter> indicationFilter);
+
+    Return<void> setSimCardPower(int32_t serial, bool powerUp);
+
+    Return<void> responseAcknowledgement();
+
+    Return<void> setCarrierInfoForImsiEncryption(int32_t serial, const ::android::hardware::radio::V1_1::ImsiEncryptionInfo& imsiEncryptionInfo);
+
+    Return<void> setSimCardPower_1_1(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp);
+
+    Return<void> startNetworkScan(int32_t serial, const ::android::hardware::radio::V1_1::NetworkScanRequest& request);
+
+    Return<void> stopNetworkScan(int32_t serial);
+
+    Return<void> startKeepalive(int32_t serial, const ::android::hardware::radio::V1_1::KeepaliveRequest& keepalive);
+
+    Return<void> stopKeepalive(int32_t serial, int32_t sessionHandle);
+
+    Return<void> startNetworkScan_1_2(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
+
+    Return<void> setIndicationFilter_1_2(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_2::IndicationFilter> indicationFilter);
+
+    Return<void> setSignalStrengthReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDb, const ::android::hardware::hidl_vec<int32_t>& thresholdsDbm, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
+
+    Return<void> setLinkCapacityReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
+
+    Return<void> setupDataCall_1_2(int32_t serial, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> deactivateDataCall_1_2(int32_t serial, int32_t cid, ::android::hardware::radio::V1_2::DataRequestReason reason);
+
+    Return<void> setSystemSelectionChannels(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& specifiers);
+
+    Return<void> enableModem(int32_t serial, bool on);
+
+    Return<void> getModemStackStatus(int32_t serial);
+
+    Return<void> setupDataCall_1_4(int32_t serial, ::android::hardware::radio::V1_4::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> setInitialAttachApn_1_4(int32_t serial, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo);
+
+    Return<void> setDataProfile_1_4(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& profiles);
+
+    Return<void> emergencyDial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting);
+
+    Return<void> startNetworkScan_1_4(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
+
+    Return<void> getPreferredNetworkTypeBitmap(int32_t serial);
+
+    Return<void> setPreferredNetworkTypeBitmap(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setAllowedCarriers_1_4(int32_t serial, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy);
+
+    Return<void> getAllowedCarriers_1_4(int32_t serial);
+
+    Return<void> getSignalStrength_1_4(int32_t serial);
+
+    Return<void> setSignalStrengthReportingCriteria_1_5(int32_t serial, const ::android::hardware::radio::V1_5::SignalThresholdInfo& signalThresholdInfo, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork);
+
+    Return<void> setLinkCapacityReportingCriteria_1_5(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork);
+
+    Return<void> enableUiccApplications(int32_t serial, bool enable);
+
+    Return<void> areUiccApplicationsEnabled(int32_t serial);
+
+    Return<void> setSystemSelectionChannels_1_5(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers);
+
+    Return<void> startNetworkScan_1_5(int32_t serial, const ::android::hardware::radio::V1_5::NetworkScanRequest& request);
+
+    Return<void> setupDataCall_1_5(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> setInitialAttachApn_1_5(int32_t serial, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo);
+
+    Return<void> setDataProfile_1_5(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& profiles);
+
+    Return<void> setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall);
+
+    Return<void> setIndicationFilter_1_5(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter);
+
+    Return<void> getBarringInfo(int32_t serial);
+
+    Return<void> getVoiceRegistrationState_1_5(int32_t serial);
+
+    Return<void> getDataRegistrationState_1_5(int32_t serial);
+
+    Return<void> setNetworkSelectionModeManual_1_5(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric, ::android::hardware::radio::V1_5::RadioAccessNetworks ran);
+
+    Return<void> sendCdmaSmsExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> supplySimDepersonalization(int32_t serial, ::android::hardware::radio::V1_5::PersoSubstate persoType, const ::android::hardware::hidl_string& controlKey);
+
+    Return<void> setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall);
+
+    Return<void> getDataCallList_1_6(int32_t serial);
+
+    Return<void> setupDataCall_1_6(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses, int32_t pduSessionId, const ::android::hardware::radio::V1_6::OptionalSliceInfo& sliceInfo, const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& trafficDescriptor, bool matchAllRuleAllowed);
+
+    Return<void> sendSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendCdmaSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> sendCdmaSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> setSimCardPower_1_6(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp);
+
+    Return<void> setNrDualConnectivityState(int32_t serial, ::android::hardware::radio::V1_6::NrDualConnectivityState nrDualConnectivityState);
+
+    Return<void> isNrDualConnectivityEnabled(int32_t serial);
+
+    Return<void> allocatePduSessionId(int32_t serial);
+
+    Return<void> releasePduSessionId(int32_t serial, int32_t id);
+
+    Return<void> startHandover(int32_t serial, int32_t callId);
+
+    Return<void> cancelHandover(int32_t serial, int32_t callId);
+
+    Return<void> setAllowedNetworkTypesBitmap(uint32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> getAllowedNetworkTypesBitmap(int32_t serial);
+
+    Return<void> setDataThrottling(int32_t serial, ::android::hardware::radio::V1_6::DataThrottlingAction dataThrottlingAction, int64_t completionDurationMillis);
+
+    Return<void> emergencyDial_1_6(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting);
+
+    Return<void> getSystemSelectionChannels(int32_t serial);
+
+    Return<void> getCellInfoList_1_6(int32_t serial);
+
+    Return<void> getVoiceRegistrationState_1_6(int32_t serial);
+
+    Return<void> getSignalStrength_1_6(int32_t serial);
+
+    Return<void> getDataRegistrationState_1_6(int32_t serial);
+
+    Return<void> getCurrentCalls_1_6(int32_t serial);
+
+    Return<void> getSlicingConfig(int32_t serial);
+
+    Return<void> setCarrierInfoForImsiEncryption_1_6(int32_t serial, const ::android::hardware::radio::V1_6::ImsiEncryptionInfo& imsiEncryptionInfo);
+
+    Return<void> getSimPhonebookRecords(int32_t serial);
+
+    Return<void> getSimPhonebookCapacity(int32_t serial);
+
+    Return<void> updateSimPhonebookRecords(int32_t serial, const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo);
+
+    Return<void> interfaceChain(interfaceChain_cb _hidl_cb);
+
+    Return<void> debug(const ::android::hardware::hidl_handle& fd, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& options);
+
+    Return<void> interfaceDescriptor(interfaceDescriptor_cb _hidl_cb);
+
+    Return<void> getHashChain(getHashChain_cb _hidl_cb);
+
+    Return<void> setHALInstrumentation();
+
+    Return<void> ping();
+
+    Return<void> getDebugInfo(getDebugInfo_cb _hidl_cb);
+
+    Return<void> notifySyspropsChanged();
+};
\ No newline at end of file
-- 
2.17.1

From 33095995fe737798c2986254b9153d96518f3c21 Mon Sep 17 00:00:00 2001
From: ngf <ngf@xdja.com>
Date: Sat, 27 Aug 2022 10:38:56 +0800
Subject: [PATCH 05/11] rm some redundancy files

---
 frameworks/base/0827.zip | Bin 15567 -> 0 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 frameworks/base/0827.zip

diff --git a/frameworks/base/0827.zip b/frameworks/base/0827.zip
deleted file mode 100644
index fabde2429a5186c113cdd7264806420e4cfb7f53..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 15567
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
SemIzaPLqF@r7!&N)BgoWDv#6v

-- 
2.17.1

From ab7433117bdbe40be92fe36695b8019ac83e7315 Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Sat, 27 Aug 2022 14:23:26 +0800
Subject: [PATCH 06/11] update Ril: kill phone

---
 .../native/services/surfaceflinger/SurfaceFlinger.cpp    | 2 +-
 .../java/com/android/internal/telephony/RILRequest.java  | 9 +++++----
 system/libhidl/transport/ServiceManagement.cpp           | 1 +
 .../systemswitch/secure/view/SecureSwitchActivity.java   | 1 +
 4 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index a3d0afa56e..156e770a1a 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -739,7 +739,7 @@ void SurfaceFlinger::bootFinished() {
     // stop boot animation
     // formerly we would just kill the process, but we now ask it to exit so it
     // can choose where to stop the animation.
-    property_set("service.bootanim.exit", "1");
+    //property_set("service.bootanim.exit", "1");
 
     const int LOGTAG_SF_STOP_BOOTANIM = 60110;
     LOG_EVENT_LONG(LOGTAG_SF_STOP_BOOTANIM,
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
index e261f87e57..544d19007d 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RILRequest.java
@@ -44,7 +44,7 @@ public class RILRequest {
     private static RILRequest sPool = null;
     private static int sPoolSize = 0;
     private static final int MAX_POOL_SIZE = 4;
-    private static final int MAX_SERIAL_NUM = Integer.MAX_VALUE >> 1; //BIT(31) mark as sysid
+    private static final int MAX_SERIAL_NUM = Integer.MAX_VALUE >> 2; //BIT(31) mark as sysid
     private static final String sCellName = SystemProperties.get("ro.boot.vm.name", "none");
     private static int mSysId = -1;
 
@@ -106,14 +106,15 @@ public class RILRequest {
             } else if ("cell2".equals(sCellName)) {
                 mSysId = 1;
             } else {
-                Rlog.e(LOG_TAG, "CellName " + sCellName + " Error!");
-                throw new NullPointerException("sCellName is " + sCellName);
+                //Rlog.e(LOG_TAG, "CellName " + sCellName + " Error!");
+                //throw new NullPointerException("sCellName is " + sCellName);
+                mSysId = 2;
             }
         }
 
         // Increment serial number. Wrap to 0 when reaching Integer.MAX_VALUE.
         rr.mSerial = sNextSerial.getAndUpdate(n -> ((n + 1) % MAX_SERIAL_NUM));
-        rr.mSerial |= (mSysId << 31);
+        rr.mSerial |= (mSysId << 30);
         rr.mRequest = request;
         rr.mResult = result;
 
diff --git a/system/libhidl/transport/ServiceManagement.cpp b/system/libhidl/transport/ServiceManagement.cpp
index 916ffc3850..14dcdebd30 100644
--- a/system/libhidl/transport/ServiceManagement.cpp
+++ b/system/libhidl/transport/ServiceManagement.cpp
@@ -91,6 +91,7 @@ static bool getinithidlservice(const char* descriptor)
         "android.hardware.secure_element",
         "android.frameworks.sensorservice",
         "vendor.samsung_slsi.telephony.hardware.radioExternal",
+        "android.hardware.radio",
         NULL
     };
 
diff --git a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
index cdfe90ac52..4bbef17bd5 100755
--- a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
+++ b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
@@ -42,6 +42,7 @@ public class SecureSwitchActivity extends Activity {
 			try{
 				disableAdapter();
 				mCellsService.switchCellsVm("host");
+				//mCellsService.switchCellsVm(name);
 			}catch(RuntimeException e){
 				e.printStackTrace();
 			}
-- 
2.17.1

From c8f6808acd8cf85fcbd5cc55ce7c725b55184b0b Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Tue, 30 Aug 2022 00:14:44 +0800
Subject: [PATCH 07/11]  mobile data network ok

---
 system/netd/server/NetdNativeService.cpp      |  56 +++-
 system/netd/server/NetdNativeService.h        |   4 +
 system/netd/server/virt_net_config.h          |   1 +
 vendor/cells/cells/Android.mk                 |   1 +
 vendor/cells/cells/celld.c                    |   5 +
 vendor/cells/cells/nsexec.c                   |   3 +
 vendor/cells/cells/virt_net_config.h          | 240 ++++++++++++++++++
 vendor/cells/cells/virtual_network.c          | 158 ++++++++++++
 vendor/cells/cells/virtual_network.h          |   8 +
 vendor/cells/cellsservice/Android.mk          |  13 +
 .../cellsservice/CellsPrivateService.cpp      |  46 ++++
 .../cells/cellsservice/CellsPrivateService.h  |   1 +
 .../cellsservice/ICellsPrivateService.cpp     |  29 +++
 .../cells/cellsservice/ICellsPrivateService.h |   2 +
 vendor/cells/cellsservice/cell_cfg_net.cpp    |  42 +++
 vendor/cells/cellsservice/virt_net_config.h   |   1 +
 16 files changed, 608 insertions(+), 2 deletions(-)
 create mode 120000 system/netd/server/virt_net_config.h
 create mode 100644 vendor/cells/cells/virt_net_config.h
 create mode 100644 vendor/cells/cells/virtual_network.c
 create mode 100644 vendor/cells/cells/virtual_network.h
 create mode 100755 vendor/cells/cellsservice/cell_cfg_net.cpp
 create mode 120000 vendor/cells/cellsservice/virt_net_config.h

diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
index 1f5dc97612..85359f5e4e 100644
--- a/system/netd/server/NetdNativeService.cpp
+++ b/system/netd/server/NetdNativeService.cpp
@@ -49,6 +49,7 @@
 #include "binder_utils/BinderUtil.h"
 #include "binder_utils/NetdPermissions.h"
 #include "netid_client.h"  // NETID_UNSET
+#include "virt_net_config.h"
 
 using android::base::StringPrintf;
 using android::base::WriteStringToFile;
@@ -170,6 +171,24 @@ bool contains(const Vector<String16>& words, const String16& word) {
 
 }  // namespace
 
+int NetdNativeService::CallHostNetworkAddRouteParcel(int sysId, const RouteInfoParcel& route) {
+    char cmd[MAX_CMD_LEN];
+
+    if (route.nextHop.empty()) {
+        snprintf(cmd, sizeof(cmd), "cell_cfg_net %d %s %s",
+            sysId, route.ifName.c_str(),
+            route.destination.c_str());
+    } else {
+        snprintf(cmd, sizeof(cmd), "cell_cfg_net %d %s %s %s",
+            sysId, route.ifName.c_str(),
+            route.destination.c_str(),
+            route.nextHop.c_str());
+    }
+
+    system(cmd);  // NOLINT(cert-env33-c)
+    return 0;
+}
+
 NetdNativeService::NetdNativeService() {
     // register log callback to BnNetd::logFunc
     BnNetd::logFunc = [](const auto& log) {
@@ -1025,17 +1044,50 @@ binder::Status NetdNativeService::tetherDnsList(std::vector<std::string>* dnsLis
     return binder::Status::ok();
 }
 
+static int get_sys_id()
+{
+    char prop_value[PROP_VALUE_MAX] = {0};
+    int sys_id = -1; //host
+
+    if (__system_property_get("ro.boot.vm.name", prop_value) > 0) {
+        if (0 == strncmp("cell1", prop_value, strlen("cell1"))) {
+            sys_id = 0;
+        } else if (0 == strncmp("cell2", prop_value, strlen("cell2"))) {
+            sys_id = 1;
+        }
+    }
+    return sys_id;
+}
+
 binder::Status NetdNativeService::networkAddRouteParcel(int32_t netId,
                                                         const RouteInfoParcel& route) {
     // Public methods of NetworkController are thread-safe.
     ENFORCE_NETWORK_STACK_PERMISSIONS();
     bool legacy = false;
     uid_t uid = 0;  // UID is only meaningful for legacy routes.
+    int sys_id = get_sys_id();
+    const char *gw = nullptr;
+    char cmd[MAX_CMD_LEN];
+
+    if (-1 != sys_id) {
+        //cells
+        //config vnet ip
+        snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",
+            route.ifName.c_str(),
+            get_vnet_ip(sys_id, route.ifName.c_str()),
+            get_vnet_mask(sys_id, route.ifName.c_str()));
+        system(cmd);  // NOLINT(cert-env33-c)
+        //config host route
+        CallHostNetworkAddRouteParcel(sys_id, route);
+        //map gw
+        gw = get_vnet_gw(sys_id, route.ifName.c_str());
+    } else {
+        gw = route.nextHop.empty() ? nullptr : route.nextHop.c_str();
+    }
 
     // convert Parcel to parameters
     int res = gCtls->netCtrl.addRoute(netId, route.ifName.c_str(), route.destination.c_str(),
-                                      route.nextHop.empty() ? nullptr : route.nextHop.c_str(),
-                                      legacy, uid, route.mtu);
+                                      gw, legacy, uid, route.mtu);
     return statusFromErrcode(res);
 }
 
diff --git a/system/netd/server/NetdNativeService.h b/system/netd/server/NetdNativeService.h
index 9779f3680a..43eb842e87 100644
--- a/system/netd/server/NetdNativeService.h
+++ b/system/netd/server/NetdNativeService.h
@@ -24,6 +24,8 @@
 
 #include "android/net/BnNetd.h"
 
+#define NETD_SERVICE
+
 namespace android {
 namespace net {
 
@@ -80,6 +82,8 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
             const netd::aidl::NativeUidRangeConfig& uidRangesConfig) override;
     binder::Status networkRejectNonSecureVpn(bool enable,
                                              const std::vector<UidRangeParcel>& uids) override;
+    //op: 0--add 1--update 2--remove
+    int CallHostNetworkAddRouteParcel(int sysid, const RouteInfoParcel& route);
     binder::Status networkAddRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
     binder::Status networkUpdateRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
     binder::Status networkRemoveRouteParcel(int32_t netId, const RouteInfoParcel& route) override;
diff --git a/system/netd/server/virt_net_config.h b/system/netd/server/virt_net_config.h
new file mode 120000
index 0000000000..c17fbce5ad
--- /dev/null
+++ b/system/netd/server/virt_net_config.h
@@ -0,0 +1 @@
+../../../vendor/cells/cells/virt_net_config.h
\ No newline at end of file
diff --git a/vendor/cells/cells/Android.mk b/vendor/cells/cells/Android.mk
index 93321f0c88..49596da697 100755
--- a/vendor/cells/cells/Android.mk
+++ b/vendor/cells/cells/Android.mk
@@ -42,6 +42,7 @@ LOCAL_SRC_FILES:= \
 	network.c \
 	cellnet.c \
 	array.c \
+	virtual_network.c
 
 LOCAL_MODULE := celld
 LOCAL_MODULE_TAGS := optional
diff --git a/vendor/cells/cells/celld.c b/vendor/cells/cells/celld.c
index 4fe4eac858..588c0cee89 100755
--- a/vendor/cells/cells/celld.c
+++ b/vendor/cells/cells/celld.c
@@ -62,6 +62,8 @@
 #include "nsexec.h"
 #include "util.h"
 
+#include "virtual_network.h"
+
 #define CELLS_MAX_CONTEXT 6
 
 static void set_properties_cells(char *name,char* v)
@@ -2684,6 +2686,9 @@ static void celld_main(void)
 	socklen_t addr_len;
 	pthread_t tid;
 
+	//gwb add for host vnet init
+	onHostStart();
+
 	sd = socket(AF_UNIX, SOCK_STREAM, 0);
 	if (sd == -1) {
 		ALOGE("socket() failed: %s", strerror(errno));
diff --git a/vendor/cells/cells/nsexec.c b/vendor/cells/cells/nsexec.c
index 83f6b41ce7..ffb6ffc6e4 100755
--- a/vendor/cells/cells/nsexec.c
+++ b/vendor/cells/cells/nsexec.c
@@ -54,6 +54,7 @@
 #include "util.h"
 #include "network.h"
 #include "cellnet.h"
+#include "virtual_network.h"
 
 #ifndef MNT_DETACH
 #define MNT_DETACH 2
@@ -645,6 +646,8 @@ static int do_clone(struct cell_args *cell_args)
 	if (gettimeofday(&cell_args->start_time, NULL) == -1)
 		ALOGE("%s: gettimeofday failed: %s", __func__, strerror(errno));
 
+	//gwb add for virt net
+	onVsysStart(cell_args->cellname, pid);
 	/*
 	 * Put the new process in a cgroup if requested.
 	 * Note that the child will block until we release it with a write
diff --git a/vendor/cells/cells/virt_net_config.h b/vendor/cells/cells/virt_net_config.h
new file mode 100644
index 0000000000..01785566ca
--- /dev/null
+++ b/vendor/cells/cells/virt_net_config.h
@@ -0,0 +1,240 @@
+#ifndef _VIRT_NET_CONFIG_H_
+#define _VIRT_NET_CONFIG_H_
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+/***********************************虚拟网络相关定义*******************************/
+
+#define MAX_SYS_NUM 2
+#define MAX_VETH_NAME_LEN (30)
+#define MAX_PATH_LEN (256)
+#define MAX_CMD_LEN (256)
+#define BIT(n)  (1 << (n))
+
+#define NET_RICH_ENABLE   BIT(0)
+#define NET_SAFE_ENABLE   BIT(1)
+#define NET_BOTH_ENABLE (NET_RICH_ENABLE | NET_SAFE_ENABLE)
+
+#define VNET_FWMARK_BASE    0xFF001
+#define VNET_HOST_RT_BASE     6001
+#define VNET_RT_BASE     5001
+#define VNET_RT_RULE_PRIO_BASE 5001
+
+#define VETH_TMP_SUFFIX "_tmp"
+
+typedef unsigned int uint32_t;
+typedef int int32_t;
+
+typedef struct _vsys_net_t {
+    const char *virt_name;
+    const char *host_ip;
+    const char *local_ip;
+    const char *mask;
+    uint32_t fwmark;
+    int32_t rt_id;
+    uint32_t rl_prio;
+} vsys_net_t;
+
+typedef struct _virtual_net_t {
+    const char *ifname;
+    uint32_t flag; //标识网络有效域：NET_RICH_ENABLE、NET_SAFE_ENABLE
+    int32_t host_rt;
+    vsys_net_t vnet_info[MAX_SYS_NUM];
+} virtual_net_t;
+
+#define DEFINE_VSYS_NET(vname, hip, lip, mask, idx) {(vname), (hip), (lip), mask, VNET_FWMARK_BASE+(idx), VNET_RT_BASE+(idx), VNET_RT_RULE_PRIO_BASE+(idx)}
+
+
+#define DEFINE_VIRTUAL_NET(ifname, flag, host_rt, vsys1, vsys2) \
+    {(ifname), (flag), (host_rt + VNET_HOST_RT_BASE), {vsys1, vsys2}}
+
+/********************************************************************************************************/
+
+//后续考虑采用配置文件的形式，方便移植和业务隐藏
+static virtual_net_t g_virt_net[] = {
+    DEFINE_VIRTUAL_NET("rmnet0", NET_BOTH_ENABLE, 0, 
+        DEFINE_VSYS_NET("rmnet0_v1", "172.20.202.5", "172.20.202.6",  "255.255.255.252", 0),
+        DEFINE_VSYS_NET("rmnet0_v2", "172.20.202.9", "172.20.202.10", "255.255.255.252", 1)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet1", NET_BOTH_ENABLE, 1,
+        DEFINE_VSYS_NET("rmnet1_v1", "172.20.202.13", "172.20.202.14", "255.255.255.252", 2),
+        DEFINE_VSYS_NET("rmnet1_v2", "172.20.202.17", "172.20.202.18", "255.255.255.252", 3)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet2", NET_BOTH_ENABLE, 2,
+        DEFINE_VSYS_NET("rmnet2_v1", "172.20.202.21", "172.20.202.22", "255.255.255.252", 4),
+        DEFINE_VSYS_NET("rmnet2_v2", "172.20.202.25", "172.20.202.26", "255.255.255.252", 5)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet3", NET_BOTH_ENABLE, 3,
+        DEFINE_VSYS_NET("rmnet3_v1", "172.20.202.29", "172.20.202.30", "255.255.255.252", 6),
+        DEFINE_VSYS_NET("rmnet3_v2", "172.20.202.33", "172.20.202.34", "255.255.255.252", 7)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet4", NET_BOTH_ENABLE, 4,
+        DEFINE_VSYS_NET("rmnet4_v1", "172.20.202.37", "172.20.202.38", "255.255.255.252", 8),
+        DEFINE_VSYS_NET("rmnet4_v2", "172.20.202.41", "172.20.202.42", "255.255.255.252", 9)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet5", NET_BOTH_ENABLE, 5,
+        DEFINE_VSYS_NET("rmnet5_v1", "172.20.202.45", "172.20.202.46", "255.255.255.252", 10),
+        DEFINE_VSYS_NET("rmnet5_v2", "172.20.202.49", "172.20.202.50", "255.255.255.252", 11)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet6", NET_BOTH_ENABLE, 6,
+        DEFINE_VSYS_NET("rmnet6_v1", "172.20.202.53", "172.20.202.54", "255.255.255.252", 12),
+        DEFINE_VSYS_NET("rmnet6_v2", "172.20.202.57", "172.20.202.58", "255.255.255.252", 13)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet7", NET_BOTH_ENABLE, 7,
+        DEFINE_VSYS_NET("rmnet7_v1", "172.20.202.61", "172.20.202.62", "255.255.255.252", 14),
+        DEFINE_VSYS_NET("rmnet7_v2", "172.20.202.65", "172.20.202.66", "255.255.255.252", 15)
+    ),
+    DEFINE_VIRTUAL_NET("rmnet8", NET_BOTH_ENABLE, 8,
+        DEFINE_VSYS_NET("rmnet8_v1", "172.20.202.69", "172.20.202.70", "255.255.255.252", 16),
+        DEFINE_VSYS_NET("rmnet8_v2", "172.20.202.73", "172.20.202.74", "255.255.255.252", 17)
+    ),
+    DEFINE_VIRTUAL_NET(NULL, NET_BOTH_ENABLE, -1,
+        DEFINE_VSYS_NET(NULL, NULL, NULL, NULL, 0),
+        DEFINE_VSYS_NET(NULL, NULL, NULL, NULL, 0)
+    ),
+};
+
+static virtual_net_t *get_vnet(const char *ifname)
+{
+    virtual_net_t *vnet = NULL;
+
+    if (NULL == ifname) {
+        return NULL;
+    }
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        if (0 == strcmp(ifname, vnet->ifname)) {
+            return vnet;
+        }
+    }
+
+    return NULL;
+}
+
+static vsys_net_t *get_vnet_info(int sys, const char *ifname)
+{
+    virtual_net_t *vnet = NULL;
+
+    if (sys < 0 || sys >= MAX_SYS_NUM || NULL == ifname) {
+        return NULL;
+    }
+
+    vnet = get_vnet(ifname);
+    if (NULL == vnet) {
+        return NULL;
+    }
+
+    return &vnet->vnet_info[sys];
+}
+
+static const char *get_vnet_ip(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->local_ip;
+    }
+
+    return NULL;
+}
+
+#if 0
+static inline void ip_mask_to_segment(const char *ip, int mask, char *segment)
+{
+    int ip_int = 0;
+    unsigned char *p = (unsigned char *)&ip_int;
+	inet_pton(AF_INET, ip, &ip_int);
+    p[3] = p[3] - 1;
+    sprintf(segment, "%d.%d.%d.%d/%d", p[0], p[1], p[2], p[3], mask);
+}
+
+//返回类似172.20.202.4/30网段地址---不需要，虚拟系统添加main表路由后也可自动获取
+static int get_vnet_segment(int sys, const char *ifname, char *segment)
+{
+
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL == p) {
+        return -1;
+    }
+
+    ip_mask_to_segment(p->host_ip, 30, segment);
+
+
+    return 0;
+}
+#endif
+
+static const char *get_vnet_mask(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->mask;
+    }
+
+    return NULL;
+}
+
+static const char *get_vnet_gw(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return p->host_ip;
+    }
+
+    return NULL;
+}
+
+
+
+#ifndef NETD_SERVICE
+static int32_t get_vnet_rt_table(int sys, const char *ifname)
+{
+    vsys_net_t *p = get_vnet_info(sys, ifname);
+    if (NULL != p) {
+        return (int32_t)p->rt_id;
+    }
+
+    return -1;
+}
+
+static int32_t get_vnet_netid(int sys, const char *ifname)
+{
+    return get_vnet_rt_table(sys, ifname);
+}
+
+static virtual_net_t *get_vnet_info_by_netid(int net_id, int *sysId)
+{
+    virtual_net_t *vnet = NULL;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        if (net_id == vnet->vnet_info[0].rt_id) {
+            *sysId = 0;
+            return vnet;
+        }
+
+        if (net_id == vnet->vnet_info[1].rt_id) {
+            *sysId = 1;
+            return vnet;
+        }
+    }
+
+    return NULL;
+}
+
+
+static int32_t get_host_rt_table(const char *ifname)
+{
+    virtual_net_t *p = get_vnet(ifname);
+    if (NULL != p) {
+        return p->host_rt;
+    }
+
+    return -1;
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/vendor/cells/cells/virtual_network.c b/vendor/cells/cells/virtual_network.c
new file mode 100644
index 0000000000..608311df9e
--- /dev/null
+++ b/vendor/cells/cells/virtual_network.c
@@ -0,0 +1,158 @@
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include "network.h"
+#include "virt_net_config.h"
+#include "virtual_network.h"
+
+#define LOG_TAG "VIRTNET"
+#include <cutils/log.h>
+
+#define VNET_ERR ALOGE
+
+static int create_vnet(virtual_net_t *vnet, int sys)
+{
+    int ret = 0;
+
+    if (NULL == vnet || sys >= MAX_SYS_NUM) {
+        return -1;
+    }
+
+    const char *name1 = vnet->vnet_info[sys].virt_name;
+    char name2[MAX_VETH_NAME_LEN];
+
+    if (sizeof(name2) <= snprintf(name2, sizeof(name2), "%s%s", name1, VETH_TMP_SUFFIX)) {
+        VNET_ERR("[create_vnet] name=%s is out of bonds!\n", name1);
+        ret |= (1 << sys);
+    }
+
+    if (0 != veth_peer_create(name1, name2)) {
+        VNET_ERR("[create_vnet] veth_peer_create(%s, %s) Fail!\n", name1, name2);
+        ret |= (2 << sys);
+    } 
+
+    return ret;
+}
+
+int create_vnet_all(int sys)
+{
+    int ret = 0;
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        ret |= create_vnet(&g_virt_net[i], sys);
+    }
+    return ret;
+}
+
+int config_vnet_host_all(int sys)
+{
+    int ret = 0;
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = NULL;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        //配置IP
+        snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up", 
+            vnet->vnet_info[sys].virt_name,
+            vnet->vnet_info[sys].host_ip,
+            vnet->vnet_info[sys].mask);
+        system(cmd);
+    }
+    return ret;
+}
+
+int move_vnet_all(int sys, pid_t pid)
+{
+    const char *name1 = NULL;
+    char *name2[MAX_VETH_NAME_LEN];
+    virtual_net_t *vnet = NULL;
+    int ret = 0;
+
+    for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+        vnet = &g_virt_net[i];
+        name1 = vnet->vnet_info[sys].virt_name;
+        if (sizeof(name2) <= snprintf((char *)name2, sizeof(name2), "%s%s", name1, VETH_TMP_SUFFIX)) {
+            VNET_ERR("[create_vnet] name=%s is out of bonds!\n", name1);
+            ret |= (1 << sys);
+        }
+
+        ret |= netdev_move_to_netns((const char*)&name2, pid, vnet->ifname);
+    }
+    return ret;
+}
+
+int onHostStart()
+{
+    int ret = 0;
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = NULL;
+
+
+    system("iptables -t raw -F");
+    system("iptables -t mangle -F");
+    system("iptables -t filter -F");
+    system("iptables -t nat -F");
+
+    //AOSP上缺少main表规则
+    snprintf(cmd, sizeof(cmd), "ip rule add from all lookup main prio 31999");
+    system(cmd);
+
+    //静态配置，只需在host启动时执行一次即可-->后续可作为oneshot服务，在rc中启动一次即可
+    for (int sys = 0; sys < MAX_SYS_NUM; sys++) {
+        for (int i = 0; NULL != g_virt_net[i].ifname; i++) {
+            vnet = &g_virt_net[i];
+            //配置FWMARK
+            snprintf(cmd, sizeof(cmd), "iptables -t mangle -I PREROUTING -s %s/30 -j MARK --set-mark 0x%x", 
+                vnet->vnet_info[sys].host_ip,
+                vnet->vnet_info[sys].fwmark);
+            system(cmd);
+            //配置MASQUERADE
+            snprintf(cmd, sizeof(cmd), "iptables -t nat -I POSTROUTING -m mark --mark 0x%x -o %s -j MASQUERADE", 
+                vnet->vnet_info[sys].fwmark,
+                vnet->ifname);
+            system(cmd);
+            //配置rule
+  
+            if (0 == sys) {
+                snprintf(cmd, sizeof(cmd), "ip rule add from all iif lo oif %s lookup %d prio %d", 
+                        vnet->ifname,
+                        vnet->host_rt,
+                        vnet->vnet_info[sys].rl_prio);
+                system(cmd);
+            }
+
+            snprintf(cmd, sizeof(cmd), "ip rule add iif %s table %d prio %d", 
+                vnet->vnet_info[sys].virt_name,
+                vnet->vnet_info[sys].rt_id,
+                vnet->vnet_info[sys].rl_prio);
+            system(cmd);
+        }
+    }
+
+    return ret;
+}
+
+int onVsysStart(const char *sysname, pid_t pid)
+{
+    int ret = 0;
+    int sys = 0;
+
+    sscanf(sysname, "cell%d", &sys);
+
+    if (sys > MAX_SYS_NUM || sys < 1) {
+        VNET_ERR("[onVsysStart] sysname=%s is invalide!\n", sysname);
+    }
+    sys -= 1;
+
+    ret = create_vnet_all(sys);
+    ret |= config_vnet_host_all(sys);
+    ret |= move_vnet_all(sys, pid);
+
+    return ret;
+}
+
+
diff --git a/vendor/cells/cells/virtual_network.h b/vendor/cells/cells/virtual_network.h
new file mode 100644
index 0000000000..12584bc39f
--- /dev/null
+++ b/vendor/cells/cells/virtual_network.h
@@ -0,0 +1,8 @@
+
+#ifndef _VIRTUAL_NETWORK_H_
+#define _VIRTUAL_NETWORK_H_
+
+extern int onVsysStart(const char *sysname, pid_t pid);
+extern int onHostStart();
+
+#endif
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/Android.mk b/vendor/cells/cellsservice/Android.mk
index 58fa006bc8..ae4b73406c 100755
--- a/vendor/cells/cellsservice/Android.mk
+++ b/vendor/cells/cellsservice/Android.mk
@@ -66,3 +66,16 @@ LOCAL_SHARED_LIBRARIES := libm libcutils libc libutils liblog
 include $(BUILD_EXECUTABLE)
 
 
+#cfg net
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	cell_cfg_net.cpp \
+	ICellsPrivateService.cpp
+
+LOCAL_MODULE:= cell_cfg_net
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := cells
+#LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
+LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils liblog
+include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/CellsPrivateService.cpp b/vendor/cells/cellsservice/CellsPrivateService.cpp
index 60a664df9b..6b25664673 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/CellsPrivateService.cpp
@@ -20,6 +20,7 @@
 
 #include <android/os/IPowerManager.h>
 #include <powermanager/PowerManager.h>
+#include "virt_net_config.h"
 
 namespace android {
 
@@ -431,6 +432,51 @@ status_t CellsPrivateService::sendCellsVM(const String16& path, const String16&
     return NO_ERROR;
 }
 
+std::string toStdString(const String16& s) {
+    return std::string(String8(s.string()));
+}
+
+
+static int cfg_host_rt(int32_t sysid, const char* ifName, const char* dest, const char* nexthop)
+{
+    char cmd[MAX_CMD_LEN];
+    virtual_net_t *vnet = get_vnet(ifName);
+    if (NULL == vnet) {
+        return -1;
+    }
+
+    //配置物理路由
+    if (strcmp("NONE", nexthop) == 0) {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s dev %s",
+            vnet->host_rt, dest, ifName);
+    } else {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s via %s dev %s",
+            vnet->host_rt, dest, nexthop, ifName);
+    }
+
+    ALOGD("cfg_host_rt %s", cmd);
+    system(cmd);
+
+    //配置虚拟网卡路由
+    if (strcmp("NONE", nexthop) == 0) {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s dev %s",
+            vnet->vnet_info[sysid].rt_id, dest, ifName);
+    } else {
+        snprintf(cmd, sizeof(cmd), "ip route add table %d %s via %s dev %s",
+            vnet->vnet_info[sysid].rt_id, dest, nexthop, ifName);
+    }
+
+    ALOGD("cfg_host_rt %s", cmd);
+    system(cmd);
+    return 0;
+}
+
+status_t CellsPrivateService::cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop)
+{
+    cfg_host_rt(sysid, toStdString(ifName).c_str(), toStdString(dest).c_str(), toStdString(nexthop).c_str());
+    return NO_ERROR;
+}
+
 status_t CellsPrivateService::vmSystemReady(const String16& name)
 {
     char pname[PATH_MAX] = {0};
diff --git a/vendor/cells/cellsservice/CellsPrivateService.h b/vendor/cells/cellsservice/CellsPrivateService.h
index 87c7ec71ae..edcf3b5c9b 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.h
+++ b/vendor/cells/cellsservice/CellsPrivateService.h
@@ -38,6 +38,7 @@ public:
     virtual status_t tarCellsVM(const String16& name);
     virtual status_t vmSystemReady(const String16& name);
     virtual status_t sendCellsVM(const String16& path, const String16& address);
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop);
 
     int isInCellstar();
     void setCellstaring();
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.cpp b/vendor/cells/cellsservice/ICellsPrivateService.cpp
index 66c2c93e62..1a6ff6eb35 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/ICellsPrivateService.cpp
@@ -247,6 +247,23 @@ public:
         result = reply.readInt32();
         return result;
     }
+
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICellsPrivateService::getInterfaceDescriptor());
+        data.writeInt32(sysid);
+        data.writeString16(ifName);
+        data.writeString16(dest);
+        data.writeString16(nexthop);
+        status_t result = remote()->transact(CFG_NET_PROXY, data, &reply);
+        if (result != NO_ERROR) {
+            ALOGE("cfgNetProxy err!\n");
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
 };
 
 IMPLEMENT_META_INTERFACE(CellsPrivateService, "CellsPrivateService");
@@ -417,6 +434,18 @@ status_t BnCellsPrivateService::onTransact(uint32_t code, const Parcel& data, Pa
             return NO_ERROR;
         }
         break;
+        case CFG_NET_PROXY:
+        {
+            CHECK_INTERFACE(ICellsPrivateService, data, reply);
+            int32_t sys = data.readInt32();
+            String16 ifname = data.readString16();
+            String16 dest = data.readString16();
+            String16 nexthop = data.readString16();
+            status_t result = cfgNetProxy(sys, ifname, dest, nexthop);
+            reply->writeInt32(result);
+            return NO_ERROR;
+        }
+        break;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.h b/vendor/cells/cellsservice/ICellsPrivateService.h
index 49c2bc06fd..acc20322bf 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.h
+++ b/vendor/cells/cellsservice/ICellsPrivateService.h
@@ -31,6 +31,7 @@ protected:
         EXITCELL = IBinder::FIRST_CALL_TRANSACTION + 13,
         EXITHOST = IBinder::FIRST_CALL_TRANSACTION + 14,
         SENDCELLSVM = IBinder::FIRST_CALL_TRANSACTION + 15,
+        CFG_NET_PROXY = IBinder::FIRST_CALL_TRANSACTION + 16,
     };
 
 public:
@@ -52,6 +53,7 @@ public:
     virtual status_t tarCellsVM(const String16& name) = 0;
     virtual status_t vmSystemReady(const String16& name) = 0;
     virtual status_t sendCellsVM(const String16& path, const String16& address) = 0;
+    virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop) = 0;
 };
 
 class BnCellsPrivateService : public BnInterface<ICellsPrivateService>
diff --git a/vendor/cells/cellsservice/cell_cfg_net.cpp b/vendor/cells/cellsservice/cell_cfg_net.cpp
new file mode 100755
index 0000000000..81a7285706
--- /dev/null
+++ b/vendor/cells/cellsservice/cell_cfg_net.cpp
@@ -0,0 +1,42 @@
+#define LOG_TAG "CELL_CFG_NET"
+
+#include <cutils/log.h>
+#include <binder/BinderService.h>
+#include "ICellsPrivateService.h"
+
+using namespace android;
+
+int main(int argc, char** argv)
+{
+    sp<ICellsPrivateService> pCellsPrivateService = NULL;
+    const sp<IServiceManager> sm = initdefaultServiceManager();
+    if (sm != NULL) {
+        sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
+        if (binder != NULL) {
+            pCellsPrivateService = interface_cast<ICellsPrivateService>(binder);
+        }
+    }
+
+    if(pCellsPrivateService == NULL) {
+        ALOGE("could not get service CellsPrivateService \n");
+        return 0;
+    }
+
+    if (argc < 4) {
+        ALOGE("use cell_cfg_net sysId ifName dest nexthop \n");
+    }
+
+    int sysId = atoi(argv[1]);
+    char *ifName = argv[2];
+    char *dest = argv[3];
+    char *nexthop = "NONE";
+
+    if (argc == 5) {
+        nexthop = argv[4];
+    }
+        
+    ALOGD("call cfgNetProxy(%d, %s, %s, %s)", sysId, ifName, dest, nexthop);
+    pCellsPrivateService->cfgNetProxy(sysId, android::String16(ifName), android::String16(dest), android::String16(nexthop));
+
+    return 0;
+}
diff --git a/vendor/cells/cellsservice/virt_net_config.h b/vendor/cells/cellsservice/virt_net_config.h
new file mode 120000
index 0000000000..675a0e999d
--- /dev/null
+++ b/vendor/cells/cellsservice/virt_net_config.h
@@ -0,0 +1 @@
+../cells/virt_net_config.h
\ No newline at end of file
-- 
2.17.1

From 2e9763ec7093eb5caa26d26a2f50e84ca90175dd Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Sat, 3 Sep 2022 10:48:18 +0800
Subject: [PATCH 08/11] apply patch:xdja-container-20220829 from jianglin

---
 .../java/android/app/IContainerService.aidl   |   2 +-
 .../android/app/SystemServiceRegistry.java    |   8 +-
 .../java/com/android/server/CellsService.java |  11 +-
 .../server/display/DisplayManagerService.java |   7 +-
 .../contexthub/ContextHubService.java         |   8 +-
 ...droid_server_power_PowerManagerService.cpp |   6 +-
 .../java/com/android/server/SystemServer.java |   9 +-
 .../com/android/server/ContainerService.java  |   2 +-
 .../cmds/servicemanager/servicemanager.rc     |   1 -
 .../native/libs/gui/ISurfaceComposer.cpp      |  10 +-
 frameworks/native/libs/gui/LayerState.cpp     |   2 +
 .../native/libs/gui/SurfaceComposerClient.cpp |   9 +-
 .../native/libs/gui/include/gui/LayerState.h  |   1 +
 .../surfaceflinger/SurfaceFlinger.cpp         |  65 +++++----
 .../services/surfaceflinger/SurfaceFlinger.h  |   1 +
 system/core/rootdir/cells/system/hw/init.rc   |   3 +-
 system/core/rootdir/cells/system/wifi.rc      |  68 ++++-----
 ...d.hardware.input.classifier@1.0-service.rc |  18 +--
 .../rootdir/cells/vendor/hw/init.oriole.rc    |   4 +-
 system/core/rootdir/init.rc                   |  11 ++
 .../libhidl/transport/ServiceManagement.cpp   |   6 +-
 system/netd/server/NetdNativeService.cpp      |   0
 system/netd/server/NetdNativeService.h        |   0
 system/netd/server/RouteController.cpp        |   2 -
 vendor/cells/cells/celld.c                    |   8 +-
 .../cellnet.c => cells/cellnet-rmnet.c}       |  41 +++++-
 vendor/cells/cells/cellnet.c                  |  76 +++++++++-
 vendor/cells/cells/cellnet.h                  |   1 +
 vendor/cells/cells/nsexec.c                   |   7 +-
 vendor/cells/cells/virtual_network.c          |   0
 vendor/cells/cells_build.mk                   |   1 +
 .../secure/view/SecureSwitchActivity.java     |   6 +-
 vendor/cells/cellsservice/Android.mk          |  18 ++-
 .../cellsservice/CellsPrivateService.cpp      | 130 ++++++++----------
 .../cells/cellsservice/CellsPrivateService.h  |   1 +
 .../cellsservice/ICellsPrivateService.cpp     |  24 ++++
 .../cells/cellsservice/ICellsPrivateService.h |   2 +
 vendor/cells/cellsservice/cellnet.h           |  21 ---
 vendor/cells/cellsservice/cellsstart.cpp      |  75 ++++++++++
 vendor/cells/cellsservice/cellssync.cpp       |   4 +-
 vendor/cells/cellsservice/cswitch.cpp         |   2 +-
 vendor/cells/cellsservice/main_cells.cpp      |  36 +++--
 42 files changed, 471 insertions(+), 236 deletions(-)
 mode change 100644 => 100755 system/netd/server/NetdNativeService.cpp
 mode change 100644 => 100755 system/netd/server/NetdNativeService.h
 rename vendor/cells/{cellsservice/cellnet.c => cells/cellnet-rmnet.c} (89%)
 mode change 100644 => 100755 vendor/cells/cells/virtual_network.c
 delete mode 100755 vendor/cells/cellsservice/cellnet.h
 create mode 100755 vendor/cells/cellsservice/cellsstart.cpp

diff --git a/frameworks/base/core/java/android/app/IContainerService.aidl b/frameworks/base/core/java/android/app/IContainerService.aidl
index 168f4040e8..6e90d2486f 100755
--- a/frameworks/base/core/java/android/app/IContainerService.aidl
+++ b/frameworks/base/core/java/android/app/IContainerService.aidl
@@ -32,6 +32,6 @@ interface IContainerService {
 	int tarCellsVm(@nullable String name);
 	int sendCellsVm(@nullable String path, @nullable String address);
 	int vmSystemReady();
-	void onPeerNotified();
+        oneway void onPeerNotified();
 }
 
diff --git a/frameworks/base/core/java/android/app/SystemServiceRegistry.java b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
index 1143fce329..37cd13b41f 100755
--- a/frameworks/base/core/java/android/app/SystemServiceRegistry.java
+++ b/frameworks/base/core/java/android/app/SystemServiceRegistry.java
@@ -1696,7 +1696,7 @@ public final class SystemServiceRegistry {
                 new StaticServiceFetcher<TServiceClass>() {
                     @Override
                     public TServiceClass createService() throws ServiceNotFoundException {
-                        if(serviceName == Context.WIFI_SERVICE ||
+                        /*if(serviceName == Context.WIFI_SERVICE ||
                            serviceName == Context.WIFI_P2P_SERVICE ||
                            serviceName == Context.WIFI_AWARE_SERVICE ||
                            serviceName == Context.WIFI_SCANNING_SERVICE ||
@@ -1704,7 +1704,7 @@ public final class SystemServiceRegistry {
                            serviceName == Context.WIFI_RTT_SERVICE){
                             return serviceProducer.createService(
                                     ServiceManager.getInitService(serviceName));
-                        }
+                        }*/
                         return serviceProducer.createService(
                                 ServiceManager.getServiceOrThrow(serviceName));
                     }});
@@ -1763,7 +1763,7 @@ public final class SystemServiceRegistry {
                     @Override
                     public TServiceClass createService(ContextImpl ctx)
                             throws ServiceNotFoundException {
-                        if(serviceName == Context.WIFI_SERVICE ||
+                        /*if(serviceName == Context.WIFI_SERVICE ||
                            serviceName == Context.WIFI_P2P_SERVICE ||
                            serviceName == Context.WIFI_AWARE_SERVICE ||
                            serviceName == Context.WIFI_SCANNING_SERVICE ||
@@ -1772,7 +1772,7 @@ public final class SystemServiceRegistry {
                             return serviceProducer.createService(
                                     ctx.getOuterContext(),
                                     ServiceManager.getInitService(serviceName));
-                        }
+                        }*/
                         return serviceProducer.createService(
                                 ctx.getOuterContext(),
                                 ServiceManager.getServiceOrThrow(serviceName));
diff --git a/frameworks/base/services/core/java/com/android/server/CellsService.java b/frameworks/base/services/core/java/com/android/server/CellsService.java
index b13b176a24..f18bd8e004 100755
--- a/frameworks/base/services/core/java/com/android/server/CellsService.java
+++ b/frameworks/base/services/core/java/com/android/server/CellsService.java
@@ -37,7 +37,6 @@ import android.net.TrafficStats;
 import android.net.InetAddresses;
 import android.net.IpPrefix;
 import android.app.CellsPrivateServiceMgr;
-
 import android.provider.Settings;
 
 import com.android.server.net.NetlinkTracker;
@@ -85,7 +84,9 @@ public class CellsService extends ICellsService.Stub {
 
     public  void systemReady(){
         if(SystemProperties.get("ro.boot.vm","0").equals("1")){
-            mCellsNetworkAgent = new CellsNetworkAgent(mContext,this);
+            if(SystemProperties.get("persist.sys.cells.netagent","").equals("")){
+                mCellsNetworkAgent = new CellsNetworkAgent(mContext,this);
+            }
 
             Thread vmready = new Thread(new Runnable(){
                 @Override
@@ -93,14 +94,12 @@ public class CellsService extends ICellsService.Stub {
                     CellsPrivateServiceMgr mCellsService = new CellsPrivateServiceMgr(mContext,
                                 ServiceManager.getInitService("CellsPrivateService"));
                     
-                    SystemProperties.set("persist.sys.exit", "1");
-
                     do
                     {
-                        SystemClock.sleep(5000);
+                        SystemClock.sleep(3000);
 
                         if("1".equals(SystemProperties.get("sys.boot_completed"))){
-                            SystemClock.sleep(2000);
+                            SystemClock.sleep(500);
                             mCellsService.vmSystemReady();
                             return ;
                         }
diff --git a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
index 499b111087..76e6a8adb7 100644
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
@@ -267,8 +267,11 @@ public final class DisplayManagerService extends SystemService {
         @Override
         public synchronized void requestDisplayState(int displayId, int state, float brightness,
                 float sdrBrightness) {
-            if(SystemProperties.get("persist.sys.exit","0").equals("1"))
-            	return ;
+            if(SystemProperties.get("sys.boot_completed").equals("1"))
+            {
+                if(SystemProperties.get("persist.sys.exit","0").equals("1"))
+                    return ;
+            }
 
             boolean allInactive = true;
             boolean allOff = true;
diff --git a/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java b/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
index 191a5f5e2e..52d70fc009 100644
--- a/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
+++ b/frameworks/base/services/core/java/com/android/server/location/contexthub/ContextHubService.java
@@ -203,11 +203,11 @@ public class ContextHubService extends IContextHubService.Stub {
 
         Pair<List<ContextHub>, List<String>> hubInfo;
         try {
-            if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
+            //if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
                 hubInfo = mContextHubWrapper.getHubs();
-            } else{
-                hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
-            }
+            //} else{
+            //    hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
+            //}
         } catch (RemoteException e) {
             Log.e(TAG, "RemoteException while getting Context Hub info", e);
             hubInfo = new Pair(Collections.emptyList(), Collections.emptyList());
diff --git a/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp b/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
index ae7ea3cd90..afcbe85df4 100644
--- a/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
+++ b/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp
@@ -193,8 +193,10 @@ void disableAutoSuspend() {
     std::lock_guard<std::mutex> lock(gSuspendMutex);
     if (!gSuspendBlocker) {
         sp<ISystemSuspend> suspendHal = getSuspendHal();
-        gSuspendBlocker = suspendHal->acquireWakeLock(WakeLockType::PARTIAL,
-                "PowerManager.SuspendLockout");
+        if(suspendHal != nullptr){
+            gSuspendBlocker = suspendHal->acquireWakeLock(WakeLockType::PARTIAL,
+                    "PowerManager.SuspendLockout");
+        }
     }
 }
 
diff --git a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
index 24969fd93e..9d3fbee281 100755
--- a/frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -1510,14 +1510,12 @@ public final class SystemServer implements Dumpable {
             // Start receiving calls from HIDL services. Start in in a separate thread
             // because it need to connect to SensorManager. This has to start
             // after PHASE_WAIT_FOR_SENSOR_SERVICE is done.
-            if(SystemProperties.get("ro.boot.vm","0").equals("0")){
             SystemServerInitThreadPool.submit(() -> {
                 TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog();
                 traceLog.traceBegin(START_HIDL_SERVICES);
                 startHidlServices();
                 traceLog.traceEnd();
             }, START_HIDL_SERVICES);
-            }
 
             if (!isWatch && enableVrService) {
                 t.traceBegin("StartVrManagerService");
@@ -1861,7 +1859,7 @@ public final class SystemServer implements Dumpable {
             }
             t.traceEnd();
 
-            if(SystemProperties.get("ro.boot.vm","0").equals("0")){
+            //if(SystemProperties.get("ro.boot.vm","0").equals("0")){
             if (context.getPackageManager().hasSystemFeature(
                     PackageManager.FEATURE_WIFI)) {
                 // Wifi Service must be started first for wifi-related services.
@@ -1898,7 +1896,7 @@ public final class SystemServer implements Dumpable {
                         WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);
                 t.traceEnd();
             }
-            }
+
             if (context.getPackageManager().hasSystemFeature(
                     PackageManager.FEATURE_LOWPAN)) {
                 t.traceBegin("StartLowpan");
@@ -1912,6 +1910,7 @@ public final class SystemServer implements Dumpable {
                 mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
                 t.traceEnd();
             }
+            //}
 
             t.traceBegin("StartPacProxyService");
             try {
@@ -2826,7 +2825,6 @@ public final class SystemServer implements Dumpable {
                 reportWtf("making VcnManagementService ready", e);
             }
             t.traceEnd();
-            if (SystemProperties.get("ro.boot.vm","0").equals("0")) {
             t.traceBegin("MakeNetworkPolicyServiceReady");
             try {
                 if (networkPolicyF != null) {
@@ -2836,7 +2834,6 @@ public final class SystemServer implements Dumpable {
                 reportWtf("making Network Policy Service ready", e);
             }
             t.traceEnd();
-            }
 
             // Wait for all packages to be prepared
             mPackageManagerService.waitForAppDataPrepared();
diff --git a/frameworks/base/services/xdja/com/android/server/ContainerService.java b/frameworks/base/services/xdja/com/android/server/ContainerService.java
index 0770e7190f..712243a825 100755
--- a/frameworks/base/services/xdja/com/android/server/ContainerService.java
+++ b/frameworks/base/services/xdja/com/android/server/ContainerService.java
@@ -148,7 +148,7 @@ public class ContainerService extends IContainerService.Stub {
         Parcel data = Parcel.obtain();
         Parcel reply = Parcel.obtain();
         try {
-            Log.e(TAG,"switchCellsVm start ");
+            Log.e(TAG,"switchCellsVm start name:" + name);
             data.writeInterfaceToken("CellsPrivateService");
             data.writeString(name);
             mChannel.transact(SWITCHCELLSVM, data, reply, 0);
diff --git a/frameworks/native/cmds/servicemanager/servicemanager.rc b/frameworks/native/cmds/servicemanager/servicemanager.rc
index d7607bed9e..6d5070fa04 100644
--- a/frameworks/native/cmds/servicemanager/servicemanager.rc
+++ b/frameworks/native/cmds/servicemanager/servicemanager.rc
@@ -3,7 +3,6 @@ service servicemanager /system/bin/servicemanager
     user system
     group system readproc
     critical
-    onrestart restart cellsservice
     onrestart restart apexd
     onrestart restart audioserver
     onrestart restart gatekeeperd
diff --git a/frameworks/native/libs/gui/ISurfaceComposer.cpp b/frameworks/native/libs/gui/ISurfaceComposer.cpp
index a9996acc29..8624b25973 100644
--- a/frameworks/native/libs/gui/ISurfaceComposer.cpp
+++ b/frameworks/native/libs/gui/ISurfaceComposer.cpp
@@ -75,6 +75,14 @@ public:
                                  const std::vector<ListenerCallbacks>& listenerCallbacks,
                                  uint64_t transactionId) override {
         Parcel data, reply;
+
+        InputWindowCommands tmpcommands;
+        char systemname[PROPERTY_VALUE_MAX]={0};
+        property_get("ro.boot.vm.name", systemname, "");
+
+        tmpcommands = commands;
+        tmpcommands.systemname = systemname;
+
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
 
         SAFE_PARCEL(frameTimelineInfo.write, data);
@@ -91,7 +99,7 @@ public:
 
         SAFE_PARCEL(data.writeUint32, flags);
         SAFE_PARCEL(data.writeStrongBinder, applyToken);
-        SAFE_PARCEL(commands.write, data);
+        SAFE_PARCEL(tmpcommands.write, data);
         SAFE_PARCEL(data.writeInt64, desiredPresentTime);
         SAFE_PARCEL(data.writeBool, isAutoTimestamp);
         SAFE_PARCEL(data.writeStrongBinder, uncacheBuffer.token.promote());
diff --git a/frameworks/native/libs/gui/LayerState.cpp b/frameworks/native/libs/gui/LayerState.cpp
index 77a883b332..5577672d36 100644
--- a/frameworks/native/libs/gui/LayerState.cpp
+++ b/frameworks/native/libs/gui/LayerState.cpp
@@ -635,12 +635,14 @@ void InputWindowCommands::clear() {
 status_t InputWindowCommands::write(Parcel& output) const {
     SAFE_PARCEL(output.writeParcelableVector, focusRequests);
     SAFE_PARCEL(output.writeBool, syncInputWindows);
+    SAFE_PARCEL(output.writeString8, systemname);
     return NO_ERROR;
 }
 
 status_t InputWindowCommands::read(const Parcel& input) {
     SAFE_PARCEL(input.readParcelableVector, &focusRequests);
     SAFE_PARCEL(input.readBool, &syncInputWindows);
+    systemname = input.readString8();
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/libs/gui/SurfaceComposerClient.cpp b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
index d464f04c52..25c0b110a1 100644
--- a/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+++ b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
@@ -25,6 +25,7 @@
 #include <utils/SortedVector.h>
 #include <utils/String8.h>
 #include <utils/threads.h>
+#include <cutils/properties.h>
 
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
@@ -707,7 +708,13 @@ status_t SurfaceComposerClient::Transaction::writeToParcel(Parcel* parcel) const
         composerState.write(*parcel);
     }
 
-    mInputWindowCommands.write(*parcel);
+    InputWindowCommands tmpcommands;
+    char systemname[PROPERTY_VALUE_MAX]={0};
+    property_get("ro.boot.vm.name", systemname, "");
+
+    tmpcommands = mInputWindowCommands;
+    tmpcommands.systemname = systemname;
+    tmpcommands.write(*parcel);
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/libs/gui/include/gui/LayerState.h b/frameworks/native/libs/gui/include/gui/LayerState.h
index 03e4aacdbe..1be4af210f 100644
--- a/frameworks/native/libs/gui/include/gui/LayerState.h
+++ b/frameworks/native/libs/gui/include/gui/LayerState.h
@@ -302,6 +302,7 @@ struct DisplayState {
 struct InputWindowCommands {
     std::vector<gui::FocusRequest> focusRequests;
     bool syncInputWindows{false};
+    String8 systemname;
 
     // Merges the passed in commands and returns true if there were any changes.
     bool merge(const InputWindowCommands& other);
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index 156e770a1a..ad9a49b35c 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -383,6 +383,8 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory, SkipInitializationTag)
     {
         mWindowInfosListenerInvokers.push_back(new WindowInfosListenerInvoker(this));
     }
+
+    mInputWindowCommandss = std::vector<InputWindowCommands>(CELLS_MAX_CONTEXT);
     ALOGI("Using HWComposer service: %s", mHwcServiceName.c_str());
 }
 
@@ -3095,39 +3097,40 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags) {
 }
 
 void SurfaceFlinger::updateInputFlinger() {
-    int i = 0;
     ATRACE_CALL();
     if (!mInputFlinger) {
         return;
     }
 
+    bool syncInputWindows = false;
+    for(int i=0; i < CELLS_MAX_CONTEXT; i++)
+    {
+        syncInputWindows |= mInputWindowCommandss[i].syncInputWindows;
+    }
+
     if (mVisibleRegionsDirty || mInputInfoChanged) {
         mInputInfoChanged = false;
         notifyWindowInfos();
-    } else if (mInputWindowCommands.syncInputWindows) {
+    } else if (syncInputWindows) {
         // If the caller requested to sync input windows, but there are no
         // changes to input windows, notify immediately.
         windowInfosReported();
     }
 
-    for (const auto& focusRequest : mInputWindowCommands.focusRequests) {
-        //mInputFlinger->setFocusedWindow(focusRequest);
-        for(i = 0; i < CELLS_MAX_CONTEXT; i++){
-            if(i == 0){
-                mInputFlinger->setFocusedWindow(focusRequest);
-            }
-            else{
-                const sp<IServiceManager> sm = OtherServiceManager(i);
-                if (sm != nullptr){
-                    sp<os::IInputFlinger>  mInputFlinger1 = interface_cast<os::IInputFlinger>(sm->getService( String16("inputflinger")));
-                    if (mInputFlinger1 != nullptr) {
-                        mInputFlinger1->setFocusedWindow(focusRequest);
-                    }
+    for(int i=0; i < CELLS_MAX_CONTEXT; i++)
+    {
+        for (const auto& focusRequest : mInputWindowCommandss[i].focusRequests)
+        {
+            const sp<IServiceManager> sm = OtherServiceManager(i);
+            if (sm != nullptr){
+                sp<os::IInputFlinger>  mInputFlinger1 = interface_cast<os::IInputFlinger>(sm->getService( String16("inputflinger")));
+                if (mInputFlinger1 != nullptr) {
+                    mInputFlinger1->setFocusedWindow(focusRequest);
                 }
             }
         }
+        mInputWindowCommandss[i].clear();
     }
-    mInputWindowCommands.clear();
 }
 
 bool enablePerWindowInputRotation() {
@@ -3137,9 +3140,7 @@ bool enablePerWindowInputRotation() {
 }
 
 void SurfaceFlinger::notifyWindowInfos() {
-    //std::vector<WindowInfo> windowInfos;
     std::vector<std::vector<WindowInfo>> windowInfos(CELLS_MAX_CONTEXT);
-    int i = 0;
 
     mDrawingState.traverseInReverseZOrder([&](Layer* layer) {
         if (!layer->needsInputInfo()) return;
@@ -3148,25 +3149,18 @@ void SurfaceFlinger::notifyWindowInfos() {
                 : nullptr;
         // When calculating the screen bounds we ignore the transparent region since it may
         // result in an unwanted offset.
-        //windowInfos.push_back(layer->fillInputInfo(display));
-        if(layer->getSystemName() == ""){
-            windowInfos[0].push_back(layer->fillInputInfo(display));
-        }else{
-            sscanf(layer->systemName(), "cell%d",&i);
-            if(i > 0 && i < CELLS_MAX_CONTEXT){
-                windowInfos[i].push_back(layer->fillInputInfo(display));
-            }
+        int i = 0;
+        sscanf(layer->systemName(), "cell%d", &i);
+        if(i >= 0 && i < CELLS_MAX_CONTEXT){
+            windowInfos[i].push_back(layer->fillInputInfo(display));
         }
     });
 
-    for(i = 0; i < CELLS_MAX_CONTEXT; i++)
+    for(int i = 0; i < CELLS_MAX_CONTEXT; i++)
     {
         mWindowInfosListenerInvokers[i]->windowInfosChanged(windowInfos[i],
-                                                    mInputWindowCommands.syncInputWindows);
+                                                    mInputWindowCommandss[i].syncInputWindows);
     }
-
-    //mWindowInfosListenerInvoker->windowInfosChanged(windowInfos,
-    //                                                mInputWindowCommands.syncInputWindows);
 }
 
 void SurfaceFlinger::updateCursorAsync() {
@@ -4318,7 +4312,10 @@ uint32_t SurfaceFlinger::setClientStateLocked(
 }
 
 uint32_t SurfaceFlinger::addInputWindowCommands(const InputWindowCommands& inputWindowCommands) {
-    bool hasChanges = mInputWindowCommands.merge(inputWindowCommands);
+    int i = 0;
+    sscanf(inputWindowCommands.systemname.string(), "cell%d", &i);
+    //ALOGD("addInputWindowCommands = %d", i);
+    bool hasChanges = mInputWindowCommandss[i].merge(inputWindowCommands);
     return hasChanges ? eTraversalNeeded : 0;
 }
 
@@ -7140,12 +7137,12 @@ status_t SurfaceFlinger::removeWindowInfosListenerX(
 status_t SurfaceFlinger::enterSelf(){
     invalidateHwcGeometry();
     repaintEverything();
-    ALOGD("SurfaceFlinger::enterSelf");
+    ALOGD("enterSelf");
     return NO_ERROR;
 }
 
 status_t SurfaceFlinger::exitSelf(){
-    ALOGD("SurfaceFlinger::exitSelf");
+    ALOGD("exitSelf");
     return NO_ERROR;
 }
 
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
index 9397faf68b..0d32fca74c 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
@@ -1454,6 +1454,7 @@ private:
     sp<os::IInputFlinger> mInputFlinger;
     // Should only be accessed by the main thread.
     InputWindowCommands mInputWindowCommands;
+    std::vector<InputWindowCommands> mInputWindowCommandss;
 
     Hwc2::impl::PowerAdvisor mPowerAdvisor;
 
diff --git a/system/core/rootdir/cells/system/hw/init.rc b/system/core/rootdir/cells/system/hw/init.rc
index b5efe44de2..4773e26250 100644
--- a/system/core/rootdir/cells/system/hw/init.rc
+++ b/system/core/rootdir/cells/system/hw/init.rc
@@ -67,7 +67,8 @@ on early-init
     start ueventd
 
     setprop ro.boot.vm 1
-    setprop persist.sys.exit 0
+    setprop persist.sys.exit 1
+    setprop persist.sys.cells.netagent ""
     setprop persist.logd.logpersistd logcatd
     # setprop system_init.startsensorservice 0
     setprop persist.sys.sdcardfs force_off
diff --git a/system/core/rootdir/cells/system/wifi.rc b/system/core/rootdir/cells/system/wifi.rc
index 71567eddd9..eceee0ae09 100644
--- a/system/core/rootdir/cells/system/wifi.rc
+++ b/system/core/rootdir/cells/system/wifi.rc
@@ -29,54 +29,54 @@ on property:sys.boot_completed=1 && property:sys.wifitracing.started=0
    # Create trace buffer, and set basic configuration.
    mkdir /sys/kernel/debug/tracing/instances/wifi 711
    restorecon_recursive /sys/kernel/debug/tracing/instances/wifi
-#   write /sys/kernel/debug/tracing/instances/wifi/tracing_on 0
-#   write /sys/kernel/debug/tracing/instances/wifi/buffer_size_kb 1
-#   write /sys/kernel/debug/tracing/instances/wifi/trace_options disable_on_free
+   write /sys/kernel/debug/tracing/instances/wifi/tracing_on 0
+   write /sys/kernel/debug/tracing/instances/wifi/buffer_size_kb 1
+   write /sys/kernel/debug/tracing/instances/wifi/trace_options disable_on_free
 
    mkdir /sys/kernel/tracing/instances/wifi 711
    restorecon_recursive /sys/kernel/tracing/instances/wifi
-#   write /sys/kernel/tracing/instances/wifi/tracing_on 0
-#   write /sys/kernel/tracing/instances/wifi/buffer_size_kb 1
-#   write /sys/kernel/tracing/instances/wifi/trace_options disable_on_free
+   write /sys/kernel/tracing/instances/wifi/tracing_on 0
+   write /sys/kernel/tracing/instances/wifi/buffer_size_kb 1
+   write /sys/kernel/tracing/instances/wifi/trace_options disable_on_free
 
    # Enable cfg80211 events for connection and key management events.
    # - Events are not actually logged until WifiService writes "1" to
    #   /sys/kernel/debug/tracing/instances/wifi/tracing_on.
    # - WifiService is responsible for turning tracing off and on.
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
 
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/cfg80211_gtk_rekey_notify/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_add_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_assoc/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_auth/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_connect/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_default_mgmt_key/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/cfg80211/rdev_set_rekey_data/enable 1
 
    # Enable datapath events for Wifi.
    # - Events are not actually logged until WifiService writes "1" to
    #   /sys/kernel/debug/tracing/instances/wifi/tracing_on.
    # - WifiService will ensure that tracing is turned back off,
    #   when a connection attempt ends (whether in success or failure)
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_queue/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_rx/enable 1
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_queue/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_rx/enable 1
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
 
-#   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
-#   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_queue/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/netif_rx/enable 1
-#   write /sys/kernel/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface:-wlan0}
+   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_queue/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/net_dev_xmit/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/netif_rx/enable 1
+   write /sys/kernel/tracing/instances/wifi/events/net/netif_receive_skb/enable 1
 
    # Set DAC to allow system to enable/disable, and read wifi trace
    # events.
@@ -97,5 +97,5 @@ on property:sys.boot_completed=1 && property:sys.wifitracing.started=0
 
 on property:sys.boot_completed=1 && property:wifi.interface=* && property:sys.wifitracing.started=1
    # Override default value.
-#   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface}
-#   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface}
+   write /sys/kernel/debug/tracing/instances/wifi/events/net/filter name==${wifi.interface}
+   write /sys/kernel/tracing/instances/wifi/events/net/filter name==${wifi.interface}
diff --git a/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc b/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
index 77a5fab5a9..e6b70e5a3a 100644
--- a/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
+++ b/system/core/rootdir/cells/vendor/android.hardware.input.classifier@1.0-service.rc
@@ -1,9 +1,9 @@
-#service vendor.input.classifier-1-0 /vendor/bin/hw/android.hardware.input.classifier@1.0-service
-#    # Must be specified if "disabled" is set. This HAL will only start if requested via getService
-#    interface android.hardware.input.classifier@1.0::IInputClassifier default
-#    class hal
-#    user nobody
-#    # will not be restarted if it exits until it is requested to be restarted
-#    oneshot
-#    # will only be started when requested
-#    disabled
\ No newline at end of file
+service vendor.input.classifier-1-0 /vendor/bin/hw/android.hardware.input.classifier@1.0-service
+    # Must be specified if "disabled" is set. This HAL will only start if requested via getService
+    interface android.hardware.input.classifier@1.0::IInputClassifier default
+    class hal
+    user nobody
+    # will not be restarted if it exits until it is requested to be restarted
+    oneshot
+    # will only be started when requested
+    disabled
diff --git a/system/core/rootdir/cells/vendor/hw/init.oriole.rc b/system/core/rootdir/cells/vendor/hw/init.oriole.rc
index 461922098b..d509c17091 100644
--- a/system/core/rootdir/cells/vendor/hw/init.oriole.rc
+++ b/system/core/rootdir/cells/vendor/hw/init.oriole.rc
@@ -10,10 +10,10 @@ on init
 
 # Toggle glove_mode according to touch_sensitivity_mode
 on property:persist.vendor.touch_sensitivity_mode=0 && property:sys.boot_completed=1
-#   write /sys/class/spi_master/spi11/spi11.0/glove_mode 00
+    write /sys/class/spi_master/spi11/spi11.0/glove_mode 00
 
 on property:persist.vendor.touch_sensitivity_mode=1 && property:sys.boot_completed=1
-#   write /sys/class/spi_master/spi11/spi11.0/glove_mode 01
+    write /sys/class/spi_master/spi11/spi11.0/glove_mode 01
 
 on late-init && property:ro.boot.hardware.revision=PROTO1.0
     setprop vendor.thermal.config "thermal_info_config_WHI_A.json"
diff --git a/system/core/rootdir/init.rc b/system/core/rootdir/init.rc
index d28c730adc..a898c16d91 100644
--- a/system/core/rootdir/init.rc
+++ b/system/core/rootdir/init.rc
@@ -68,6 +68,8 @@ on early-init
 
     setprop ro.boot.vm 0
     setprop persist.sys.exit 0
+    setprop persist.sys.ui.exit 0
+    setprop persist.sys.iw.wlan ""
     setprop persist.logd.logpersistd logcatd
     setprop persist.sys.sdcardfs force_on
 
@@ -1287,3 +1289,12 @@ service cellsservice /system/bin/cellsservice
     user root
     group root
     seclabel  u:r:init:s0
+
+service cellsstart /system/bin/cellsstart
+    class main
+    disabled
+    oneshot
+    user root
+    group root
+    seclabel  u:r:init:s0
+
diff --git a/system/libhidl/transport/ServiceManagement.cpp b/system/libhidl/transport/ServiceManagement.cpp
index 14dcdebd30..4fc3f78b01 100644
--- a/system/libhidl/transport/ServiceManagement.cpp
+++ b/system/libhidl/transport/ServiceManagement.cpp
@@ -85,13 +85,13 @@ static bool getinithidlservice(const char* descriptor)
         "android.hardware.keymaster",
         "android.hardware.biometrics.fingerprint",
         "android.hardware.thermal",
-        "android.hardware.input.classifier",
+        //"android.hardware.input.classifier",
         "android.hardware.audio",
         "android.hardware.soundtrigger",
         "android.hardware.secure_element",
-        "android.frameworks.sensorservice",
-        "vendor.samsung_slsi.telephony.hardware.radioExternal",
+        //"android.frameworks.sensorservice",
         "android.hardware.radio",
+        "vendor.samsung_slsi.telephony.hardware.radioExternal",
         NULL
     };
 
diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
old mode 100644
new mode 100755
diff --git a/system/netd/server/NetdNativeService.h b/system/netd/server/NetdNativeService.h
old mode 100644
new mode 100755
diff --git a/system/netd/server/RouteController.cpp b/system/netd/server/RouteController.cpp
index e34953bbff..7b794f0a57 100644
--- a/system/netd/server/RouteController.cpp
+++ b/system/netd/server/RouteController.cpp
@@ -1149,8 +1149,6 @@ int RouteController::flushRoutes(const char* interface) {
 }
 
 int RouteController::Init(unsigned localNetId) {
-    if(android::base::GetProperty("ro.boot.vm", "0") == std::string("1"))
-        return 0;
     if (int ret = flushRules()) {
         return ret;
     }
diff --git a/vendor/cells/cells/celld.c b/vendor/cells/cells/celld.c
index 588c0cee89..9365fcd546 100755
--- a/vendor/cells/cells/celld.c
+++ b/vendor/cells/cells/celld.c
@@ -1079,7 +1079,7 @@ static void *__monitor_start_state(void *arg)
 {
 	char *root_path = NULL;
 	char buf[20];
-	int ret, i = 0;
+	int ret;// i = 0;
 
 	struct cell_monitor_state *cms = (struct cell_monitor_state *)arg;
 	root_path = get_root_path(cms->name);
@@ -1097,9 +1097,9 @@ static void *__monitor_start_state(void *arg)
 
 	__umount_rootmount(root_path);
 
-	sleep(2);
-	sscanf(cms->name, "cell%d",&i);
-	if(i > 0)starttether(i);
+	//sleep(2);
+	//sscanf(cms->name, "cell%d",&i);
+	//if(i > 0)starttether(i);
 
 	finish_cell_startup(cms->name);
 
diff --git a/vendor/cells/cellsservice/cellnet.c b/vendor/cells/cells/cellnet-rmnet.c
similarity index 89%
rename from vendor/cells/cellsservice/cellnet.c
rename to vendor/cells/cells/cellnet-rmnet.c
index 83c21d431b..1b2bff6969 100755
--- a/vendor/cells/cellsservice/cellnet.c
+++ b/vendor/cells/cells/cellnet-rmnet.c
@@ -12,7 +12,8 @@
 #include <cutils/memory.h>
 #include <cutils/misc.h>
 
-#define INTERFACE "wlan0"
+#define INTERFACE "rmnet_data1"
+#define VMINTERFACE "rmnet_data1"
 #define VETH0 "vm_wlan_%d_0"
 #define VETH1 "vm_wlan_%d_1"
 
@@ -91,6 +92,30 @@ void vethtons(int pid,int index)
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
 
+static int get_if_status(char *if_name)
+{
+    char buffer[BUFSIZ];
+    char cmd[100];
+    FILE *read_fp;
+    int chars_read;
+
+    memset( buffer, 0, BUFSIZ );
+    memset( cmd, 0, 100 );
+
+    sprintf(cmd, "ip link show | grep %s",if_name);
+    read_fp = popen(cmd, "r");
+    if ( read_fp != NULL )
+    {
+        chars_read = fread(buffer, sizeof(char), BUFSIZ-1, read_fp);
+        pclose(read_fp);
+        if (chars_read > 0){
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
 void rnameveth(int index)
 {
     int ret  = 0;
@@ -103,21 +128,29 @@ void rnameveth(int index)
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
     snprintf(vethaddr1, sizeof(vethaddr1), VETHIFACEADDR1, VETHIFACEADDRBASE + index);
 
+    int num = 0;
+    while(0 == get_if_status(vethname1) && num < 5)
+    {
+        num++;
+        ALOGD("rnameveth num = %d", num);
+        sleep(1);
+    }
+
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,INTERFACE );
+    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,VMINTERFACE );
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",INTERFACE,vethaddr1,VETHADDRMASK);
+    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",VMINTERFACE,vethaddr1,VETHADDRMASK);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,INTERFACE);
+    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,VMINTERFACE);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
diff --git a/vendor/cells/cells/cellnet.c b/vendor/cells/cells/cellnet.c
index e93e409790..51f8f57bef 100755
--- a/vendor/cells/cells/cellnet.c
+++ b/vendor/cells/cells/cellnet.c
@@ -11,8 +11,10 @@
 #include <cutils/log.h>
 #include <cutils/memory.h>
 #include <cutils/misc.h>
+#include <cutils/properties.h>
 
 #define INTERFACE "wlan0"
+#define VMINTERFACE "wlan0"
 #define VETH0 "vm_wlan_%d_0"
 #define VETH1 "vm_wlan_%d_1"
 
@@ -40,6 +42,12 @@ void createveth(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
@@ -82,6 +90,12 @@ void vethtons(int pid,int index)
     char vethname1[24] = {0};
     char cmd[256];
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
 
     errno = 0;
@@ -123,6 +137,24 @@ void rnameveth(int index)
     char vethaddr1[64] = {0};
     char cmd[256];
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        int i=0;
+        sscanf(value, "cell%d", &i);
+        if(index == i)
+        {
+            int num = 0;
+            while(0 == get_if_status("wlan0") && num < 5)
+            {
+                num++;
+                ALOGD("wlan0 num = %d", num);
+                sleep(1);
+            }
+        }
+        return;
+    }
+
     snprintf(vethname1, sizeof(vethname1), VETH1, index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
     snprintf(vethaddr1, sizeof(vethaddr1), VETHIFACEADDR1, VETHIFACEADDRBASE + index);
@@ -137,19 +169,19 @@ void rnameveth(int index)
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,INTERFACE );
+    snprintf(cmd, sizeof(cmd), "ip link set %s name %s",vethname1 ,VMINTERFACE );
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",INTERFACE,vethaddr1,VETHADDRMASK);
+    snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",VMINTERFACE,vethaddr1,VETHADDRMASK);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 
     errno = 0;
     memset(cmd,0,sizeof(cmd));
-    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,INTERFACE);
+    snprintf(cmd, sizeof(cmd), "ip ro add default via %s dev %s",vethaddr0 ,VMINTERFACE);
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
@@ -163,6 +195,12 @@ void starttether(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
@@ -217,6 +255,12 @@ void stoptether(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
 
     errno = 0;
@@ -247,6 +291,12 @@ void delveth(int index)
 
     char cmd[256] = {0};
 
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") != 0){
+        return;
+    }
+
     snprintf(vethname0, sizeof(vethname0), VETH0, index);
     snprintf(vethgateaddr, sizeof(vethgateaddr), VETHGATEADDR, VETHIFACEADDRBASE + index);
     snprintf(vethaddr0, sizeof(vethaddr0), VETHIFACEADDR0, VETHIFACEADDRBASE + index);
@@ -275,3 +325,23 @@ void delveth(int index)
     ret = system(cmd);
     ALOGD("%s errno = %s",cmd,strerror(errno));
 }
+
+#define WLAN_PHY "phy0" 
+
+void phytons(int pid,int index)
+{
+    int ret  = 0;
+    char cmd[256];
+
+    char value[PROPERTY_VALUE_MAX] = {0};
+    property_get("persist.sys.iw.wlan", value, "");
+    if(strcmp(value, "") == 0){
+        return;
+    }
+
+    errno = 0;
+    memset(cmd,0,sizeof(cmd));
+    snprintf(cmd, sizeof(cmd), "iw phy %s set netns %d", WLAN_PHY, pid);
+    ret = system(cmd);
+    ALOGD("%s index = %d errno = %s",cmd,index,strerror(errno));
+}
diff --git a/vendor/cells/cells/cellnet.h b/vendor/cells/cells/cellnet.h
index bcc4e67414..86163746d5 100755
--- a/vendor/cells/cells/cellnet.h
+++ b/vendor/cells/cells/cellnet.h
@@ -13,6 +13,7 @@ extern void rnameveth(int index);
 extern void starttether(int index);
 extern void stoptether(int index);
 extern void delveth(int index);
+extern void phytons(int pid,int index);
 
 #ifdef __cplusplus
 }
diff --git a/vendor/cells/cells/nsexec.c b/vendor/cells/cells/nsexec.c
index ffb6ffc6e4..e68a60182f 100755
--- a/vendor/cells/cells/nsexec.c
+++ b/vendor/cells/cells/nsexec.c
@@ -753,8 +753,13 @@ int cell_nsexec(int sd, struct cell_args *cell_args,
 		sscanf(cell_args->cellname, "cell%d",&i);
 		if(i > 0){
 			createveth(i);
-
 			vethtons(pid,i);
+
+			int index = 0;
+			char value[PROPERTY_VALUE_MAX] = {0};
+			property_get("persist.sys.iw.wlan", value, "");
+			sscanf(value, "cell%d", &index);
+			if(i == index) phytons(pid,i);
 		}
 	}
 
diff --git a/vendor/cells/cells/virtual_network.c b/vendor/cells/cells/virtual_network.c
old mode 100644
new mode 100755
diff --git a/vendor/cells/cells_build.mk b/vendor/cells/cells_build.mk
index 99c08b1562..c39b84c3c8 100755
--- a/vendor/cells/cells_build.mk
+++ b/vendor/cells/cells_build.mk
@@ -6,5 +6,6 @@ PRODUCT_PACKAGES += \
 	cellssync \
 	cellsupdownvm \
 	cswitch \
+        cellsstart \
 	busybox \
 	virtualcamera
diff --git a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
index 4bbef17bd5..e6b3f80f74 100755
--- a/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
+++ b/vendor/cells/cellsapp/src/com/cells/systemswitch/secure/view/SecureSwitchActivity.java
@@ -2,6 +2,8 @@ package com.cells.systemswitch.secure.view;
 
 import android.util.Log;
 import android.app.Activity;
+import android.app.ContainerManager;
+import android.content.Context;
 import android.os.Bundle;
 import android.view.View;
 import android.view.WindowManager;
@@ -28,10 +30,12 @@ import java.lang.RuntimeException;
 
 public class SecureSwitchActivity extends Activity {
 	private static final String TAG = "SecureSwitchActivity";
+    private ContainerManager mContainerManager;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
+        mContainerManager = (ContainerManager) getSystemService(Context.CONTAINER_SERVICE);
 
 		if(!SystemProperties.get("ro.boot.vm","1").equals("0")){
 			CellsPrivateServiceMgr mCellsService;
@@ -41,8 +45,8 @@ public class SecureSwitchActivity extends Activity {
 			String name = (SystemProperties.get("ro.boot.vm.name","").equals("cell1")?"cell2":"cell1");
 			try{
 				disableAdapter();
-				mCellsService.switchCellsVm("host");
 				//mCellsService.switchCellsVm(name);
+                mContainerManager.switchCellsVm(name);
 			}catch(RuntimeException e){
 				e.printStackTrace();
 			}
diff --git a/vendor/cells/cellsservice/Android.mk b/vendor/cells/cellsservice/Android.mk
index ae4b73406c..d60cb03456 100755
--- a/vendor/cells/cellsservice/Android.mk
+++ b/vendor/cells/cellsservice/Android.mk
@@ -12,7 +12,7 @@ LOCAL_SRC_FILES:= \
 	CellsPrivateService.cpp \
 	ICellsPrivateService.cpp \
 	main_cells.cpp \
-	cellnet.c
+	../cells/cellnet.c
 
 LOCAL_MODULE := cellsservice
 LOCAL_MODULE_TAGS := optional
@@ -52,7 +52,7 @@ include $(BUILD_EXECUTABLE)
 
 
 
-#sync
+#down
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
@@ -78,4 +78,18 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE_OWNER := cells
 #LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
 LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils liblog
+include $(BUILD_EXECUTABLE)
+
+#start
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	cellsstart.cpp \
+	ICellsPrivateService.cpp
+
+LOCAL_MODULE:= cellsstart
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := cells
+#LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
+LOCAL_SHARED_LIBRARIES := libm libcutils libc libbinder libutils libgui libpowermanager liblog libbase
 include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/vendor/cells/cellsservice/CellsPrivateService.cpp b/vendor/cells/cellsservice/CellsPrivateService.cpp
index 6b25664673..7f0b302b51 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/CellsPrivateService.cpp
@@ -13,6 +13,7 @@
 #include <cutils/log.h>
 #include <cutils/properties.h>
 #include "CellsPrivateService.h"
+#include "../cells/cellnet.h"
 
 #include <binder/IServiceManager.h>
 #include <gui/ISurfaceComposer.h>
@@ -70,8 +71,6 @@ status_t CellsPrivateService::setProperty(const String16& name,const String16& v
 
 status_t CellsPrivateService::startCellsVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc start %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("STARTCELLSVM cmd = %s", cmd);
@@ -81,8 +80,6 @@ status_t CellsPrivateService::startCellsVM(const String16& name)
 
 status_t CellsPrivateService::stopCellsVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc stop %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("STOPCELLSVM cmd = %s", cmd);
@@ -92,8 +89,6 @@ status_t CellsPrivateService::stopCellsVM(const String16& name)
 
 status_t CellsPrivateService::cellsSwitchVM(const String16& name)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc switch %s",String8(name).string());
     SYSTEMPRIVATE_LOGD("CELLSSWITCHVM cmd = %s", cmd);
@@ -102,10 +97,8 @@ status_t CellsPrivateService::cellsSwitchVM(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::cellsSwitchHOST(const String16& name)
+status_t CellsPrivateService::cellsSwitchHOST(const String16& /*name*/)
 {
-    name;
-
     char cmd[200];
     snprintf(cmd, sizeof(cmd), "cellc switch host");
     SYSTEMPRIVATE_LOGD("CELLSSWITCHHOST cmd = %s", cmd);
@@ -114,10 +107,8 @@ status_t CellsPrivateService::cellsSwitchHOST(const String16& name)
     return NO_ERROR;
 }
 
-static void* gotosleep(void* o)
+static void* gotosleep(void* /*o*/)
 {
-    o;
-
     {
         android::sp<android::IServiceManager> sm = android::defaultServiceManager();
         android::sp<android::os::IPowerManager> mPowerManager = 
@@ -147,8 +138,6 @@ static void create_gotosleep_pthread(void)
 status_t CellsPrivateService::switchCellsVM(const String16& name)
 {
     int i = 0;
-    char value[PROPERTY_VALUE_MAX];
-    char pname[PATH_MAX];
     char curname[PROPERTY_VALUE_MAX] = {0};
 
     property_get("ro.boot.vm.name", curname, "");
@@ -164,12 +153,17 @@ status_t CellsPrivateService::switchCellsVM(const String16& name)
     }
 
     if(strcmp(String8(name).string(), "host") != 0){
-        memset(value,0,PROPERTY_VALUE_MAX);
-        memset(pname,0,PATH_MAX);
-        sprintf(pname, "persist.sys.%s.init",  String8(name).string());
-        property_get(pname, value, "0");
-        if((strcmp(value, "0") == 0))
+        if(strcmp(curname, "") == 0){
+            if(isVMSystemReady(name) == 0)
+                return 0;
+        }
+
+        android::sp<android::IServiceManager> sm = android::initdefaultServiceManager();
+        android::sp<android::ICellsPrivateService> mCellsPrivateService = 
+        android::interface_cast<android::ICellsPrivateService>(sm->checkService(android::String16("CellsPrivateService")));
+        if(mCellsPrivateService != NULL && mCellsPrivateService->isVMSystemReady(name) == 0){
             return 0;
+        }
     }
 
     if(strcmp(curname, "") == 0){
@@ -230,23 +224,12 @@ status_t CellsPrivateService::switchCellsVM(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::enterHost(const String16& name)
+status_t CellsPrivateService::enterHost(const String16& /*name*/)
 {
-    name;
-
     {
         property_set("persist.sys.exit", "0");
     }
 
-    {
-        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
-        android::sp<android::ISurfaceComposer> mComposer = 
-            android::interface_cast<android::ISurfaceComposer>(sm->checkService(android::String16("SurfaceFlinger")));
-        if(mComposer != NULL){
-            mComposer->enterSelf();
-        }
-    }
-
     {
         android::sp<android::IServiceManager> sm = android::defaultServiceManager();
         android::sp<android::os::IPowerManager> mPowerManager = 
@@ -259,6 +242,15 @@ status_t CellsPrivateService::enterHost(const String16& name)
         }
     }
 
+    {
+        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
+        android::sp<android::ISurfaceComposer> mComposer = 
+            android::interface_cast<android::ISurfaceComposer>(sm->checkService(android::String16("SurfaceFlinger")));
+        if(mComposer != NULL){
+            mComposer->enterSelf();
+        }
+    }
+
     {
         property_set("ctl.restart", "adbd");
     }
@@ -275,10 +267,8 @@ status_t CellsPrivateService::enterHost(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::exitHost(const String16& name)
+status_t CellsPrivateService::exitHost(const String16& /*name*/)
 {
-    name;
-
     {
         property_set("persist.sys.exit", "1");
     }
@@ -315,10 +305,8 @@ static void write_vm_exit(bool bexit){
     }
 }
 
-status_t CellsPrivateService::enterCell(const String16& name)
+status_t CellsPrivateService::enterCell(const String16& /*name*/)
 {
-    name;
-
     {
         write_vm_exit(false);
         property_set("persist.sys.exit", "0");
@@ -329,7 +317,10 @@ status_t CellsPrivateService::enterCell(const String16& name)
         android::sp<android::os::IPowerManager> mPowerManager = 
             android::interface_cast<android::os::IPowerManager>(sm->checkService(android::String16("power")));
         if(mPowerManager != NULL){
-            mPowerManager->goToSleep(long(ns2ms(systemTime())),android::os::IPowerManager::GO_TO_SLEEP_REASON_POWER_BUTTON,0);
+            mPowerManager->wakeUp(long(ns2ms(systemTime())),WAKE_REASON_POWER_BUTTON,
+                            android::String16("enter_self"),android::String16("CellsPrivateService"));
+        }else{
+            SYSTEMPRIVATE_LOGD("mPowerManager = 0");
         }
     }
 
@@ -342,18 +333,6 @@ status_t CellsPrivateService::enterCell(const String16& name)
         }
     }
 
-    {
-        android::sp<android::IServiceManager> sm = android::defaultServiceManager();
-        android::sp<android::os::IPowerManager> mPowerManager = 
-            android::interface_cast<android::os::IPowerManager>(sm->checkService(android::String16("power")));
-        if(mPowerManager != NULL){
-            mPowerManager->wakeUp(long(ns2ms(systemTime())),WAKE_REASON_POWER_BUTTON,
-                            android::String16("enter_self"),android::String16("CellsPrivateService"));
-        }else{
-            SYSTEMPRIVATE_LOGD("mPowerManager = 0");
-        }
-    }
-
     {
         property_set("ctl.restart", "adbd");
     }
@@ -366,10 +345,8 @@ status_t CellsPrivateService::enterCell(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::exitCell(const String16& name)
+status_t CellsPrivateService::exitCell(const String16& /*name*/)
 {
-    name;
-
     {
         write_vm_exit(true);
         property_set("persist.sys.exit", "1");
@@ -396,39 +373,28 @@ status_t CellsPrivateService::exitCell(const String16& name)
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::uploadCellsVM(const String16& name)
+status_t CellsPrivateService::uploadCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::downloadCellsVM(const String16& name)
+status_t CellsPrivateService::downloadCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::untarCellsVM(const String16& name)
+status_t CellsPrivateService::untarCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::tarCellsVM(const String16& name)
+status_t CellsPrivateService::tarCellsVM(const String16& /*name*/)
 {
-    name;
-
     return NO_ERROR;
 }
 
-status_t CellsPrivateService::sendCellsVM(const String16& path, const String16& address)
+status_t CellsPrivateService::sendCellsVM(const String16& /*path*/, const String16& /*address*/)
 {
-    path;
-    address;
-
     return NO_ERROR;
 }
 
@@ -480,16 +446,40 @@ status_t CellsPrivateService::cfgNetProxy(int32_t sysid, const String16& ifName,
 status_t CellsPrivateService::vmSystemReady(const String16& name)
 {
     char pname[PATH_MAX] = {0};
+    int i = 0;
 
     sprintf(pname, "persist.sys.%s.init",  String8(name).string());
     property_set(pname, "1");
 
     property_set("ctl.restart", "adbd");
 
-    chown("/dev/sg1", 1000, 1000);
+    sscanf(String8(name).string(), "cell%d",&i);
+    starttether(i);
+
+    //chown("/dev/sg1", 1000, 1000);
 
     SYSTEMPRIVATE_LOGD("SYSTEMREADY name = %s", String8(name).string());
     return NO_ERROR;
 }
 
+status_t CellsPrivateService::isVMSystemReady(const String16& name)
+{
+    char pname[PATH_MAX] = {0};
+    char value[PROPERTY_VALUE_MAX] = {0};
+
+    status_t ret = 0;
+    if(strcmp(String8(name).string(), "host") == 0){
+        ret = 1;
+    }
+
+    sprintf(pname, "persist.sys.%s.init",  String8(name).string());
+    property_get(pname, value, "0");
+    if(strcmp(String8(value).string(), "1") == 0){
+        ret = 1;
+    }
+
+    SYSTEMPRIVATE_LOGD("ISVMSYSTEMREADY name = %s ret = %d", String8(name).string(), ret);
+    return ret;
+}
+
 };
diff --git a/vendor/cells/cellsservice/CellsPrivateService.h b/vendor/cells/cellsservice/CellsPrivateService.h
index edcf3b5c9b..4045623192 100755
--- a/vendor/cells/cellsservice/CellsPrivateService.h
+++ b/vendor/cells/cellsservice/CellsPrivateService.h
@@ -39,6 +39,7 @@ public:
     virtual status_t vmSystemReady(const String16& name);
     virtual status_t sendCellsVM(const String16& path, const String16& address);
     virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop);
+	virtual status_t isVMSystemReady(const String16& name);
 
     int isInCellstar();
     void setCellstaring();
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.cpp b/vendor/cells/cellsservice/ICellsPrivateService.cpp
index 1a6ff6eb35..0a075ebf37 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.cpp
+++ b/vendor/cells/cellsservice/ICellsPrivateService.cpp
@@ -264,6 +264,20 @@ public:
         result = reply.readInt32();
         return result;
     }
+	
+	virtual status_t isVMSystemReady(const String16& name)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICellsPrivateService::getInterfaceDescriptor());
+        data.writeString16(name);
+        status_t result = remote()->transact(ISVMACTIVE, data, &reply);
+        if (result != NO_ERROR) {
+            ALOGE("isVMSystemReady VM err!\n");
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
 };
 
 IMPLEMENT_META_INTERFACE(CellsPrivateService, "CellsPrivateService");
@@ -445,6 +459,16 @@ status_t BnCellsPrivateService::onTransact(uint32_t code, const Parcel& data, Pa
             reply->writeInt32(result);
             return NO_ERROR;
         }
+        break;
+		case ISVMACTIVE:
+        {
+            CHECK_INTERFACE(ICellsPrivateService, data, reply);
+            String16 name = data.readString16();
+
+            status_t result = isVMSystemReady(name);
+            reply->writeInt32(result);
+            return NO_ERROR;
+        }
         break;
     }
     return BBinder::onTransact(code, data, reply, flags);
diff --git a/vendor/cells/cellsservice/ICellsPrivateService.h b/vendor/cells/cellsservice/ICellsPrivateService.h
index acc20322bf..34bd314f29 100755
--- a/vendor/cells/cellsservice/ICellsPrivateService.h
+++ b/vendor/cells/cellsservice/ICellsPrivateService.h
@@ -32,6 +32,7 @@ protected:
         EXITHOST = IBinder::FIRST_CALL_TRANSACTION + 14,
         SENDCELLSVM = IBinder::FIRST_CALL_TRANSACTION + 15,
         CFG_NET_PROXY = IBinder::FIRST_CALL_TRANSACTION + 16,
+		ISVMACTIVE = IBinder::FIRST_CALL_TRANSACTION + 17,
     };
 
 public:
@@ -54,6 +55,7 @@ public:
     virtual status_t vmSystemReady(const String16& name) = 0;
     virtual status_t sendCellsVM(const String16& path, const String16& address) = 0;
     virtual status_t cfgNetProxy(int32_t sysid, const String16& ifName, const String16& dest, const String16& nexthop) = 0;
+	virtual status_t isVMSystemReady(const String16& name) = 0;
 };
 
 class BnCellsPrivateService : public BnInterface<ICellsPrivateService>
diff --git a/vendor/cells/cellsservice/cellnet.h b/vendor/cells/cellsservice/cellnet.h
deleted file mode 100755
index bcc4e67414..0000000000
--- a/vendor/cells/cellsservice/cellnet.h
+++ /dev/null
@@ -1,21 +0,0 @@
-
-#ifndef __CELLNET_H
-#define __CELLNET_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern void init_cell_net();
-extern void createveth(int index);
-extern void vethtons(int pid,int index);
-extern void rnameveth(int index);
-extern void starttether(int index);
-extern void stoptether(int index);
-extern void delveth(int index);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CELLNET_H */
diff --git a/vendor/cells/cellsservice/cellsstart.cpp b/vendor/cells/cellsservice/cellsstart.cpp
new file mode 100755
index 0000000000..956a791750
--- /dev/null
+++ b/vendor/cells/cellsservice/cellsstart.cpp
@@ -0,0 +1,75 @@
+#define LOG_TAG "CELLSSTART"
+#include <stdio.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/select.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <binder/BinderService.h>
+#include <android-base/properties.h>
+#include "ICellsPrivateService.h"
+
+using namespace android;
+
+int main(int /*argc*/, char** /*argv*/)
+{
+	property_set("persist.sys.ui.exit", "1");
+	property_set("persist.sys.iw.wlan", "cell1");
+
+	const sp<IServiceManager> sm = defaultServiceManager();
+	sp<ICellsPrivateService> pCellsPrivateService = NULL;
+	if (sm != NULL)
+	{
+		sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
+        while(binder == NULL){
+            sleep(1);
+
+            binder = sm->checkService(String16("CellsPrivateService"));
+        }
+
+        pCellsPrivateService = interface_cast<ICellsPrivateService>(binder);
+        if(pCellsPrivateService == NULL){
+            ALOGE("could not get service CellsPrivateService");
+            return 0;
+        }
+	}
+
+	sleep(1);
+
+	if(android::base::GetProperty("persist.sys.cell1.init", "0") == std::string("0"))
+	{
+		ALOGD("Start cell1");
+		pCellsPrivateService->startCellsVM(android::String16("cell1"));
+		ALOGD("Started cell1");
+	}
+
+	property_set("persist.sys.active", "cell1");
+
+	if(android::base::GetProperty("persist.sys.cell2.init", "0") == std::string("0"))
+	{
+		ALOGD("Start cell2");
+		pCellsPrivateService->startCellsVM(android::String16("cell2"));
+		ALOGD("Started cell2");
+	}
+
+	while(android::base::GetProperty("persist.sys.cell1.init", "0") == std::string("0"))
+	{
+		sleep(3);
+	}
+
+	ALOGD("Switch cell1");
+	pCellsPrivateService->switchCellsVM(android::String16("cell1"));
+	ALOGD("Switched cell1");
+
+    return 0;
+}
diff --git a/vendor/cells/cellsservice/cellssync.cpp b/vendor/cells/cellsservice/cellssync.cpp
index 752fa0fa9b..14bc56d186 100755
--- a/vendor/cells/cellsservice/cellssync.cpp
+++ b/vendor/cells/cellsservice/cellssync.cpp
@@ -8,7 +8,7 @@ using namespace android;
 
 int main(int argc, char** argv)
 {
-    /*const sp<IServiceManager> sm = initdefaultServiceManager();
+    const sp<IServiceManager> sm = initdefaultServiceManager();
     if (sm != NULL) {
         sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
         if (binder != NULL) {
@@ -26,7 +26,7 @@ int main(int argc, char** argv)
                 pCellsPrivateService->setProperty(android::String16(argv[1]),android::String16(argv[2]));
             }
         }
-    }*/
+    }
 
     return 0;
 }
diff --git a/vendor/cells/cellsservice/cswitch.cpp b/vendor/cells/cellsservice/cswitch.cpp
index 5d0d3ef1cb..bc23476900 100755
--- a/vendor/cells/cellsservice/cswitch.cpp
+++ b/vendor/cells/cellsservice/cswitch.cpp
@@ -8,7 +8,7 @@ using namespace android;
 
 int main(int argc, char** argv)
 {
-   const sp<IServiceManager> sm = defaultServiceManager();
+    const sp<IServiceManager> sm = defaultServiceManager();
     if (sm != NULL) {
         sp<IBinder> binder = sm->checkService(String16("CellsPrivateService"));
         if (binder != NULL) {
diff --git a/vendor/cells/cellsservice/main_cells.cpp b/vendor/cells/cellsservice/main_cells.cpp
index af007c3a5c..b93b66e6e8 100755
--- a/vendor/cells/cellsservice/main_cells.cpp
+++ b/vendor/cells/cellsservice/main_cells.cpp
@@ -7,11 +7,11 @@
 #include <binder/BinderService.h>
 #include <CellsPrivateService.h>
 
-#include "cellnet.h"
+#include "../cells/cellnet.h"
 
 using namespace android;
 
-/*static int get_vm_index()
+static int get_vm_index()
 {
 	int index = 0;
 	char value[PROPERTY_VALUE_MAX] = {0};
@@ -20,7 +20,7 @@ using namespace android;
 
 	ALOGD("VM Index = %d", index);
 	return index;
-}*/
+}
 
 int main(int /*argc*/, char** /*argv*/)
 {
@@ -32,18 +32,28 @@ int main(int /*argc*/, char** /*argv*/)
 		//property_set("persist.sys.exit", "0");
 		//property_set("persist.sys.active", "");
 
-		property_set("ctl.stop", "vendor.adsprpcd");
-		property_set("ctl.stop", "vendor.sensors");
+		//property_set("ctl.stop", "vendor.qcrild");
+		//property_set("ctl.stop", "vendor.qcrild2");
+		//property_set("ctl.stop", "vendor.qcrild3");
+		//property_set("ctl.stop", "vendor.adsprpcd");
+		//property_set("ctl.stop", "vendor.sensors");
+
+		property_set("ctl.start", "cellsstart");
 	}else{
-		property_set("ctl.stop", "vendor.adsprpcd");
-		property_set("ctl.stop", "vendor.sensors");
-		property_set("ctl.stop", "adbd");
+		//property_set("ctl.stop", "vendor.qcrild");
+		//property_set("ctl.stop", "vendor.qcrild2");
+		//property_set("ctl.stop", "vendor.qcrild3");
+		//property_set("ctl.stop", "vendor.adsprpcd");
+		//property_set("ctl.stop", "vendor.sensors");
+		//property_set("ctl.stop", "adbd");
 		//property_set("persist.sys.exit", "1");
-
-		/*int i = get_vm_index();
-		if(i > 0){
-			rnameveth(i);
-		}*/
+		
+		int i = get_vm_index();
+		if(i == 1){
+			property_set("persist.sys.cells.netagent", "cell1");
+		}else if (i == 2){
+			property_set("persist.sys.cells.netagent", "cell2");
+		}
 	}
 
 	CellsPrivateService::publishAndJoinThreadPool(true);
-- 
2.17.1

From d8e2c3b72c907c3e09162da23eeffa1b09748558 Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Sat, 3 Sep 2022 14:22:38 +0800
Subject: [PATCH 09/11] fix rmnet wlan conflict

---
 system/netd/server/NetdNativeService.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/system/netd/server/NetdNativeService.cpp b/system/netd/server/NetdNativeService.cpp
index 85359f5e4e..f1eb3fb091 100755
--- a/system/netd/server/NetdNativeService.cpp
+++ b/system/netd/server/NetdNativeService.cpp
@@ -1069,8 +1069,10 @@ binder::Status NetdNativeService::networkAddRouteParcel(int32_t netId,
     const char *gw = nullptr;
     char cmd[MAX_CMD_LEN];
 
-    if (-1 != sys_id) {
+    int is_rmnet = !strncmp("rmnet", route.ifName.c_str(), strlen("rmnet"));
+    if (-1 != sys_id && is_rmnet) {
         //cells
+        system("ip rule add from all lookup main prio 31999");// NOLINT(cert-env33-c)
         //config vnet ip
         snprintf(cmd, sizeof(cmd), "ifconfig %s %s netmask %s up",
             route.ifName.c_str(),
-- 
2.17.1

From 6954f9300cd5b514cea1a2e7a4b36147f3b07377 Mon Sep 17 00:00:00 2001
From: lxl <lxl@xdja.com>
Date: Mon, 5 Sep 2022 09:23:46 +0800
Subject: [PATCH 10/11] commit missing code int patch:xdja-container-20220829
 from jianglin

---
 system/core/rootdir/init.rc | 1 -
 1 file changed, 1 deletion(-)

diff --git a/system/core/rootdir/init.rc b/system/core/rootdir/init.rc
index a898c16d91..8a370d335d 100644
--- a/system/core/rootdir/init.rc
+++ b/system/core/rootdir/init.rc
@@ -459,7 +459,6 @@ on init
     start servicemanager
     start hwservicemanager
     start vndservicemanager
-    start cellsservice
 
 # Healthd can trigger a full boot from charger mode by signaling this
 # property when the power button is held.
-- 
2.17.1

From e77ccea35e09a1caa078f4b0f804334f33ddb3dd Mon Sep 17 00:00:00 2001
From: tanshuai <tanshuai@xdja.com>
Date: Mon, 5 Sep 2022 22:48:58 +0800
Subject: [PATCH 11/11] radio hal proxy ok

---
 .../com/android/internal/telephony/RIL.java   |   23 +-
 .../radio/1.6/radio_hal_proxy/Android.bp      |   73 +
 .../RadioIndication_V1_6_Proxy.cpp            |  706 ++++++
 .../RadioIndication_V1_6_Proxy.h              |  185 ++
 .../RadioResponse_V1_6_Proxy.cpp              | 1899 +++++++++++++++++
 .../RadioResponse_V1_6_Proxy.h                |  449 ++++
 .../radio/1.6/radio_hal_proxy/proxy_common.h  |    3 +
 .../radio_hal_proxy/radio_hidl_hal_proxy.cpp  |  152 ++
 .../radio_hal_proxy/ril_service_1_6_proxy.cpp | 1078 ++++++++++
 .../radio_hal_proxy/ril_service_1_6_proxy.h   |  482 +++++
 10 files changed, 5040 insertions(+), 10 deletions(-)
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
 create mode 100755 hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h

diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
index 56c81d1da3..bdbb532288 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
@@ -299,7 +299,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     //***** Constants
 
     static final String[] HIDL_SERVICE_NAME = {"slot1", "slot2", "slot3"};
-
+    static final String[] HIDL_SERVICE_NAME_PROXY = {"slot1_proxy", "slot2_proxy", "slot3_proxy"};
     static final int IRADIO_GET_SERVICE_DELAY_MILLIS = 4 * 1000;
 
     static final String EMPTY_ALPHA_LONG = "";
@@ -493,20 +493,22 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         try {
             if (mDisabledRadioServices.contains(mPhoneId)) {
-                riljLoge("getRadioProxy: mRadioProxy for " + HIDL_SERVICE_NAME[mPhoneId]
+                riljLoge("getRadioProxy: mRadioProxy for " + HIDL_SERVICE_NAME_PROXY[mPhoneId]
                         + " is disabled");
             } else {
                 try {
                     mRadioProxy = android.hardware.radio.V1_6.IRadio.getService(
-                            HIDL_SERVICE_NAME[mPhoneId], true);
+                            HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                     mRadioVersion = RADIO_HAL_VERSION_1_6;
                 } catch (NoSuchElementException e) {
                 }
 
                 if (mRadioProxy == null) {
+                    riljLoge("getRadioProxy: mRadioProxy for android.hardware.radio.V1_6.IRadio " + HIDL_SERVICE_NAME_PROXY[mPhoneId]
+                        + " is fail");
                     try {
                         mRadioProxy = android.hardware.radio.V1_5.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_5;
                     } catch (NoSuchElementException e) {
                     }
@@ -515,7 +517,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_4.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_4;
                     } catch (NoSuchElementException e) {
                     }
@@ -524,7 +526,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_3.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_3;
                     } catch (NoSuchElementException e) {
                     }
@@ -533,7 +535,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_2.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_2;
                     } catch (NoSuchElementException e) {
                     }
@@ -542,7 +544,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_1.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_1;
                     } catch (NoSuchElementException e) {
                     }
@@ -551,7 +553,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy == null) {
                     try {
                         mRadioProxy = android.hardware.radio.V1_0.IRadio.getService(
-                                HIDL_SERVICE_NAME[mPhoneId], true);
+                                HIDL_SERVICE_NAME_PROXY[mPhoneId], true);
                         mRadioVersion = RADIO_HAL_VERSION_1_0;
                     } catch (NoSuchElementException e) {
                     }
@@ -560,11 +562,12 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (mRadioProxy != null) {
                     mRadioProxy.linkToDeath(mRadioProxyDeathRecipient,
                             mRadioProxyCookie.incrementAndGet());
+                    riljLoge("gwb call mRadioProxy.setResponseFunctions");
                     mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
                 } else {
                     mDisabledRadioServices.add(mPhoneId);
                     riljLoge("getRadioProxy: mRadioProxy for "
-                            + HIDL_SERVICE_NAME[mPhoneId] + " is disabled");
+                            + HIDL_SERVICE_NAME_PROXY[mPhoneId] + " is disabled");
                 }
             }
         } catch (RemoteException e) {
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp b/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
new file mode 100755
index 0000000000..434ea4a8b2
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/Android.bp
@@ -0,0 +1,73 @@
+//
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "hardware_interfaces_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["hardware_interfaces_license"],
+}
+
+cc_defaults {
+    name: "HidlProxyDefaults",
+    defaults: [
+        "hidl_defaults",
+    ],
+
+    // Lists all dependencies that can *not* be expected on the device.
+    static_libs: [
+        "libhidl-gen-utils",
+    ],
+
+    group_static_libs: true,
+
+    // Lists all system dependencies that can be expected on the device.
+    shared_libs: [
+        "libbase",
+        // All the following are dependencies of any HAL definition library.
+        "libcutils",
+        "liblog",
+        "libhidlbase",
+        "libutils",
+    ],
+
+    require_root: true,
+}
+
+cc_binary {
+    name: "radio_hal_proxy",
+    defaults: ["HidlProxyDefaults"],
+    srcs: [
+        "radio_hidl_hal_proxy.cpp",
+        "RadioIndication_V1_6_Proxy.cpp",
+        "RadioResponse_V1_6_Proxy.cpp",
+        "ril_service_1_6_proxy.cpp",
+    ],
+    static_libs: [
+        "android.hardware.radio@1.6",
+        "android.hardware.radio@1.5",
+        "android.hardware.radio@1.4",
+        "android.hardware.radio@1.3",
+        "android.hardware.radio@1.2",
+        "android.hardware.radio@1.1",
+        "android.hardware.radio@1.0",
+        "android.hardware.radio.config@1.0",
+        "android.hardware.radio.config@1.1",
+    ],
+    header_libs: ["radio.util.header@1.0"],
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
new file mode 100755
index 0000000000..66d12ee39d
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.cpp
@@ -0,0 +1,706 @@
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include "RadioIndication_V1_6_Proxy.h"
+
+
+RadioIndication_v1_6_Proxy::RadioIndication_v1_6_Proxy() {
+    for (int32_t sysId = 0; sysId < MAX_SYS_NUM; sysId++) {
+        mRadioIndication[sysId] = nullptr;
+    }
+}
+
+int32_t RadioIndication_v1_6_Proxy::setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioIndication> radioIndication) {
+    int32_t i = 0;
+
+    if (sysId >= MAX_SYS_NUM) {
+        RLOGE("RadioIndication_v1_6_Proxy::setCallback SysId=%d Error!", sysId);
+        return -1;
+    }
+
+    if (-1 != sysId) {
+        mRadioIndication[sysId] = radioIndication;
+        return sysId;
+    }
+
+    //get a free slot
+    for (i = 0; i < MAX_SYS_NUM; i++) {
+        if (nullptr == mRadioIndication[i]) {
+            break;
+        }
+    }
+
+    if (i >= MAX_SYS_NUM) {
+        RLOGE("[RadioIndication_v1_6_Proxy::setCallback] no free slot!");
+        return -1;
+    }
+
+    mRadioIndication[i] = radioIndication;
+    return i;
+}
+
+
+Return<void> RadioIndication_v1_6_Proxy::radioStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioState radioState) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->radioStateChanged(type, radioState);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::callStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->callStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSms(type, pdu);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSmsStatusReport(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSmsStatusReport(type, pdu);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newSmsOnSim(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t recordNumber) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newSmsOnSim(type, recordNumber);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::onUssd(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::UssdModeType modeType, const ::android::hardware::hidl_string& msg) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->onUssd(type, modeType, msg);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::nitzTimeReceived(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& nitzTime, uint64_t receivedTime) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->nitzTimeReceived(type, nitzTime, receivedTime);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::suppSvcNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SuppSvcNotification& suppSvc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->suppSvcNotify(type, suppSvc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkSessionEnd(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkSessionEnd(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkProactiveCommand(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkProactiveCommand(type, cmd);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkEventNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkEventNotify(type, cmd);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkCallSetup(::android::hardware::radio::V1_0::RadioIndicationType type, int64_t timeout) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkCallSetup(type, timeout);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simSmsStorageFull(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simRefresh(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SimRefreshResult& refreshResult) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simRefresh(type, refreshResult);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::callRing(::android::hardware::radio::V1_0::RadioIndicationType type, bool isGsm, const ::android::hardware::radio::V1_0::CdmaSignalInfoRecord& record) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->callRing(type, isGsm, record);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simStatusChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaNewSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaSmsMessage& msg) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaNewSms(type, msg);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::newBroadcastSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& data) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->newBroadcastSms(type, data);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaRuimSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaRuimSmsStorageFull(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::restrictedStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::PhoneRestrictedState state) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->restrictedStateChanged(type, state);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::enterEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->enterEmergencyCallbackMode(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaCallWaiting(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaCallWaiting& callWaitingRecord) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaCallWaiting(type, callWaitingRecord);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaOtaProvisionStatus(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaOtaProvisionStatus status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaOtaProvisionStatus(type, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaInfoRec(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaInformationRecords& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaInfoRec(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::indicateRingbackTone(::android::hardware::radio::V1_0::RadioIndicationType type, bool start) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->indicateRingbackTone(type, start);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::resendIncallMute(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->resendIncallMute(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaSubscriptionSourceChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSource) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaSubscriptionSourceChanged(type, cdmaSource);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cdmaPrlChanged(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t version) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cdmaPrlChanged(type, version);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::exitEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->exitEmergencyCallbackMode(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::rilConnected(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->rilConnected(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::voiceRadioTechChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioTechnology rat) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->voiceRadioTechChanged(type, rat);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::imsNetworkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->imsNetworkStateChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::subscriptionStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool activate) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->subscriptionStatusChanged(type, activate);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::srvccStateNotify(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::SrvccState state) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->srvccStateNotify(type, state);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::hardwareConfigChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->hardwareConfigChanged(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::radioCapabilityIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->radioCapabilityIndication(type, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::onSupplementaryServiceIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::StkCcUnsolSsResult& ss) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->onSupplementaryServiceIndication(type, ss);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::stkCallControlAlphaNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& alpha) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->stkCallControlAlphaNotify(type, alpha);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::lceData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::LceDataInfo& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->lceData(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::pcoData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::PcoDataInfo& pco) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->pcoData(type, pco);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::modemReset(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& reason) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->modemReset(type, reason);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::carrierInfoForImsiEncryption(::android::hardware::radio::V1_0::RadioIndicationType info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->carrierInfoForImsiEncryption(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::keepaliveStatus(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::KeepaliveStatus& status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->keepaliveStatus(type, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_2(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_2(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentLinkCapacityEstimate(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::LinkCapacityEstimate& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentLinkCapacityEstimate(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_2(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentEmergencyNumberList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::EmergencyNumber>& emergencyNumberList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentEmergencyNumberList(type, emergencyNumberList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_4(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_4(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs_1_4(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_4(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_4(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::uiccApplicationsEnablementChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool enabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->uiccApplicationsEnablementChanged(type, enabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::registrationFailed(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_string& chosenPlmn, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::Domain> domain, int32_t causeCode, int32_t additionalCauseCode) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->registrationFailed(type, cellIdentity, chosenPlmn, domain, causeCode, additionalCauseCode);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::barringInfoChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->barringInfoChanged(type, cellIdentity, barringInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_5(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_5(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_5(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::dataCallListChanged_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcList) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->dataCallListChanged_1_6(type, dcList);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::unthrottleApn(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& apn) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->unthrottleApn(type, apn);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentLinkCapacityEstimate_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::LinkCapacityEstimate& lce) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentLinkCapacityEstimate_1_6(type, lce);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentSignalStrength_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentSignalStrength_1_6(type, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::cellInfoList_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->cellInfoList_1_6(type, records);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::networkScanResult_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::NetworkScanResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->networkScanResult_1_6(type, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::currentPhysicalChannelConfigs_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhysicalChannelConfig>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->currentPhysicalChannelConfigs_1_6(type, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simPhonebookChanged(::android::hardware::radio::V1_0::RadioIndicationType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simPhonebookChanged(type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioIndication_v1_6_Proxy::simPhonebookRecordsReceived(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_6::PbReceivedStatus status, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhonebookRecordInfo>& records) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioIndication[i] != nullptr) {
+            mRadioIndication[i]->simPhonebookRecordsReceived(type, status, records);
+        }
+    }
+    return Void();
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
new file mode 100755
index 0000000000..2298a5ca83
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioIndication_V1_6_Proxy.h
@@ -0,0 +1,185 @@
+#pragma once
+
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/types.h>
+#include "proxy_common.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+class RadioIndication_v1_6_Proxy : public ::android::hardware::radio::V1_6::IRadioIndication {
+  private:
+    sp<::android::hardware::radio::V1_6::IRadioIndication> mRadioIndication[MAX_SYS_NUM];
+
+  public:
+    RadioIndication_v1_6_Proxy();
+    virtual ~RadioIndication_v1_6_Proxy() = default;
+
+    //static ::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioIndication>> castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& parent, bool emitError = false) {
+    //    return ::android::sp<::android::hardware::radio::V1_6::IRadioIndication>(static_cast<::android::hardware::radio::V1_6::IRadioIndication*>(parent.get()));
+    //}
+
+    int32_t setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioIndication> radioIndication);
+        
+    Return<void> radioStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioState radioState);
+
+    Return<void> callStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> networkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> newSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu);
+
+    Return<void> newSmsStatusReport(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& pdu);
+
+    Return<void> newSmsOnSim(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t recordNumber);
+
+    Return<void> onUssd(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::UssdModeType modeType, const ::android::hardware::hidl_string& msg);
+
+    Return<void> nitzTimeReceived(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& nitzTime, uint64_t receivedTime);
+
+    Return<void> currentSignalStrength(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SignalStrength& signalStrength);
+
+    Return<void> dataCallListChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcList);
+
+    Return<void> suppSvcNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SuppSvcNotification& suppSvc);
+
+    Return<void> stkSessionEnd(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> stkProactiveCommand(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd);
+
+    Return<void> stkEventNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& cmd);
+
+    Return<void> stkCallSetup(::android::hardware::radio::V1_0::RadioIndicationType type, int64_t timeout);
+
+    Return<void> simSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> simRefresh(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::SimRefreshResult& refreshResult);
+
+    Return<void> callRing(::android::hardware::radio::V1_0::RadioIndicationType type, bool isGsm, const ::android::hardware::radio::V1_0::CdmaSignalInfoRecord& record);
+
+    Return<void> simStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaNewSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaSmsMessage& msg);
+
+    Return<void> newBroadcastSms(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<uint8_t>& data);
+
+    Return<void> cdmaRuimSmsStorageFull(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> restrictedStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::PhoneRestrictedState state);
+
+    Return<void> enterEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaCallWaiting(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaCallWaiting& callWaitingRecord);
+
+    Return<void> cdmaOtaProvisionStatus(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaOtaProvisionStatus status);
+
+    Return<void> cdmaInfoRec(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::CdmaInformationRecords& records);
+
+    Return<void> indicateRingbackTone(::android::hardware::radio::V1_0::RadioIndicationType type, bool start);
+
+    Return<void> resendIncallMute(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> cdmaSubscriptionSourceChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSource);
+
+    Return<void> cdmaPrlChanged(::android::hardware::radio::V1_0::RadioIndicationType type, int32_t version);
+
+    Return<void> exitEmergencyCallbackMode(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> rilConnected(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> voiceRadioTechChanged(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::RadioTechnology rat);
+
+    Return<void> cellInfoList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& records);
+
+    Return<void> imsNetworkStateChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> subscriptionStatusChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool activate);
+
+    Return<void> srvccStateNotify(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_0::SrvccState state);
+
+    Return<void> hardwareConfigChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& configs);
+
+    Return<void> radioCapabilityIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> onSupplementaryServiceIndication(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::StkCcUnsolSsResult& ss);
+
+    Return<void> stkCallControlAlphaNotify(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& alpha);
+
+    Return<void> lceData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::LceDataInfo& lce);
+
+    Return<void> pcoData(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_0::PcoDataInfo& pco);
+
+    Return<void> modemReset(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& reason);
+
+    Return<void> carrierInfoForImsiEncryption(::android::hardware::radio::V1_0::RadioIndicationType info);
+
+    Return<void> networkScanResult(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::NetworkScanResult& result);
+
+    Return<void> keepaliveStatus(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_1::KeepaliveStatus& status);
+
+    Return<void> networkScanResult_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::NetworkScanResult& result);
+
+    Return<void> cellInfoList_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& records);
+
+    Return<void> currentLinkCapacityEstimate(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::LinkCapacityEstimate& lce);
+
+    Return<void> currentPhysicalChannelConfigs(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::PhysicalChannelConfig>& configs);
+
+    Return<void> currentSignalStrength_1_2(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength);
+
+    Return<void> currentEmergencyNumberList(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::EmergencyNumber>& emergencyNumberList);
+
+    Return<void> cellInfoList_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& records);
+
+    Return<void> networkScanResult_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::NetworkScanResult& result);
+
+    Return<void> currentPhysicalChannelConfigs_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::PhysicalChannelConfig>& configs);
+
+    Return<void> dataCallListChanged_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcList);
+
+    Return<void> currentSignalStrength_1_4(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength);
+
+    Return<void> uiccApplicationsEnablementChanged(::android::hardware::radio::V1_0::RadioIndicationType type, bool enabled);
+
+    Return<void> registrationFailed(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_string& chosenPlmn, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::Domain> domain, int32_t causeCode, int32_t additionalCauseCode);
+
+    Return<void> barringInfoChanged(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos);
+
+    Return<void> cellInfoList_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& records);
+
+    Return<void> networkScanResult_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_5::NetworkScanResult& result);
+
+    Return<void> dataCallListChanged_1_5(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcList);
+
+    Return<void> dataCallListChanged_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcList);
+
+    Return<void> unthrottleApn(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_string& apn);
+
+    Return<void> currentLinkCapacityEstimate_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::LinkCapacityEstimate& lce);
+
+    Return<void> currentSignalStrength_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength);
+
+    Return<void> cellInfoList_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& records);
+
+    Return<void> networkScanResult_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::radio::V1_6::NetworkScanResult& result);
+
+    Return<void> currentPhysicalChannelConfigs_1_6(::android::hardware::radio::V1_0::RadioIndicationType type, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhysicalChannelConfig>& configs);
+
+    Return<void> simPhonebookChanged(::android::hardware::radio::V1_0::RadioIndicationType type);
+
+    Return<void> simPhonebookRecordsReceived(::android::hardware::radio::V1_0::RadioIndicationType type, ::android::hardware::radio::V1_6::PbReceivedStatus status, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::PhonebookRecordInfo>& records);
+
+};
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
new file mode 100755
index 0000000000..7084e41ebd
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.cpp
@@ -0,0 +1,1899 @@
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include "RadioResponse_V1_6_Proxy.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+RadioResponse_v1_6_Proxy::RadioResponse_v1_6_Proxy() {
+    for (int32_t sysId = 0; sysId < MAX_SYS_NUM; sysId++) {
+        mRadioResponse[sysId] = nullptr;
+    }
+}
+
+int32_t RadioResponse_v1_6_Proxy::setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioResponse> radioResponse) {
+    int32_t i = 0;
+
+    if (sysId >= MAX_SYS_NUM) {
+        RLOGE("RadioResponse_v1_6_Proxy::setCallback SysId=%d Error!", sysId);
+        return -1;
+    }
+
+    if (-1 != sysId) {
+        mRadioResponse[sysId] = radioResponse;
+        return sysId;
+    }
+
+    //get a free slot
+    for (i = 0; i < MAX_SYS_NUM; i++) {
+        if (nullptr == mRadioResponse[i]) {
+            break;
+        }
+    }
+
+    if (i >= MAX_SYS_NUM) {
+        RLOGE("[RadioResponse_v1_6_Proxy::setCallback] no free slot!");
+        return -1;
+    }
+
+    mRadioResponse[i] = radioResponse;
+    return i;
+}
+
+
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPinForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPukForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPukForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPin2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyIccPuk2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyIccPuk2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::changeIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->changeIccPinForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::changeIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->changeIccPin2ForAppResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplyNetworkDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplyNetworkDepersonalizationResponse(info, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::dialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->dialResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIMSIForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imsi) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIMSIForAppResponse(info, imsi);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupConnectionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupWaitingOrBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupWaitingOrBackgroundResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::hangupForegroundResumeBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->hangupForegroundResumeBackgroundResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::switchWaitingOrHoldingAndActiveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->switchWaitingOrHoldingAndActiveResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::conferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->conferenceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::rejectCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->rejectCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getLastCallFailCauseResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LastCallFailCauseInfo& failCauseinfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getLastCallFailCauseResponse(info, failCauseinfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SignalStrength& sigStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse(info, sigStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::VoiceRegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getOperatorResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& longName, const ::android::hardware::hidl_string& shortName, const ::android::hardware::hidl_string& numeric) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getOperatorResponse(info, longName, shortName, numeric);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSMSExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSMSExpectMoreResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccIOForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccIOForAppResponse(info, iccIo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendUssdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::cancelPendingUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->cancelPendingUssdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t n, int32_t m) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getClirResponse(info, n, m);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setClirResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCallForwardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CallForwardInfo>& callForwardInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCallForwardStatusResponse(info, callForwardInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCallForwardResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCallForwardResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable, int32_t serviceClass) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCallWaitingResponse(info, enable, serviceClass);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCallWaitingResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeLastIncomingGsmSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeLastIncomingGsmSmsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acceptCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acceptCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deactivateDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deactivateDataCallResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t response) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getFacilityLockForAppResponse(info, response);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t retry) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setFacilityLockForAppResponse(info, retry);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setBarringPasswordResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setBarringPasswordResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getNetworkSelectionModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool manual) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getNetworkSelectionModeResponse(info, manual);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeAutomaticResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeAutomaticResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeManualResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeManualResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAvailableNetworksResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::OperatorInfo>& networkInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAvailableNetworksResponse(info, networkInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getBasebandVersionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& version) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getBasebandVersionResponse(info, version);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::separateConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->separateConnectionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setMuteResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getMuteResponse(info, enable);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getClipResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::ClipStatus status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getClipResponse(info, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSuppServiceNotificationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSuppServiceNotificationsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::writeSmsToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t index) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->writeSmsToSimResponse(info, index);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deleteSmsOnSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deleteSmsOnSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setBandModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setBandModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAvailableBandModesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::RadioBandMode>& bandModes) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAvailableBandModesResponse(info, bandModes);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendEnvelopeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& commandResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendEnvelopeResponse(info, commandResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendTerminalResponseToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendTerminalResponseToSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::handleStkCallSetupRequestFromSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->handleStkCallSetupRequestFromSimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::explicitCallTransferResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->explicitCallTransferResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredNetworkTypeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::PreferredNetworkType nwType) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredNetworkTypeResponse(info, nwType);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getNeighboringCidsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::NeighboringCell>& cells) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getNeighboringCidsResponse(info, cells);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLocationUpdatesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLocationUpdatesResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaSubscriptionSourceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaRoamingPreferenceResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaRoamingType type) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaRoamingPreferenceResponse(info, type);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setTTYModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::TtyMode mode) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getTTYModeResponse(info, mode);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredVoicePrivacyResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredVoicePrivacyResponse(info, enable);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCDMAFeatureCodeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCDMAFeatureCodeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendBurstDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendBurstDtmfResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeLastIncomingCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeLastIncomingCdmaSmsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getGsmBroadcastConfigResponse(info, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setGsmBroadcastConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setGsmBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setGsmBroadcastActivationResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configs) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaBroadcastConfigResponse(info, configs);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaBroadcastConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCdmaBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCdmaBroadcastActivationResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCDMASubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& mdn, const ::android::hardware::hidl_string& hSid, const ::android::hardware::hidl_string& hNid, const ::android::hardware::hidl_string& min, const ::android::hardware::hidl_string& prl) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCDMASubscriptionResponse(info, mdn, hSid, hNid, min, prl);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::writeSmsToRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, uint32_t index) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->writeSmsToRuimResponse(info, index);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::deleteSmsOnRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->deleteSmsOnRuimResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDeviceIdentityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imei, const ::android::hardware::hidl_string& imeisv, const ::android::hardware::hidl_string& esn, const ::android::hardware::hidl_string& meid) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDeviceIdentityResponse(info, imei, imeisv, esn, meid);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::exitEmergencyCallbackModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->exitEmergencyCallbackModeResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& smsc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSmscAddressResponse(info, smsc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSmscAddressResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::reportSmsMemoryStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->reportSmsMemoryStatusResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::reportStkServiceIsRunningResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->reportStkServiceIsRunningResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaSubscriptionSource source) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCdmaSubscriptionSourceResponse(info, source);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestIsimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& response) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestIsimAuthenticationResponse(info, response);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeIncomingGsmSmsWithPduResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeIncomingGsmSmsWithPduResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendEnvelopeWithStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendEnvelopeWithStatusResponse(info, iccIo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRadioTechnologyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::RadioTechnology rat) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRadioTechnologyResponse(info, rat);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCellInfoListRateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCellInfoListRateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setInitialAttachApnResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setInitialAttachApnResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getImsRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isRegistered, ::android::hardware::radio::V1_0::RadioTechnologyFamily ratFamily) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getImsRegistrationStateResponse(info, isRegistered, ratFamily);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendImsSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendImsSmsResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccTransmitApduBasicChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccTransmitApduBasicChannelResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccOpenLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t channelId, const ::android::hardware::hidl_vec<int8_t>& selectResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccOpenLogicalChannelResponse(info, channelId, selectResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccCloseLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccCloseLogicalChannelResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::iccTransmitApduLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->iccTransmitApduLogicalChannelResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvReadItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvReadItemResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvWriteItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvWriteItemResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvWriteCdmaPrlResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvWriteCdmaPrlResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::nvResetConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->nvResetConfigResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setUiccSubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setUiccSubscriptionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataAllowedResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataAllowedResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getHardwareConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& config) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getHardwareConfigResponse(info, config);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestIccSimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestIccSimAuthenticationResponse(info, result);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataProfileResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataProfileResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::requestShutdownResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->requestShutdownResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getRadioCapabilityResponse(info, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioCapabilityResponse(info, rc);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startLceServiceResponse(info, statusInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopLceServiceResponse(info, statusInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::pullLceDataResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceDataInfo& lceInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->pullLceDataResponse(info, lceInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getModemActivityInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::ActivityStatsInfo& activityInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getModemActivityInfoResponse(info, activityInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t numAllowed) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedCarriersResponse(info, numAllowed);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedCarriersResponse(info, allAllowed, carriers);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendDeviceStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendDeviceStateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setIndicationFilterResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setIndicationFilterResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::acknowledgeRequest(int32_t serial) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->acknowledgeRequest(serial);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setCarrierInfoForImsiEncryptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setCarrierInfoForImsiEncryptionResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse_1_1(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse_1_1(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopNetworkScanResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_1::KeepaliveStatus& status) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startKeepaliveResponse(info, status);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::stopKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->stopKeepaliveResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_2(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_2(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSignalStrengthReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSignalStrengthReportingCriteriaResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLinkCapacityReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLinkCapacityReportingCriteriaResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse_1_2(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_2(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::VoiceRegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_2(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_2(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSystemSelectionChannelsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::enableModemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->enableModemResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getModemStackStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isEnabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getModemStackStatusResponse(info, isEnabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::emergencyDialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->emergencyDialResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse_1_4(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_4(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::DataRegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_4(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_4(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getPreferredNetworkTypeBitmapResponse(info, networkTypeBitmap);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setPreferredNetworkTypeBitmapResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_4(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_4(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedCarriersResponse_1_4(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedCarriersResponse_1_4(info, carriers, multiSimPolicy);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_4(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSignalStrengthReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSignalStrengthReportingCriteriaResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setLinkCapacityReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setLinkCapacityReportingCriteriaResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::enableUiccApplicationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->enableUiccApplicationsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::areUiccApplicationsEnabledResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->areUiccApplicationsEnabledResponse(info, enabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSystemSelectionChannelsResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSystemSelectionChannelsResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startNetworkScanResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startNetworkScanResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_5(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_5(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setInitialAttachApnResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setInitialAttachApnResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataProfileResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataProfileResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setIndicationFilterResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setIndicationFilterResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getBarringInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getBarringInfoResponse(info, cellIdentity, barringInfos);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_5(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_5(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_5(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNetworkSelectionModeManualResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNetworkSelectionModeManualResponse_1_5(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsExpectMoreResponse(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::supplySimDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_5::PersoSubstate persoType, int32_t remainingRetries) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->supplySimDepersonalizationResponse(info, persoType, remainingRetries);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getIccCardStatusResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CardStatus& cardStatus) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getIccCardStatusResponse_1_5(info, cardStatus);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setRadioPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setRadioPowerResponse_1_6(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setupDataCallResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SetupDataCallResult& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setupDataCallResponse_1_6(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataCallListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataCallListResponse_1_6(info, dcResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendSmsExpectMoreResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::sendCdmaSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->sendCdmaSmsExpectMoreResponse_1_6(info, sms);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setSimCardPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setSimCardPowerResponse_1_6(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setNrDualConnectivityStateResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setNrDualConnectivityStateResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::isNrDualConnectivityEnabledResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, bool isEnabled) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->isNrDualConnectivityEnabledResponse(info, isEnabled);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::allocatePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t id) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->allocatePduSessionIdResponse(info, id);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::releasePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->releasePduSessionIdResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::startHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->startHandoverResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::cancelHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->cancelHandoverResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setAllowedNetworkTypesBitmapResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getAllowedNetworkTypesBitmapResponse(info, networkTypeBitmap);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::setDataThrottlingResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->setDataThrottlingResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSystemSelectionChannelsResponse(info, specifiers);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCellInfoListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& cellInfo) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCellInfoListResponse_1_6(info, cellInfo);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSignalStrengthResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSignalStrengthResponse_1_6(info, signalStrength);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getVoiceRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& voiceRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getVoiceRegistrationStateResponse_1_6(info, voiceRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getDataRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& dataRegResponse) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getDataRegistrationStateResponse_1_6(info, dataRegResponse);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getCurrentCallsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::Call>& calls) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getCurrentCallsResponse_1_6(info, calls);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSlicingConfigResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SlicingConfig& slicingConfig) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSlicingConfigResponse(info, slicingConfig);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSimPhonebookRecordsResponse(info);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::getSimPhonebookCapacityResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::PhonebookCapacity& capacity) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->getSimPhonebookCapacityResponse(info, capacity);
+        }
+    }
+    return Void();
+}
+
+Return<void> RadioResponse_v1_6_Proxy::updateSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t updatedRecordIndex) {
+    for (int32_t i = 0; i < MAX_SYS_NUM; i++) {
+        if (mRadioResponse[i] != nullptr) {
+            mRadioResponse[i]->updateSimPhonebookRecordsResponse(info, updatedRecordIndex);
+        }
+    }
+    return Void();
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
new file mode 100755
index 0000000000..ac45354139
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/RadioResponse_V1_6_Proxy.h
@@ -0,0 +1,449 @@
+#pragma once
+
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/types.h>
+#include "proxy_common.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+class RadioResponse_v1_6_Proxy : public ::android::hardware::radio::V1_6::IRadioResponse {
+
+private:
+    sp<::android::hardware::radio::V1_6::IRadioResponse> mRadioResponse[MAX_SYS_NUM];
+
+public:
+    RadioResponse_v1_6_Proxy();
+
+    //static ::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioResponse>> castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& parent, bool emitError = false) {
+    //    return ::android::sp<::android::hardware::radio::V1_6::IRadioResponse>(static_cast<::android::hardware::radio::V1_6::IRadioResponse*>(parent.get()));
+    //}
+
+    int32_t setCallback(int sysId, sp<::android::hardware::radio::V1_6::IRadioResponse> radioResponse);
+
+    virtual ~RadioResponse_v1_6_Proxy() = default;
+
+    Return<void> getIccCardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::CardStatus& cardStatus);
+
+    Return<void> supplyIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPukForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyIccPuk2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> changeIccPinForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> changeIccPin2ForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> supplyNetworkDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t remainingRetries);
+
+    Return<void> getCurrentCallsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::Call>& calls);
+
+    Return<void> dialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getIMSIForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imsi);
+
+    Return<void> hangupConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> hangupWaitingOrBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> hangupForegroundResumeBackgroundResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> switchWaitingOrHoldingAndActiveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> conferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> rejectCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getLastCallFailCauseResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LastCallFailCauseInfo& failCauseinfo);
+
+    Return<void> getSignalStrengthResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SignalStrength& sigStrength);
+
+    Return<void> getVoiceRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::VoiceRegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::DataRegStateResult& dataRegResponse);
+
+    Return<void> getOperatorResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& longName, const ::android::hardware::hidl_string& shortName, const ::android::hardware::hidl_string& numeric);
+
+    Return<void> setRadioPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendSMSExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> setupDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SetupDataCallResult& dcResponse);
+
+    Return<void> iccIOForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo);
+
+    Return<void> sendUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> cancelPendingUssdResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t n, int32_t m);
+
+    Return<void> setClirResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCallForwardStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CallForwardInfo>& callForwardInfos);
+
+    Return<void> setCallForwardResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable, int32_t serviceClass);
+
+    Return<void> setCallWaitingResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acknowledgeLastIncomingGsmSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acceptCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> deactivateDataCallResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t response);
+
+    Return<void> setFacilityLockForAppResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t retry);
+
+    Return<void> setBarringPasswordResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getNetworkSelectionModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool manual);
+
+    Return<void> setNetworkSelectionModeAutomaticResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setNetworkSelectionModeManualResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAvailableNetworksResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::OperatorInfo>& networkInfos);
+
+    Return<void> startDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> stopDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getBasebandVersionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& version);
+
+    Return<void> separateConnectionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getMuteResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable);
+
+    Return<void> getClipResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::ClipStatus status);
+
+    Return<void> getDataCallListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::SetupDataCallResult>& dcResponse);
+
+    Return<void> setSuppServiceNotificationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> writeSmsToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t index);
+
+    Return<void> deleteSmsOnSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setBandModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAvailableBandModesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::RadioBandMode>& bandModes);
+
+    Return<void> sendEnvelopeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& commandResponse);
+
+    Return<void> sendTerminalResponseToSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> handleStkCallSetupRequestFromSimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> explicitCallTransferResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getPreferredNetworkTypeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::PreferredNetworkType nwType);
+
+    Return<void> getNeighboringCidsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::NeighboringCell>& cells);
+
+    Return<void> setLocationUpdatesResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaRoamingPreferenceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaRoamingType type);
+
+    Return<void> setTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getTTYModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::TtyMode mode);
+
+    Return<void> setPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getPreferredVoicePrivacyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enable);
+
+    Return<void> sendCDMAFeatureCodeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendBurstDtmfResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> acknowledgeLastIncomingCdmaSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configs);
+
+    Return<void> setGsmBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setGsmBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configs);
+
+    Return<void> setCdmaBroadcastConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setCdmaBroadcastActivationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCDMASubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& mdn, const ::android::hardware::hidl_string& hSid, const ::android::hardware::hidl_string& hNid, const ::android::hardware::hidl_string& min, const ::android::hardware::hidl_string& prl);
+
+    Return<void> writeSmsToRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, uint32_t index);
+
+    Return<void> deleteSmsOnRuimResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getDeviceIdentityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& imei, const ::android::hardware::hidl_string& imeisv, const ::android::hardware::hidl_string& esn, const ::android::hardware::hidl_string& meid);
+
+    Return<void> exitEmergencyCallbackModeResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& smsc);
+
+    Return<void> setSmscAddressResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> reportSmsMemoryStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> reportStkServiceIsRunningResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCdmaSubscriptionSourceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::CdmaSubscriptionSource source);
+
+    Return<void> requestIsimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& response);
+
+    Return<void> acknowledgeIncomingGsmSmsWithPduResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendEnvelopeWithStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& iccIo);
+
+    Return<void> getVoiceRadioTechnologyResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_0::RadioTechnology rat);
+
+    Return<void> getCellInfoListResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CellInfo>& cellInfo);
+
+    Return<void> setCellInfoListRateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setInitialAttachApnResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getImsRegistrationStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isRegistered, ::android::hardware::radio::V1_0::RadioTechnologyFamily ratFamily);
+
+    Return<void> sendImsSmsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> iccTransmitApduBasicChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> iccOpenLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t channelId, const ::android::hardware::hidl_vec<int8_t>& selectResponse);
+
+    Return<void> iccCloseLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> iccTransmitApduLogicalChannelResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> nvReadItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_string& result);
+
+    Return<void> nvWriteItemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> nvWriteCdmaPrlResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> nvResetConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setUiccSubscriptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setDataAllowedResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getHardwareConfigResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::HardwareConfig>& config);
+
+    Return<void> requestIccSimAuthenticationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::IccIoResult& result);
+
+    Return<void> setDataProfileResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> requestShutdownResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> setRadioCapabilityResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> startLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo);
+
+    Return<void> stopLceServiceResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceStatusInfo& statusInfo);
+
+    Return<void> pullLceDataResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::LceDataInfo& lceInfo);
+
+    Return<void> getModemActivityInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::ActivityStatsInfo& activityInfo);
+
+    Return<void> setAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, int32_t numAllowed);
+
+    Return<void> getAllowedCarriersResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers);
+
+    Return<void> sendDeviceStateResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setIndicationFilterResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setSimCardPowerResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> acknowledgeRequest(int32_t serial);
+
+    Return<void> setCarrierInfoForImsiEncryptionResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setSimCardPowerResponse_1_1(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> stopNetworkScanResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_1::KeepaliveStatus& status);
+
+    Return<void> stopKeepaliveResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCellInfoListResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::CellInfo>& cellInfo);
+
+    Return<void> getIccCardStatusResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::CardStatus& cardStatus);
+
+    Return<void> setSignalStrengthReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setLinkCapacityReportingCriteriaResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCurrentCallsResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_2::Call>& calls);
+
+    Return<void> getSignalStrengthResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::SignalStrength& signalStrength);
+
+    Return<void> getVoiceRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::VoiceRegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_2(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_2::DataRegStateResult& dataRegResponse);
+
+    Return<void> setSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> enableModemResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getModemStackStatusResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool isEnabled);
+
+    Return<void> emergencyDialResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getCellInfoListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::CellInfo>& cellInfo);
+
+    Return<void> getDataRegistrationStateResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::DataRegStateResult& dataRegResponse);
+
+    Return<void> getIccCardStatusResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CardStatus& cardStatus);
+
+    Return<void> getPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setPreferredNetworkTypeBitmapResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getDataCallListResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::SetupDataCallResult>& dcResponse);
+
+    Return<void> setupDataCallResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SetupDataCallResult& dcResponse);
+
+    Return<void> setAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getAllowedCarriersResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy);
+
+    Return<void> getSignalStrengthResponse_1_4(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_4::SignalStrength& signalStrength);
+
+    Return<void> setSignalStrengthReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setLinkCapacityReportingCriteriaResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> enableUiccApplicationsResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> areUiccApplicationsEnabledResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, bool enabled);
+
+    Return<void> setSystemSelectionChannelsResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> startNetworkScanResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setupDataCallResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::SetupDataCallResult& dcResponse);
+
+    Return<void> getDataCallListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::SetupDataCallResult>& dcResponse);
+
+    Return<void> setInitialAttachApnResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setDataProfileResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setRadioPowerResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> setIndicationFilterResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> getBarringInfoResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CellIdentity& cellIdentity, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::BarringInfo>& barringInfos);
+
+    Return<void> getVoiceRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::RegStateResult& dataRegResponse);
+
+    Return<void> getCellInfoListResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::CellInfo>& cellInfo);
+
+    Return<void> setNetworkSelectionModeManualResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info);
+
+    Return<void> sendCdmaSmsExpectMoreResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> supplySimDepersonalizationResponse(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, ::android::hardware::radio::V1_5::PersoSubstate persoType, int32_t remainingRetries);
+
+    Return<void> getIccCardStatusResponse_1_5(const ::android::hardware::radio::V1_0::RadioResponseInfo& info, const ::android::hardware::radio::V1_5::CardStatus& cardStatus);
+
+    Return<void> setRadioPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setupDataCallResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SetupDataCallResult& dcResponse);
+
+    Return<void> getDataCallListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::SetupDataCallResult>& dcResponse);
+
+    Return<void> sendSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendCdmaSmsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> sendCdmaSmsExpectMoreResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_0::SendSmsResult& sms);
+
+    Return<void> setSimCardPowerResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setNrDualConnectivityStateResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> isNrDualConnectivityEnabledResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, bool isEnabled);
+
+    Return<void> allocatePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t id);
+
+    Return<void> releasePduSessionIdResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> startHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> cancelHandoverResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> setAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getAllowedNetworkTypesBitmapResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setDataThrottlingResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getSystemSelectionChannelsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers);
+
+    Return<void> getCellInfoListResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::CellInfo>& cellInfo);
+
+    Return<void> getSignalStrengthResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SignalStrength& signalStrength);
+
+    Return<void> getVoiceRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& voiceRegResponse);
+
+    Return<void> getDataRegistrationStateResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::RegStateResult& dataRegResponse);
+
+    Return<void> getCurrentCallsResponse_1_6(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_6::Call>& calls);
+
+    Return<void> getSlicingConfigResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::SlicingConfig& slicingConfig);
+
+    Return<void> getSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info);
+
+    Return<void> getSimPhonebookCapacityResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, const ::android::hardware::radio::V1_6::PhonebookCapacity& capacity);
+
+    Return<void> updateSimPhonebookRecordsResponse(const ::android::hardware::radio::V1_6::RadioResponseInfo& info, int32_t updatedRecordIndex);
+
+};
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
new file mode 100755
index 0000000000..dd4e450ea9
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/proxy_common.h
@@ -0,0 +1,3 @@
+#pragma once
+
+#define MAX_SYS_NUM 3
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
new file mode 100755
index 0000000000..1f71d7280e
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/radio_hidl_hal_proxy.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include <hidl/HidlTransportSupport.h>
+#include "RadioResponse_V1_6_Proxy.h"
+#include "RadioIndication_V1_6_Proxy.h"
+#include "ril_service_1_6_proxy.h"
+
+using namespace ::android::hardware::radio::V1_6;
+using namespace ::android::hardware::radio::V1_5;
+using namespace ::android::hardware::radio::V1_4;
+using namespace ::android::hardware::radio::V1_3;
+using namespace ::android::hardware::radio::V1_2;
+using namespace ::android::hardware::radio::V1_1;
+using namespace ::android::hardware::radio::V1_0;
+
+using ::android::sp;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+
+#define SIM_COUNT 2
+
+int main(int argc, char **argv) {
+    android::status_t status;
+    sp<::android::hardware::radio::V1_6::IRadio> radio_v1_6 = nullptr;
+    int32_t slot = 0;
+    const char *serviceNames[] = {
+        "slot1"
+        #if (SIM_COUNT >= 2)
+        , "slot2"
+        #if (SIM_COUNT >= 3)
+        , "slot3"
+        #if (SIM_COUNT >= 4)
+        , "slot4"
+        #endif
+        #endif
+        #endif
+    };
+    const char *proxyServiceNames[] = {
+            "slot1_proxy"
+            #if (SIM_COUNT >= 2)
+            , "slot2_proxy"
+            #if (SIM_COUNT >= 3)
+            , "slot3_proxy"
+            #if (SIM_COUNT >= 4)
+            , "slot4_proxy"
+            #endif
+            #endif
+            #endif
+        };
+
+
+    if (argc < 2) {
+        return -1;
+    }
+
+    slot = atoi(argv[1]);
+    RLOGD("slot = %d\n", slot);
+    if (argc >= 3) {
+        //test
+        radio_v1_6 = android::hardware::radio::V1_6::IRadio::getService(proxyServiceNames[slot]);
+        if (radio_v1_6 == nullptr) {
+            RLOGD("RIL_Proxy_Init radio_v1_6(%s) is null \n", proxyServiceNames[slot]);
+            return 0;
+        }
+
+        int32_t serial = 0x55AA55AA;
+        ::android::hardware::radio::V1_5::AccessNetwork accessNetwork =
+                ::android::hardware::radio::V1_5::AccessNetwork::EUTRAN;
+
+        android::hardware::radio::V1_5::DataProfileInfo dataProfileInfo;
+        memset(&dataProfileInfo, 0, sizeof(dataProfileInfo));
+        dataProfileInfo.profileId = DataProfileId::DEFAULT;
+        dataProfileInfo.apn = hidl_string("internet");
+        dataProfileInfo.protocol = PdpProtocolType::IP;
+        dataProfileInfo.roamingProtocol = PdpProtocolType::IP;
+        dataProfileInfo.authType = ApnAuthType::NO_PAP_NO_CHAP;
+        dataProfileInfo.user = hidl_string("username");
+        dataProfileInfo.password = hidl_string("password");
+        dataProfileInfo.type = DataProfileInfoType::THREE_GPP;
+        dataProfileInfo.maxConnsTime = 300;
+        dataProfileInfo.maxConns = 20;
+        dataProfileInfo.waitTime = 0;
+        dataProfileInfo.enabled = true;
+        dataProfileInfo.supportedApnTypesBitmap = 320;
+        dataProfileInfo.bearerBitmap = 161543;
+        dataProfileInfo.mtuV4 = 0;
+        dataProfileInfo.mtuV6 = 0;
+        dataProfileInfo.preferred = true;
+        dataProfileInfo.persistent = false;
+
+        bool roamingAllowed = false;
+
+        std::vector<::android::hardware::radio::V1_5::LinkAddress> addresses = {};
+        std::vector<hidl_string> dnses = {};
+
+        ::android::hardware::radio::V1_2::DataRequestReason reason =
+                ::android::hardware::radio::V1_2::DataRequestReason::NORMAL;
+
+        ::android::hardware::radio::V1_6::OptionalSliceInfo optionalSliceInfo;
+        memset(&optionalSliceInfo, 0, sizeof(optionalSliceInfo));
+
+        ::android::hardware::radio::V1_6::OptionalTrafficDescriptor optionalTrafficDescriptor;
+        memset(&optionalTrafficDescriptor, 0, sizeof(optionalTrafficDescriptor));
+
+        bool matchAllRuleAllowed = true;
+
+        radio_v1_6->setupDataCall_1_6(serial, accessNetwork, dataProfileInfo, roamingAllowed,
+                                          reason, addresses, dnses, -1, optionalSliceInfo,
+                                          optionalTrafficDescriptor, matchAllRuleAllowed);
+        RLOGD("RIL_Proxy_Init radio_v1_6(%s) setupDataCall_1_6 after\n", proxyServiceNames[slot]);
+
+        return 0;
+    }
+
+    android::hardware::configureRpcThreadpool(2, true /* callerWillJoin */);
+
+    radio_v1_6 = android::hardware::radio::V1_6::IRadio::getService(serviceNames[slot]);
+    if (radio_v1_6 == nullptr) {
+        RLOGD("RIL_Proxy_Init radio_v1_6 is null \n");
+    }
+
+    sp<RadioImpl_1_6_Proxy> radioImpl_1_6_Proxy = new (std::nothrow) RadioImpl_1_6_Proxy(slot, radio_v1_6);
+    if (radioImpl_1_6_Proxy == nullptr) {
+        RLOGD("RIL_Proxy_Init radioImpl_1_6_Proxy is null \n");
+    }
+
+    status = radioImpl_1_6_Proxy->registerAsService(proxyServiceNames[slot]);
+
+    RLOGD("RIL_Proxy_Init starting sleep loop");
+    while (true) {
+        sleep(UINT32_MAX);
+    }
+
+    return 0;
+}
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
new file mode 100755
index 0000000000..c4dc7c8fdb
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.cpp
@@ -0,0 +1,1078 @@
+
+#include "ril_service_1_6_proxy.h"
+
+::android::status_t RadioImpl_1_6_Proxy::registerAsService(const std::string &serviceName) {
+    return ::android::hardware::radio::V1_6::IRadio::registerAsService(serviceName);
+}
+
+//::android::hardware::Return<::android::sp<::android::hardware::radio::V1_6::IRadioResponse>> RadioImpl_1_6_Proxy::castFrom(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& parent, bool /* emitError */) {
+//    return (::android::sp<::android::hardware::radio::V1_6::IRadioResponse>)parent;
+//}
+
+void RadioImpl_1_6_Proxy::serviceDied(uint64_t cookie,
+        const ::android::wp<::android::hidl::base::V1_0::IBase>& who) {
+    int32_t sysId = cookie;
+    (void)who;
+    RLOGD("RadioImpl_1_6_Proxy::serviceDied: Client %d died. Cleaning up callbacks", sysId);
+    mRadioResponseV1_6->setCallback(sysId, nullptr);
+    mRadioIndicationV1_6->setCallback(sysId, nullptr);
+}
+
+Return<void> RadioImpl_1_6_Proxy::setResponseFunctions(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& radioResponse, const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& radioIndication) {
+    int sysId = 0;
+
+    ::android::sp<::android::hardware::radio::V1_6::IRadioResponse> tmpResponse =::android::hardware::radio::V1_6::IRadioResponse::castFrom(radioResponse)
+                             .withDefault(nullptr);
+    ::android::sp<::android::hardware::radio::V1_6::IRadioIndication> tmpIndication = ::android::hardware::radio::V1_6::IRadioIndication::castFrom(radioIndication)
+                             .withDefault(nullptr);
+    if (nullptr != tmpResponse && nullptr != tmpIndication) {
+        sysId = mRadioResponseV1_6->setCallback(-1, tmpResponse);
+        mRadioIndicationV1_6->setCallback(-1, tmpIndication);
+        RLOGD("setCallback to free_slot %d\n", sysId);
+        tmpResponse->linkToDeath(this, sysId);
+        mRealService->setResponseFunctions(mRadioResponseV1_6, mRadioIndicationV1_6);
+    }
+
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getIccCardStatus(int32_t serial) {
+    mRealService->getIccCardStatus(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPinForApp(serial, pin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPukForApp(int32_t serial, const ::android::hardware::hidl_string& puk, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPukForApp(serial, puk, pin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPin2ForApp(serial, pin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyIccPuk2ForApp(int32_t serial, const ::android::hardware::hidl_string& puk2, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->supplyIccPuk2ForApp(serial, puk2, pin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::changeIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin, const ::android::hardware::hidl_string& newPin, const ::android::hardware::hidl_string& aid) {
+    mRealService->changeIccPinForApp(serial, oldPin, newPin, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::changeIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin2, const ::android::hardware::hidl_string& newPin2, const ::android::hardware::hidl_string& aid) {
+    mRealService->changeIccPin2ForApp(serial, oldPin2, newPin2, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplyNetworkDepersonalization(int32_t serial, const ::android::hardware::hidl_string& netPin) {
+    mRealService->supplyNetworkDepersonalization(serial, netPin);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCurrentCalls(int32_t serial) {
+    mRealService->getCurrentCalls(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::dial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo) {
+    mRealService->dial(serial, dialInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getImsiForApp(int32_t serial, const ::android::hardware::hidl_string& aid) {
+    mRealService->getImsiForApp(serial, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangup(int32_t serial, int32_t gsmIndex) {
+    mRealService->hangup(serial, gsmIndex);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangupWaitingOrBackground(int32_t serial) {
+    mRealService->hangupWaitingOrBackground(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::hangupForegroundResumeBackground(int32_t serial) {
+    mRealService->hangupForegroundResumeBackground(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::switchWaitingOrHoldingAndActive(int32_t serial) {
+    mRealService->switchWaitingOrHoldingAndActive(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::conference(int32_t serial) {
+    mRealService->conference(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::rejectCall(int32_t serial) {
+    mRealService->rejectCall(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getLastCallFailCause(int32_t serial) {
+    mRealService->getLastCallFailCause(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength(int32_t serial) {
+    mRealService->getSignalStrength(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState(int32_t serial) {
+    mRealService->getVoiceRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState(int32_t serial) {
+    mRealService->getDataRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getOperator(int32_t serial) {
+    mRealService->getOperator(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower(int32_t serial, bool on) {
+    mRealService->setRadioPower(serial, on);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendDtmf(int32_t serial, const ::android::hardware::hidl_string& s) {
+    mRealService->sendDtmf(serial, s);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSms(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSms(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSMSExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSMSExpectMore(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall(int32_t serial, ::android::hardware::radio::V1_0::RadioTechnology radioTechnology, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming) {
+    mRealService->setupDataCall(serial, radioTechnology, dataProfileInfo, modemCognitive, roamingAllowed, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccIOForApp(int32_t serial, const ::android::hardware::radio::V1_0::IccIo& iccIo) {
+    mRealService->iccIOForApp(serial, iccIo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendUssd(int32_t serial, const ::android::hardware::hidl_string& ussd) {
+    mRealService->sendUssd(serial, ussd);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::cancelPendingUssd(int32_t serial) {
+    mRealService->cancelPendingUssd(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getClir(int32_t serial) {
+    mRealService->getClir(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setClir(int32_t serial, int32_t status) {
+    mRealService->setClir(serial, status);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCallForwardStatus(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo) {
+    mRealService->getCallForwardStatus(serial, callInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCallForward(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo) {
+    mRealService->setCallForward(serial, callInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCallWaiting(int32_t serial, int32_t serviceClass) {
+    mRealService->getCallWaiting(serial, serviceClass);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCallWaiting(int32_t serial, bool enable, int32_t serviceClass) {
+    mRealService->setCallWaiting(serial, enable, serviceClass);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeLastIncomingGsmSms(int32_t serial, bool success, ::android::hardware::radio::V1_0::SmsAcknowledgeFailCause cause) {
+    mRealService->acknowledgeLastIncomingGsmSms(serial, success, cause);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acceptCall(int32_t serial) {
+    mRealService->acceptCall(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deactivateDataCall(int32_t serial, int32_t cid, bool reasonRadioShutDown) {
+    mRealService->deactivateDataCall(serial, cid, reasonRadioShutDown);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId) {
+    mRealService->getFacilityLockForApp(serial, facility, password, serviceClass, appId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, bool lockState, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId) {
+    mRealService->setFacilityLockForApp(serial, facility, lockState, password, serviceClass, appId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setBarringPassword(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& oldPassword, const ::android::hardware::hidl_string& newPassword) {
+    mRealService->setBarringPassword(serial, facility, oldPassword, newPassword);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getNetworkSelectionMode(int32_t serial) {
+    mRealService->getNetworkSelectionMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeAutomatic(int32_t serial) {
+    mRealService->setNetworkSelectionModeAutomatic(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeManual(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric) {
+    mRealService->setNetworkSelectionModeManual(serial, operatorNumeric);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAvailableNetworks(int32_t serial) {
+    mRealService->getAvailableNetworks(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startDtmf(int32_t serial, const ::android::hardware::hidl_string& s) {
+    mRealService->startDtmf(serial, s);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopDtmf(int32_t serial) {
+    mRealService->stopDtmf(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getBasebandVersion(int32_t serial) {
+    mRealService->getBasebandVersion(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::separateConnection(int32_t serial, int32_t gsmIndex) {
+    mRealService->separateConnection(serial, gsmIndex);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setMute(int32_t serial, bool enable) {
+    mRealService->setMute(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getMute(int32_t serial) {
+    mRealService->getMute(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getClip(int32_t serial) {
+    mRealService->getClip(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataCallList(int32_t serial) {
+    mRealService->getDataCallList(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSuppServiceNotifications(int32_t serial, bool enable) {
+    mRealService->setSuppServiceNotifications(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::writeSmsToSim(int32_t serial, const ::android::hardware::radio::V1_0::SmsWriteArgs& smsWriteArgs) {
+    mRealService->writeSmsToSim(serial, smsWriteArgs);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deleteSmsOnSim(int32_t serial, int32_t index) {
+    mRealService->deleteSmsOnSim(serial, index);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setBandMode(int32_t serial, ::android::hardware::radio::V1_0::RadioBandMode mode) {
+    mRealService->setBandMode(serial, mode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAvailableBandModes(int32_t serial) {
+    mRealService->getAvailableBandModes(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendEnvelope(int32_t serial, const ::android::hardware::hidl_string& command) {
+    mRealService->sendEnvelope(serial, command);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendTerminalResponseToSim(int32_t serial, const ::android::hardware::hidl_string& commandResponse) {
+    mRealService->sendTerminalResponseToSim(serial, commandResponse);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::handleStkCallSetupRequestFromSim(int32_t serial, bool accept) {
+    mRealService->handleStkCallSetupRequestFromSim(serial, accept);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::explicitCallTransfer(int32_t serial) {
+    mRealService->explicitCallTransfer(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredNetworkType(int32_t serial, ::android::hardware::radio::V1_0::PreferredNetworkType nwType) {
+    mRealService->setPreferredNetworkType(serial, nwType);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredNetworkType(int32_t serial) {
+    mRealService->getPreferredNetworkType(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getNeighboringCids(int32_t serial) {
+    mRealService->getNeighboringCids(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLocationUpdates(int32_t serial, bool enable) {
+    mRealService->setLocationUpdates(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaSubscriptionSource(int32_t serial, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSub) {
+    mRealService->setCdmaSubscriptionSource(serial, cdmaSub);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaRoamingPreference(int32_t serial, ::android::hardware::radio::V1_0::CdmaRoamingType type) {
+    mRealService->setCdmaRoamingPreference(serial, type);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaRoamingPreference(int32_t serial) {
+    mRealService->getCdmaRoamingPreference(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setTTYMode(int32_t serial, ::android::hardware::radio::V1_0::TtyMode mode) {
+    mRealService->setTTYMode(serial, mode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getTTYMode(int32_t serial) {
+    mRealService->getTTYMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredVoicePrivacy(int32_t serial, bool enable) {
+    mRealService->setPreferredVoicePrivacy(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredVoicePrivacy(int32_t serial) {
+    mRealService->getPreferredVoicePrivacy(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCDMAFeatureCode(int32_t serial, const ::android::hardware::hidl_string& featureCode) {
+    mRealService->sendCDMAFeatureCode(serial, featureCode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendBurstDtmf(int32_t serial, const ::android::hardware::hidl_string& dtmf, int32_t on, int32_t off) {
+    mRealService->sendBurstDtmf(serial, dtmf, on, off);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSms(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeLastIncomingCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsAck& smsAck) {
+    mRealService->acknowledgeLastIncomingCdmaSms(serial, smsAck);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getGsmBroadcastConfig(int32_t serial) {
+    mRealService->getGsmBroadcastConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setGsmBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configInfo) {
+    mRealService->setGsmBroadcastConfig(serial, configInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setGsmBroadcastActivation(int32_t serial, bool activate) {
+    mRealService->setGsmBroadcastActivation(serial, activate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaBroadcastConfig(int32_t serial) {
+    mRealService->getCdmaBroadcastConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configInfo) {
+    mRealService->setCdmaBroadcastConfig(serial, configInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCdmaBroadcastActivation(int32_t serial, bool activate) {
+    mRealService->setCdmaBroadcastActivation(serial, activate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCDMASubscription(int32_t serial) {
+    mRealService->getCDMASubscription(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::writeSmsToRuim(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsWriteArgs& cdmaSms) {
+    mRealService->writeSmsToRuim(serial, cdmaSms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deleteSmsOnRuim(int32_t serial, int32_t index) {
+    mRealService->deleteSmsOnRuim(serial, index);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDeviceIdentity(int32_t serial) {
+    mRealService->getDeviceIdentity(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::exitEmergencyCallbackMode(int32_t serial) {
+    mRealService->exitEmergencyCallbackMode(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSmscAddress(int32_t serial) {
+    mRealService->getSmscAddress(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSmscAddress(int32_t serial, const ::android::hardware::hidl_string& smsc) {
+    mRealService->setSmscAddress(serial, smsc);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::reportSmsMemoryStatus(int32_t serial, bool available) {
+    mRealService->reportSmsMemoryStatus(serial, available);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::reportStkServiceIsRunning(int32_t serial) {
+    mRealService->reportStkServiceIsRunning(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCdmaSubscriptionSource(int32_t serial) {
+    mRealService->getCdmaSubscriptionSource(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestIsimAuthentication(int32_t serial, const ::android::hardware::hidl_string& challenge) {
+    mRealService->requestIsimAuthentication(serial, challenge);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success, const ::android::hardware::hidl_string& ackPdu) {
+    mRealService->acknowledgeIncomingGsmSmsWithPdu(serial, success, ackPdu);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendEnvelopeWithStatus(int32_t serial, const ::android::hardware::hidl_string& contents) {
+    mRealService->sendEnvelopeWithStatus(serial, contents);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRadioTechnology(int32_t serial) {
+    mRealService->getVoiceRadioTechnology(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCellInfoList(int32_t serial) {
+    mRealService->getCellInfoList(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCellInfoListRate(int32_t serial, int32_t rate) {
+    mRealService->setCellInfoListRate(serial, rate);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn(int32_t serial, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool isRoaming) {
+    mRealService->setInitialAttachApn(serial, dataProfileInfo, modemCognitive, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getImsRegistrationState(int32_t serial) {
+    mRealService->getImsRegistrationState(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendImsSms(int32_t serial, const ::android::hardware::radio::V1_0::ImsSmsMessage& message) {
+    mRealService->sendImsSms(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccTransmitApduBasicChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message) {
+    mRealService->iccTransmitApduBasicChannel(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccOpenLogicalChannel(int32_t serial, const ::android::hardware::hidl_string& aid, int32_t p2) {
+    mRealService->iccOpenLogicalChannel(serial, aid, p2);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccCloseLogicalChannel(int32_t serial, int32_t channelId) {
+    mRealService->iccCloseLogicalChannel(serial, channelId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::iccTransmitApduLogicalChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message) {
+    mRealService->iccTransmitApduLogicalChannel(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvReadItem(int32_t serial, ::android::hardware::radio::V1_0::NvItem itemId) {
+    mRealService->nvReadItem(serial, itemId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvWriteItem(int32_t serial, const ::android::hardware::radio::V1_0::NvWriteItem& item) {
+    mRealService->nvWriteItem(serial, item);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvWriteCdmaPrl(int32_t serial, const ::android::hardware::hidl_vec<uint8_t>& prl) {
+    mRealService->nvWriteCdmaPrl(serial, prl);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::nvResetConfig(int32_t serial, ::android::hardware::radio::V1_0::ResetNvType resetType) {
+    mRealService->nvResetConfig(serial, resetType);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setUiccSubscription(int32_t serial, const ::android::hardware::radio::V1_0::SelectUiccSub& uiccSub) {
+    mRealService->setUiccSubscription(serial, uiccSub);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataAllowed(int32_t serial, bool allow) {
+    mRealService->setDataAllowed(serial, allow);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getHardwareConfig(int32_t serial) {
+    mRealService->getHardwareConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestIccSimAuthentication(int32_t serial, int32_t authContext, const ::android::hardware::hidl_string& authData, const ::android::hardware::hidl_string& aid) {
+    mRealService->requestIccSimAuthentication(serial, authContext, authData, aid);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::DataProfileInfo>& profiles, bool isRoaming) {
+    mRealService->setDataProfile(serial, profiles, isRoaming);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::requestShutdown(int32_t serial) {
+    mRealService->requestShutdown(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getRadioCapability(int32_t serial) {
+    mRealService->getRadioCapability(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioCapability(int32_t serial, const ::android::hardware::radio::V1_0::RadioCapability& rc) {
+    mRealService->setRadioCapability(serial, rc);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startLceService(int32_t serial, int32_t reportInterval, bool pullMode) {
+    mRealService->startLceService(serial, reportInterval, pullMode);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopLceService(int32_t serial) {
+    mRealService->stopLceService(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::pullLceData(int32_t serial) {
+    mRealService->pullLceData(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getModemActivityInfo(int32_t serial) {
+    mRealService->getModemActivityInfo(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedCarriers(int32_t serial, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers) {
+    mRealService->setAllowedCarriers(serial, allAllowed, carriers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedCarriers(int32_t serial) {
+    mRealService->getAllowedCarriers(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendDeviceState(int32_t serial, ::android::hardware::radio::V1_0::DeviceStateType deviceStateType, bool state) {
+    mRealService->sendDeviceState(serial, deviceStateType, state);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_0::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower(int32_t serial, bool powerUp) {
+    mRealService->setSimCardPower(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::responseAcknowledgement() {
+    mRealService->responseAcknowledgement();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCarrierInfoForImsiEncryption(int32_t serial, const ::android::hardware::radio::V1_1::ImsiEncryptionInfo& imsiEncryptionInfo) {
+    mRealService->setCarrierInfoForImsiEncryption(serial, imsiEncryptionInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower_1_1(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp) {
+    mRealService->setSimCardPower_1_1(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan(int32_t serial, const ::android::hardware::radio::V1_1::NetworkScanRequest& request) {
+    mRealService->startNetworkScan(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopNetworkScan(int32_t serial) {
+    mRealService->stopNetworkScan(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startKeepalive(int32_t serial, const ::android::hardware::radio::V1_1::KeepaliveRequest& keepalive) {
+    mRealService->startKeepalive(serial, keepalive);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::stopKeepalive(int32_t serial, int32_t sessionHandle) {
+    mRealService->stopKeepalive(serial, sessionHandle);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_2(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_2(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter_1_2(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_2::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter_1_2(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSignalStrengthReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDb, const ::android::hardware::hidl_vec<int32_t>& thresholdsDbm, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork) {
+    mRealService->setSignalStrengthReportingCriteria(serial, hysteresisMs, hysteresisDb, thresholdsDbm, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLinkCapacityReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork) {
+    mRealService->setLinkCapacityReportingCriteria(serial, hysteresisMs, hysteresisDlKbps, hysteresisUlKbps, thresholdsDownlinkKbps, thresholdsUplinkKbps, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_2(int32_t serial, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_2(serial, accessNetwork, dataProfileInfo, modemCognitive, roamingAllowed, isRoaming, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::deactivateDataCall_1_2(int32_t serial, int32_t cid, ::android::hardware::radio::V1_2::DataRequestReason reason) {
+    mRealService->deactivateDataCall_1_2(serial, cid, reason);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSystemSelectionChannels(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& specifiers) {
+    mRealService->setSystemSelectionChannels(serial, specifyChannels, specifiers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::enableModem(int32_t serial, bool on) {
+    mRealService->enableModem(serial, on);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getModemStackStatus(int32_t serial) {
+    mRealService->getModemStackStatus(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_4(int32_t serial, ::android::hardware::radio::V1_4::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_4(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn_1_4(int32_t serial, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo) {
+    mRealService->setInitialAttachApn_1_4(serial, dataProfileInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile_1_4(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& profiles) {
+    mRealService->setDataProfile_1_4(serial, profiles);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::emergencyDial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting) {
+    mRealService->emergencyDial(serial, dialInfo, categories, urns, routing, hasKnownUserIntentEmergency, isTesting);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_4(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_4(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getPreferredNetworkTypeBitmap(int32_t serial) {
+    mRealService->getPreferredNetworkTypeBitmap(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setPreferredNetworkTypeBitmap(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    mRealService->setPreferredNetworkTypeBitmap(serial, networkTypeBitmap);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedCarriers_1_4(int32_t serial, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy) {
+    mRealService->setAllowedCarriers_1_4(serial, carriers, multiSimPolicy);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedCarriers_1_4(int32_t serial) {
+    mRealService->getAllowedCarriers_1_4(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength_1_4(int32_t serial) {
+    mRealService->getSignalStrength_1_4(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSignalStrengthReportingCriteria_1_5(int32_t serial, const ::android::hardware::radio::V1_5::SignalThresholdInfo& signalThresholdInfo, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork) {
+    mRealService->setSignalStrengthReportingCriteria_1_5(serial, signalThresholdInfo, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setLinkCapacityReportingCriteria_1_5(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork) {
+    mRealService->setLinkCapacityReportingCriteria_1_5(serial, hysteresisMs, hysteresisDlKbps, hysteresisUlKbps, thresholdsDownlinkKbps, thresholdsUplinkKbps, accessNetwork);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::enableUiccApplications(int32_t serial, bool enable) {
+    mRealService->enableUiccApplications(serial, enable);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::areUiccApplicationsEnabled(int32_t serial) {
+    mRealService->areUiccApplicationsEnabled(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSystemSelectionChannels_1_5(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers) {
+    mRealService->setSystemSelectionChannels_1_5(serial, specifyChannels, specifiers);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startNetworkScan_1_5(int32_t serial, const ::android::hardware::radio::V1_5::NetworkScanRequest& request) {
+    mRealService->startNetworkScan_1_5(serial, request);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_5(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses) {
+    mRealService->setupDataCall_1_5(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setInitialAttachApn_1_5(int32_t serial, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo) {
+    mRealService->setInitialAttachApn_1_5(serial, dataProfileInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataProfile_1_5(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& profiles) {
+    mRealService->setDataProfile_1_5(serial, profiles);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall) {
+    mRealService->setRadioPower_1_5(serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setIndicationFilter_1_5(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter) {
+    mRealService->setIndicationFilter_1_5(serial, indicationFilter);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getBarringInfo(int32_t serial) {
+    mRealService->getBarringInfo(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState_1_5(int32_t serial) {
+    mRealService->getVoiceRegistrationState_1_5(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState_1_5(int32_t serial) {
+    mRealService->getDataRegistrationState_1_5(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNetworkSelectionModeManual_1_5(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric, ::android::hardware::radio::V1_5::RadioAccessNetworks ran) {
+    mRealService->setNetworkSelectionModeManual_1_5(serial, operatorNumeric, ran);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSmsExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSmsExpectMore(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::supplySimDepersonalization(int32_t serial, ::android::hardware::radio::V1_5::PersoSubstate persoType, const ::android::hardware::hidl_string& controlKey) {
+    mRealService->supplySimDepersonalization(serial, persoType, controlKey);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall) {
+    mRealService->setRadioPower_1_6(serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataCallList_1_6(int32_t serial) {
+    mRealService->getDataCallList_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setupDataCall_1_6(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses, int32_t pduSessionId, const ::android::hardware::radio::V1_6::OptionalSliceInfo& sliceInfo, const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& trafficDescriptor, bool matchAllRuleAllowed) {
+    mRealService->setupDataCall_1_6(serial, accessNetwork, dataProfileInfo, roamingAllowed, reason, addresses, dnses, pduSessionId, sliceInfo, trafficDescriptor, matchAllRuleAllowed);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSms_1_6(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message) {
+    mRealService->sendSmsExpectMore_1_6(serial, message);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSms_1_6(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::sendCdmaSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms) {
+    mRealService->sendCdmaSmsExpectMore_1_6(serial, sms);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setSimCardPower_1_6(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp) {
+    mRealService->setSimCardPower_1_6(serial, powerUp);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setNrDualConnectivityState(int32_t serial, ::android::hardware::radio::V1_6::NrDualConnectivityState nrDualConnectivityState) {
+    mRealService->setNrDualConnectivityState(serial, nrDualConnectivityState);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::isNrDualConnectivityEnabled(int32_t serial) {
+    mRealService->isNrDualConnectivityEnabled(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::allocatePduSessionId(int32_t serial) {
+    mRealService->allocatePduSessionId(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::releasePduSessionId(int32_t serial, int32_t id) {
+    mRealService->releasePduSessionId(serial, id);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::startHandover(int32_t serial, int32_t callId) {
+    mRealService->startHandover(serial, callId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::cancelHandover(int32_t serial, int32_t callId) {
+    mRealService->cancelHandover(serial, callId);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setAllowedNetworkTypesBitmap(uint32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap) {
+    mRealService->setAllowedNetworkTypesBitmap(serial, networkTypeBitmap);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getAllowedNetworkTypesBitmap(int32_t serial) {
+    mRealService->getAllowedNetworkTypesBitmap(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setDataThrottling(int32_t serial, ::android::hardware::radio::V1_6::DataThrottlingAction dataThrottlingAction, int64_t completionDurationMillis) {
+    mRealService->setDataThrottling(serial, dataThrottlingAction, completionDurationMillis);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::emergencyDial_1_6(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting) {
+    mRealService->emergencyDial_1_6(serial, dialInfo, categories, urns, routing, hasKnownUserIntentEmergency, isTesting);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSystemSelectionChannels(int32_t serial) {
+    mRealService->getSystemSelectionChannels(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCellInfoList_1_6(int32_t serial) {
+    mRealService->getCellInfoList_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getVoiceRegistrationState_1_6(int32_t serial) {
+    mRealService->getVoiceRegistrationState_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSignalStrength_1_6(int32_t serial) {
+    mRealService->getSignalStrength_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDataRegistrationState_1_6(int32_t serial) {
+    mRealService->getDataRegistrationState_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getCurrentCalls_1_6(int32_t serial) {
+    mRealService->getCurrentCalls_1_6(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSlicingConfig(int32_t serial) {
+    mRealService->getSlicingConfig(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setCarrierInfoForImsiEncryption_1_6(int32_t serial, const ::android::hardware::radio::V1_6::ImsiEncryptionInfo& imsiEncryptionInfo) {
+    mRealService->setCarrierInfoForImsiEncryption_1_6(serial, imsiEncryptionInfo);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSimPhonebookRecords(int32_t serial) {
+    mRealService->getSimPhonebookRecords(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getSimPhonebookCapacity(int32_t serial) {
+    mRealService->getSimPhonebookCapacity(serial);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::updateSimPhonebookRecords(int32_t serial, const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo) {
+    mRealService->updateSimPhonebookRecords(serial, recordInfo);
+    return Void();
+}
+
+
+Return<void> RadioImpl_1_6_Proxy::interfaceChain(interfaceChain_cb _hidl_cb) {
+    mRealService->interfaceChain(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::debug(const ::android::hardware::hidl_handle& fd, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& options) {
+    mRealService->debug(fd, options);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::interfaceDescriptor(interfaceDescriptor_cb _hidl_cb) {
+    mRealService->interfaceDescriptor(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getHashChain(getHashChain_cb _hidl_cb) {
+    mRealService->getHashChain(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::setHALInstrumentation() {
+    mRealService->setHALInstrumentation();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::ping() {
+    mRealService->ping();
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::getDebugInfo(getDebugInfo_cb _hidl_cb) {
+    mRealService->getDebugInfo(_hidl_cb);
+    return Void();
+}
+
+Return<void> RadioImpl_1_6_Proxy::notifySyspropsChanged() {
+    mRealService->notifySyspropsChanged();
+    return Void();
+}
\ No newline at end of file
diff --git a/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h
new file mode 100755
index 0000000000..964e2c8ec2
--- /dev/null
+++ b/hardware/interfaces/radio/1.6/radio_hal_proxy/ril_service_1_6_proxy.h
@@ -0,0 +1,482 @@
+#pragma once
+#define LOG_TAG "RADIO_HAL_PROXY"
+#include <log/log.h>
+#include <memory>
+#include <android/hardware/radio/1.6/IRadio.h>
+#include <android/hardware/radio/1.6/IRadioResponse.h>
+#include <android/hardware/radio/1.6/IRadioIndication.h>
+#include <android/hardware/radio/1.6/types.h>
+#include <utils/SystemClock.h>
+#include <inttypes.h>
+#include "proxy_common.h"
+#include "RadioIndication_V1_6_Proxy.h"
+#include "RadioResponse_V1_6_Proxy.h"
+
+
+// revisit the header files and using primitive
+using namespace android::hardware::radio;
+using namespace android::hardware::radio::V1_0;
+using namespace android::hardware::radio::V1_1;
+using namespace android::hardware::radio::V1_2;
+using namespace android::hardware::radio::V1_3;
+using namespace android::hardware::radio::V1_4;
+using namespace android::hardware::radio::V1_5;
+using namespace android::hardware::radio::V1_6;
+//using namespace android::hardware::radio::deprecated::V1_0;
+using ::android::hardware::Return;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_bitfield;
+using ::android::hardware::Void;
+using ::android::hardware::hidl_death_recipient;
+
+//using android::requestToString;
+using android::sp;
+
+class RadioImpl_1_6_Proxy : public ::android::hardware::radio::V1_6::IRadio, public ::android::hardware::hidl_death_recipient {
+    sp<RadioResponse_v1_6_Proxy> mRadioResponseV1_6;
+    sp<RadioIndication_v1_6_Proxy> mRadioIndicationV1_6;
+    sp<::android::hardware::radio::V1_6::IRadio> mRealService;
+    int32_t mInstance;
+
+public:
+    RadioImpl_1_6_Proxy(int32_t instance, sp<::android::hardware::radio::V1_6::IRadio> realService) {
+        mInstance = instance;
+        mRealService = realService;
+
+        mRadioResponseV1_6 = new (std::nothrow) RadioResponse_v1_6_Proxy();
+
+        mRadioIndicationV1_6 = new (std::nothrow) RadioIndication_v1_6_Proxy();
+
+        mRealService->setResponseFunctions(mRadioResponseV1_6, mRadioIndicationV1_6);
+
+    }
+
+    virtual ::android::status_t registerAsService(const std::string &serviceName);
+
+    virtual const char *getDescriptor() {
+        return ::android::hardware::radio::V1_6::IRadio::descriptor;
+    }
+
+    void serviceDied(uint64_t,
+            const ::android::wp<::android::hidl::base::V1_0::IBase>&);
+
+    Return<void> setResponseFunctions(const ::android::sp<::android::hardware::radio::V1_0::IRadioResponse>& radioResponse, const ::android::sp<::android::hardware::radio::V1_0::IRadioIndication>& radioIndication);
+
+    Return<void> getIccCardStatus(int32_t serial);
+
+    Return<void> supplyIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPukForApp(int32_t serial, const ::android::hardware::hidl_string& puk, const ::android::hardware::hidl_string& pin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyIccPuk2ForApp(int32_t serial, const ::android::hardware::hidl_string& puk2, const ::android::hardware::hidl_string& pin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> changeIccPinForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin, const ::android::hardware::hidl_string& newPin, const ::android::hardware::hidl_string& aid);
+
+    Return<void> changeIccPin2ForApp(int32_t serial, const ::android::hardware::hidl_string& oldPin2, const ::android::hardware::hidl_string& newPin2, const ::android::hardware::hidl_string& aid);
+
+    Return<void> supplyNetworkDepersonalization(int32_t serial, const ::android::hardware::hidl_string& netPin);
+
+    Return<void> getCurrentCalls(int32_t serial);
+
+    Return<void> dial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo);
+
+    Return<void> getImsiForApp(int32_t serial, const ::android::hardware::hidl_string& aid);
+
+    Return<void> hangup(int32_t serial, int32_t gsmIndex);
+
+    Return<void> hangupWaitingOrBackground(int32_t serial);
+
+    Return<void> hangupForegroundResumeBackground(int32_t serial);
+
+    Return<void> switchWaitingOrHoldingAndActive(int32_t serial);
+
+    Return<void> conference(int32_t serial);
+
+    Return<void> rejectCall(int32_t serial);
+
+    Return<void> getLastCallFailCause(int32_t serial);
+
+    Return<void> getSignalStrength(int32_t serial);
+
+    Return<void> getVoiceRegistrationState(int32_t serial);
+
+    Return<void> getDataRegistrationState(int32_t serial);
+
+    Return<void> getOperator(int32_t serial);
+
+    Return<void> setRadioPower(int32_t serial, bool on);
+
+    Return<void> sendDtmf(int32_t serial, const ::android::hardware::hidl_string& s);
+
+    Return<void> sendSms(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendSMSExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> setupDataCall(int32_t serial, ::android::hardware::radio::V1_0::RadioTechnology radioTechnology, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming);
+
+    Return<void> iccIOForApp(int32_t serial, const ::android::hardware::radio::V1_0::IccIo& iccIo);
+
+    Return<void> sendUssd(int32_t serial, const ::android::hardware::hidl_string& ussd);
+
+    Return<void> cancelPendingUssd(int32_t serial);
+
+    Return<void> getClir(int32_t serial);
+
+    Return<void> setClir(int32_t serial, int32_t status);
+
+    Return<void> getCallForwardStatus(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo);
+
+    Return<void> setCallForward(int32_t serial, const ::android::hardware::radio::V1_0::CallForwardInfo& callInfo);
+
+    Return<void> getCallWaiting(int32_t serial, int32_t serviceClass);
+
+    Return<void> setCallWaiting(int32_t serial, bool enable, int32_t serviceClass);
+
+    Return<void> acknowledgeLastIncomingGsmSms(int32_t serial, bool success, ::android::hardware::radio::V1_0::SmsAcknowledgeFailCause cause);
+
+    Return<void> acceptCall(int32_t serial);
+
+    Return<void> deactivateDataCall(int32_t serial, int32_t cid, bool reasonRadioShutDown);
+
+    Return<void> getFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId);
+
+    Return<void> setFacilityLockForApp(int32_t serial, const ::android::hardware::hidl_string& facility, bool lockState, const ::android::hardware::hidl_string& password, int32_t serviceClass, const ::android::hardware::hidl_string& appId);
+
+    Return<void> setBarringPassword(int32_t serial, const ::android::hardware::hidl_string& facility, const ::android::hardware::hidl_string& oldPassword, const ::android::hardware::hidl_string& newPassword);
+
+    Return<void> getNetworkSelectionMode(int32_t serial);
+
+    Return<void> setNetworkSelectionModeAutomatic(int32_t serial);
+
+    Return<void> setNetworkSelectionModeManual(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric);
+
+    Return<void> getAvailableNetworks(int32_t serial);
+
+    Return<void> startDtmf(int32_t serial, const ::android::hardware::hidl_string& s);
+
+    Return<void> stopDtmf(int32_t serial);
+
+    Return<void> getBasebandVersion(int32_t serial);
+
+    Return<void> separateConnection(int32_t serial, int32_t gsmIndex);
+
+    Return<void> setMute(int32_t serial, bool enable);
+
+    Return<void> getMute(int32_t serial);
+
+    Return<void> getClip(int32_t serial);
+
+    Return<void> getDataCallList(int32_t serial);
+
+    Return<void> setSuppServiceNotifications(int32_t serial, bool enable);
+
+    Return<void> writeSmsToSim(int32_t serial, const ::android::hardware::radio::V1_0::SmsWriteArgs& smsWriteArgs);
+
+    Return<void> deleteSmsOnSim(int32_t serial, int32_t index);
+
+    Return<void> setBandMode(int32_t serial, ::android::hardware::radio::V1_0::RadioBandMode mode);
+
+    Return<void> getAvailableBandModes(int32_t serial);
+
+    Return<void> sendEnvelope(int32_t serial, const ::android::hardware::hidl_string& command);
+
+    Return<void> sendTerminalResponseToSim(int32_t serial, const ::android::hardware::hidl_string& commandResponse);
+
+    Return<void> handleStkCallSetupRequestFromSim(int32_t serial, bool accept);
+
+    Return<void> explicitCallTransfer(int32_t serial);
+
+    Return<void> setPreferredNetworkType(int32_t serial, ::android::hardware::radio::V1_0::PreferredNetworkType nwType);
+
+    Return<void> getPreferredNetworkType(int32_t serial);
+
+    Return<void> getNeighboringCids(int32_t serial);
+
+    Return<void> setLocationUpdates(int32_t serial, bool enable);
+
+    Return<void> setCdmaSubscriptionSource(int32_t serial, ::android::hardware::radio::V1_0::CdmaSubscriptionSource cdmaSub);
+
+    Return<void> setCdmaRoamingPreference(int32_t serial, ::android::hardware::radio::V1_0::CdmaRoamingType type);
+
+    Return<void> getCdmaRoamingPreference(int32_t serial);
+
+    Return<void> setTTYMode(int32_t serial, ::android::hardware::radio::V1_0::TtyMode mode);
+
+    Return<void> getTTYMode(int32_t serial);
+
+    Return<void> setPreferredVoicePrivacy(int32_t serial, bool enable);
+
+    Return<void> getPreferredVoicePrivacy(int32_t serial);
+
+    Return<void> sendCDMAFeatureCode(int32_t serial, const ::android::hardware::hidl_string& featureCode);
+
+    Return<void> sendBurstDtmf(int32_t serial, const ::android::hardware::hidl_string& dtmf, int32_t on, int32_t off);
+
+    Return<void> sendCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> acknowledgeLastIncomingCdmaSms(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsAck& smsAck);
+
+    Return<void> getGsmBroadcastConfig(int32_t serial);
+
+    Return<void> setGsmBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::GsmBroadcastSmsConfigInfo>& configInfo);
+
+    Return<void> setGsmBroadcastActivation(int32_t serial, bool activate);
+
+    Return<void> getCdmaBroadcastConfig(int32_t serial);
+
+    Return<void> setCdmaBroadcastConfig(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::CdmaBroadcastSmsConfigInfo>& configInfo);
+
+    Return<void> setCdmaBroadcastActivation(int32_t serial, bool activate);
+
+    Return<void> getCDMASubscription(int32_t serial);
+
+    Return<void> writeSmsToRuim(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsWriteArgs& cdmaSms);
+
+    Return<void> deleteSmsOnRuim(int32_t serial, int32_t index);
+
+    Return<void> getDeviceIdentity(int32_t serial);
+
+    Return<void> exitEmergencyCallbackMode(int32_t serial);
+
+    Return<void> getSmscAddress(int32_t serial);
+
+    Return<void> setSmscAddress(int32_t serial, const ::android::hardware::hidl_string& smsc);
+
+    Return<void> reportSmsMemoryStatus(int32_t serial, bool available);
+
+    Return<void> reportStkServiceIsRunning(int32_t serial);
+
+    Return<void> getCdmaSubscriptionSource(int32_t serial);
+
+    Return<void> requestIsimAuthentication(int32_t serial, const ::android::hardware::hidl_string& challenge);
+
+    Return<void> acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success, const ::android::hardware::hidl_string& ackPdu);
+
+    Return<void> sendEnvelopeWithStatus(int32_t serial, const ::android::hardware::hidl_string& contents);
+
+    Return<void> getVoiceRadioTechnology(int32_t serial);
+
+    Return<void> getCellInfoList(int32_t serial);
+
+    Return<void> setCellInfoListRate(int32_t serial, int32_t rate);
+
+    Return<void> setInitialAttachApn(int32_t serial, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool isRoaming);
+
+    Return<void> getImsRegistrationState(int32_t serial);
+
+    Return<void> sendImsSms(int32_t serial, const ::android::hardware::radio::V1_0::ImsSmsMessage& message);
+
+    Return<void> iccTransmitApduBasicChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message);
+
+    Return<void> iccOpenLogicalChannel(int32_t serial, const ::android::hardware::hidl_string& aid, int32_t p2);
+
+    Return<void> iccCloseLogicalChannel(int32_t serial, int32_t channelId);
+
+    Return<void> iccTransmitApduLogicalChannel(int32_t serial, const ::android::hardware::radio::V1_0::SimApdu& message);
+
+    Return<void> nvReadItem(int32_t serial, ::android::hardware::radio::V1_0::NvItem itemId);
+
+    Return<void> nvWriteItem(int32_t serial, const ::android::hardware::radio::V1_0::NvWriteItem& item);
+
+    Return<void> nvWriteCdmaPrl(int32_t serial, const ::android::hardware::hidl_vec<uint8_t>& prl);
+
+    Return<void> nvResetConfig(int32_t serial, ::android::hardware::radio::V1_0::ResetNvType resetType);
+
+    Return<void> setUiccSubscription(int32_t serial, const ::android::hardware::radio::V1_0::SelectUiccSub& uiccSub);
+
+    Return<void> setDataAllowed(int32_t serial, bool allow);
+
+    Return<void> getHardwareConfig(int32_t serial);
+
+    Return<void> requestIccSimAuthentication(int32_t serial, int32_t authContext, const ::android::hardware::hidl_string& authData, const ::android::hardware::hidl_string& aid);
+
+    Return<void> setDataProfile(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_0::DataProfileInfo>& profiles, bool isRoaming);
+
+    Return<void> requestShutdown(int32_t serial);
+
+    Return<void> getRadioCapability(int32_t serial);
+
+    Return<void> setRadioCapability(int32_t serial, const ::android::hardware::radio::V1_0::RadioCapability& rc);
+
+    Return<void> startLceService(int32_t serial, int32_t reportInterval, bool pullMode);
+
+    Return<void> stopLceService(int32_t serial);
+
+    Return<void> pullLceData(int32_t serial);
+
+    Return<void> getModemActivityInfo(int32_t serial);
+
+    Return<void> setAllowedCarriers(int32_t serial, bool allAllowed, const ::android::hardware::radio::V1_0::CarrierRestrictions& carriers);
+
+    Return<void> getAllowedCarriers(int32_t serial);
+
+    Return<void> sendDeviceState(int32_t serial, ::android::hardware::radio::V1_0::DeviceStateType deviceStateType, bool state);
+
+    Return<void> setIndicationFilter(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_0::IndicationFilter> indicationFilter);
+
+    Return<void> setSimCardPower(int32_t serial, bool powerUp);
+
+    Return<void> responseAcknowledgement();
+
+    Return<void> setCarrierInfoForImsiEncryption(int32_t serial, const ::android::hardware::radio::V1_1::ImsiEncryptionInfo& imsiEncryptionInfo);
+
+    Return<void> setSimCardPower_1_1(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp);
+
+    Return<void> startNetworkScan(int32_t serial, const ::android::hardware::radio::V1_1::NetworkScanRequest& request);
+
+    Return<void> stopNetworkScan(int32_t serial);
+
+    Return<void> startKeepalive(int32_t serial, const ::android::hardware::radio::V1_1::KeepaliveRequest& keepalive);
+
+    Return<void> stopKeepalive(int32_t serial, int32_t sessionHandle);
+
+    Return<void> startNetworkScan_1_2(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
+
+    Return<void> setIndicationFilter_1_2(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_2::IndicationFilter> indicationFilter);
+
+    Return<void> setSignalStrengthReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDb, const ::android::hardware::hidl_vec<int32_t>& thresholdsDbm, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
+
+    Return<void> setLinkCapacityReportingCriteria(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
+
+    Return<void> setupDataCall_1_2(int32_t serial, ::android::hardware::radio::V1_2::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive, bool roamingAllowed, bool isRoaming, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> deactivateDataCall_1_2(int32_t serial, int32_t cid, ::android::hardware::radio::V1_2::DataRequestReason reason);
+
+    Return<void> setSystemSelectionChannels(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& specifiers);
+
+    Return<void> enableModem(int32_t serial, bool on);
+
+    Return<void> getModemStackStatus(int32_t serial);
+
+    Return<void> setupDataCall_1_4(int32_t serial, ::android::hardware::radio::V1_4::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> setInitialAttachApn_1_4(int32_t serial, const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo);
+
+    Return<void> setDataProfile_1_4(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& profiles);
+
+    Return<void> emergencyDial(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting);
+
+    Return<void> startNetworkScan_1_4(int32_t serial, const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
+
+    Return<void> getPreferredNetworkTypeBitmap(int32_t serial);
+
+    Return<void> setPreferredNetworkTypeBitmap(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> setAllowedCarriers_1_4(int32_t serial, const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers, ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy);
+
+    Return<void> getAllowedCarriers_1_4(int32_t serial);
+
+    Return<void> getSignalStrength_1_4(int32_t serial);
+
+    Return<void> setSignalStrengthReportingCriteria_1_5(int32_t serial, const ::android::hardware::radio::V1_5::SignalThresholdInfo& signalThresholdInfo, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork);
+
+    Return<void> setLinkCapacityReportingCriteria_1_5(int32_t serial, int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsDownlinkKbps, const ::android::hardware::hidl_vec<int32_t>& thresholdsUplinkKbps, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork);
+
+    Return<void> enableUiccApplications(int32_t serial, bool enable);
+
+    Return<void> areUiccApplicationsEnabled(int32_t serial);
+
+    Return<void> setSystemSelectionChannels_1_5(int32_t serial, bool specifyChannels, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers);
+
+    Return<void> startNetworkScan_1_5(int32_t serial, const ::android::hardware::radio::V1_5::NetworkScanRequest& request);
+
+    Return<void> setupDataCall_1_5(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses);
+
+    Return<void> setInitialAttachApn_1_5(int32_t serial, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo);
+
+    Return<void> setDataProfile_1_5(int32_t serial, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& profiles);
+
+    Return<void> setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall);
+
+    Return<void> setIndicationFilter_1_5(int32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter);
+
+    Return<void> getBarringInfo(int32_t serial);
+
+    Return<void> getVoiceRegistrationState_1_5(int32_t serial);
+
+    Return<void> getDataRegistrationState_1_5(int32_t serial);
+
+    Return<void> setNetworkSelectionModeManual_1_5(int32_t serial, const ::android::hardware::hidl_string& operatorNumeric, ::android::hardware::radio::V1_5::RadioAccessNetworks ran);
+
+    Return<void> sendCdmaSmsExpectMore(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> supplySimDepersonalization(int32_t serial, ::android::hardware::radio::V1_5::PersoSubstate persoType, const ::android::hardware::hidl_string& controlKey);
+
+    Return<void> setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall, bool preferredForEmergencyCall);
+
+    Return<void> getDataCallList_1_6(int32_t serial);
+
+    Return<void> setupDataCall_1_6(int32_t serial, ::android::hardware::radio::V1_5::AccessNetwork accessNetwork, const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo, bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason, const ::android::hardware::hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& dnses, int32_t pduSessionId, const ::android::hardware::radio::V1_6::OptionalSliceInfo& sliceInfo, const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& trafficDescriptor, bool matchAllRuleAllowed);
+
+    Return<void> sendSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::GsmSmsMessage& message);
+
+    Return<void> sendCdmaSms_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> sendCdmaSmsExpectMore_1_6(int32_t serial, const ::android::hardware::radio::V1_0::CdmaSmsMessage& sms);
+
+    Return<void> setSimCardPower_1_6(int32_t serial, ::android::hardware::radio::V1_1::CardPowerState powerUp);
+
+    Return<void> setNrDualConnectivityState(int32_t serial, ::android::hardware::radio::V1_6::NrDualConnectivityState nrDualConnectivityState);
+
+    Return<void> isNrDualConnectivityEnabled(int32_t serial);
+
+    Return<void> allocatePduSessionId(int32_t serial);
+
+    Return<void> releasePduSessionId(int32_t serial, int32_t id);
+
+    Return<void> startHandover(int32_t serial, int32_t callId);
+
+    Return<void> cancelHandover(int32_t serial, int32_t callId);
+
+    Return<void> setAllowedNetworkTypesBitmap(uint32_t serial, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
+
+    Return<void> getAllowedNetworkTypesBitmap(int32_t serial);
+
+    Return<void> setDataThrottling(int32_t serial, ::android::hardware::radio::V1_6::DataThrottlingAction dataThrottlingAction, int64_t completionDurationMillis);
+
+    Return<void> emergencyDial_1_6(int32_t serial, const ::android::hardware::radio::V1_0::Dial& dialInfo, ::android::hardware::hidl_bitfield<::android::hardware::radio::V1_4::EmergencyServiceCategory> categories, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& urns, ::android::hardware::radio::V1_4::EmergencyCallRouting routing, bool hasKnownUserIntentEmergency, bool isTesting);
+
+    Return<void> getSystemSelectionChannels(int32_t serial);
+
+    Return<void> getCellInfoList_1_6(int32_t serial);
+
+    Return<void> getVoiceRegistrationState_1_6(int32_t serial);
+
+    Return<void> getSignalStrength_1_6(int32_t serial);
+
+    Return<void> getDataRegistrationState_1_6(int32_t serial);
+
+    Return<void> getCurrentCalls_1_6(int32_t serial);
+
+    Return<void> getSlicingConfig(int32_t serial);
+
+    Return<void> setCarrierInfoForImsiEncryption_1_6(int32_t serial, const ::android::hardware::radio::V1_6::ImsiEncryptionInfo& imsiEncryptionInfo);
+
+    Return<void> getSimPhonebookRecords(int32_t serial);
+
+    Return<void> getSimPhonebookCapacity(int32_t serial);
+
+    Return<void> updateSimPhonebookRecords(int32_t serial, const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo);
+
+    Return<void> interfaceChain(interfaceChain_cb _hidl_cb);
+
+    Return<void> debug(const ::android::hardware::hidl_handle& fd, const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& options);
+
+    Return<void> interfaceDescriptor(interfaceDescriptor_cb _hidl_cb);
+
+    Return<void> getHashChain(getHashChain_cb _hidl_cb);
+
+    Return<void> setHALInstrumentation();
+
+    Return<void> ping();
+
+    Return<void> getDebugInfo(getDebugInfo_cb _hidl_cb);
+
+    Return<void> notifySyspropsChanged();
+};
\ No newline at end of file
-- 
2.17.1

