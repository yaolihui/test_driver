diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index 8cd346d0546e..3a209d8d9914 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -1,3 +1,4 @@
+CONFIG_SYSVIPC=y
 CONFIG_AUDIT=y
 CONFIG_NO_HZ=y
 CONFIG_HIGH_RES_TIMERS=y
@@ -25,7 +26,8 @@ CONFIG_CPUSETS=y
 CONFIG_CGROUP_CPUACCT=y
 CONFIG_CGROUP_BPF=y
 CONFIG_NAMESPACES=y
-# CONFIG_PID_NS is not set
+CONFIG_USER_NS=y
+CONFIG_DRV_NS=y
 CONFIG_RT_SOFTINT_OPTIMIZATION=y
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index f0d8989a2130..cea34760b5e6 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -77,6 +77,12 @@
 #include "binder_trace.h"
 #include <trace/hooks/binder.h>
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 static HLIST_HEAD(binder_deferred_list);
 static DEFINE_MUTEX(binder_deferred_lock);
 
@@ -220,6 +226,53 @@ static struct binder_transaction_log_entry *binder_transaction_log_add(
 	return e;
 }
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+struct binder_drv_ns {
+	struct drv_ns_info	drv_ns_info;
+};
+static void binder_ns_initialize(struct binder_drv_ns *binder_ns)
+{
+}
+/* binder_ns_id, get_binder_ns(), get_binder_ns_cur(), put_binder_ns() */
+DEFINE_DRV_NS_INFO(binder)
+static struct drv_ns_info *binder_ns_create(struct drv_namespace *drv_ns)
+{
+	struct binder_drv_ns *binder_ns;
+	binder_ns = kzalloc(sizeof(*binder_ns), GFP_KERNEL);
+	if (!binder_ns)
+		return ERR_PTR(-ENOMEM);
+	binder_ns_initialize(binder_ns);
+	return &binder_ns->drv_ns_info;
+}
+static void binder_ns_release(struct drv_ns_info *drv_ns_info)
+{
+	struct binder_drv_ns *binder_ns;
+	binder_ns = container_of(drv_ns_info, struct binder_drv_ns,
+				 drv_ns_info);
+	kfree(binder_ns);
+}
+static struct drv_ns_ops binder_ns_ops = {
+	.create = binder_ns_create,
+	.release = binder_ns_release,
+};
+#define INIT_OTHER_CONTEXT_MGR_HANDLE 100000000
+static inline int current_drv_ns_cell_index(void)
+{
+	char tag[DRV_NS_TAG_LEN];
+	int i = 0;
+	if(current_drv_ns() == &init_drv_ns)
+		return 0;
+	for(i = 1; i < MAX_CONTEXT; i++){
+		sprintf(tag, "cell%d", i);
+		if(strncmp(current_drv_ns()->tag, tag, DRV_NS_TAG_LEN) == 0)
+			return i;
+	}
+	return -1;
+}
+#endif /* CONFIG_DRV_NS */
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 enum binder_deferred_state {
 	BINDER_DEFERRED_FLUSH        = 0x01,
 	BINDER_DEFERRED_RELEASE      = 0x02,
@@ -959,6 +1012,21 @@ static void binder_free_node(struct binder_node *node)
 	binder_stats_deleted(BINDER_STAT_NODE);
 }
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+static int mgr_node(struct binder_node *node)
+{
+	int i = 0;
+	for(i = 0; i < MAX_CONTEXT; i++)
+	{
+		if(node == node->proc->acontext[i]->binder_context_mgr_node)
+			return 1;
+	}
+	return 0;
+}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 static int binder_inc_node_nilocked(struct binder_node *node, int strong,
 				    int internal,
 				    struct list_head *target_list)
@@ -972,9 +1040,15 @@ static int binder_inc_node_nilocked(struct binder_node *node, int strong,
 		if (internal) {
 			if (target_list == NULL &&
 			    node->internal_strong_refs == 0 &&
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+				!(node->proc && mgr_node(node) && node->has_strong_ref)) {
+#else
 			    !(node->proc &&
 			      node == node->proc->context->binder_context_mgr_node &&
 			      node->has_strong_ref)) {
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 				pr_err("invalid inc strong node for %d\n",
 					node->debug_id);
 				return -EINVAL;
@@ -1218,6 +1292,11 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 	struct rb_node *parent = NULL;
 	struct binder_ref *ref;
 	struct rb_node *n;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	while (*p) {
 		parent = *p;
@@ -1240,6 +1319,30 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 	rb_link_node(&new_ref->rb_node_node, parent, p);
 	rb_insert_color(&new_ref->rb_node_node, &proc->refs_by_node);
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	new_ref->data.desc = 1;
+	for(i = 0; i < MAX_CONTEXT; i++)
+	{
+		if(node == proc->acontext[i]->binder_context_mgr_node){
+			new_ref->data.desc = INIT_OTHER_CONTEXT_MGR_HANDLE + i;
+			break;
+		}
+	}
+	if(node == context->binder_context_mgr_node)
+		new_ref->data.desc = 0;
+	if(new_ref->data.desc < INIT_OTHER_CONTEXT_MGR_HANDLE)
+	{
+		for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
+			ref = rb_entry(n, struct binder_ref, rb_node_desc);
+			if(ref->data.desc  >= INIT_OTHER_CONTEXT_MGR_HANDLE)
+				continue;
+			if (ref->data.desc > new_ref->data.desc)
+				break;
+			new_ref->data.desc = ref->data.desc + 1;
+		}
+	}
+#else
 	new_ref->data.desc = (node == context->binder_context_mgr_node) ? 0 : 1;
 	for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
 		ref = rb_entry(n, struct binder_ref, rb_node_desc);
@@ -1247,6 +1350,8 @@ static struct binder_ref *binder_get_ref_for_node_olocked(
 			break;
 		new_ref->data.desc = ref->data.desc + 1;
 	}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	p = &proc->refs_by_desc.rb_node;
 	while (*p) {
@@ -3097,7 +3202,31 @@ static void binder_transaction(struct binder_proc *proc,
 		binder_inner_proc_unlock(target_thread->proc);
 		trace_android_vh_binder_reply(target_proc, proc, thread, tr);
 	} else {
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if(tr->target.handle >= INIT_OTHER_CONTEXT_MGR_HANDLE){
+			mutex_lock(&proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			target_node = proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->binder_context_mgr_node;
+			if (target_node)
+				target_node = binder_get_node_refs_for_txn(
+						target_node, &target_proc,
+						&return_error);
+			else
+				return_error = BR_DEAD_REPLY;
+			mutex_unlock(&proc->acontext[tr->target.handle - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			if (target_node && target_proc->pid == proc->pid) {
+				binder_user_error("%d:%d got transaction to context manager from process owning it\n",
+						  proc->pid, thread->pid);
+				return_error = BR_FAILED_REPLY;
+				return_error_param = -EINVAL;
+				return_error_line = __LINE__;
+				goto err_invalid_target_handle;
+			}
+		}else if (tr->target.handle) {
+#else
 		if (tr->target.handle) {
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 			struct binder_ref *ref;
 
 			/*
@@ -3143,6 +3272,9 @@ static void binder_transaction(struct binder_proc *proc,
 			/*
 			 * return_error is set above
 			 */
+			/* Begin: xdja.lxl modify for dual-system on 20231026 */
+            binder_user_error("container:%d", tr->target.handle);
+			/* End: xdja.lxl modify for dual-system on 20231026 */
 			return_error_param = -EINVAL;
 			return_error_line = __LINE__;
 			goto err_dead_binder;
@@ -3914,7 +4046,23 @@ static int binder_thread_write(struct binder_proc *proc,
 
 			ptr += sizeof(uint32_t);
 			ret = -1;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+			if (increment && target >= INIT_OTHER_CONTEXT_MGR_HANDLE) {
+				struct binder_node *ctx_mgr_node;
+				mutex_lock(&proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+				ctx_mgr_node = proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->binder_context_mgr_node;
+				if (ctx_mgr_node) {
+					ret = binder_inc_ref_for_node(
+							proc, ctx_mgr_node,
+							strong, NULL, &rdata);
+				}
+				mutex_unlock(&proc->acontext[target - INIT_OTHER_CONTEXT_MGR_HANDLE]->context_mgr_node_lock);
+			} else if (increment && !target) {
+#else
 			if (increment && !target) {
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 				struct binder_node *ctx_mgr_node;
 				mutex_lock(&context->context_mgr_node_lock);
 				ctx_mgr_node = context->binder_context_mgr_node;
@@ -4995,7 +5143,13 @@ static void binder_free_proc(struct binder_proc *proc)
 	if (proc->outstanding_txns)
 		pr_warn("%s: Unexpected outstanding_txns %d\n",
 			__func__, proc->outstanding_txns);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	device = container_of(proc->context, struct binder_device, context[0]);
+#else
 	device = container_of(proc->context, struct binder_device, context);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	if (refcount_dec_and_test(&device->ref)) {
 		kfree(proc->context->name);
 		kfree(device);
@@ -5692,6 +5846,11 @@ static int binder_open(struct inode *nodp, struct file *filp)
 	struct binderfs_info *info;
 	struct dentry *binder_binderfs_dir_entry_proc = NULL;
 	bool existing_pid = false;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	binder_debug(BINDER_DEBUG_OPEN_CLOSE, "%s: %d:%d\n", __func__,
 		     current->group_leader->pid, current->pid);
@@ -5724,7 +5883,21 @@ static int binder_open(struct inode *nodp, struct file *filp)
 					  struct binder_device, miscdev);
 	}
 	refcount_inc(&binder_dev->ref);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	for(i = 0; i < MAX_CONTEXT; i++){
+		proc->acontext[i] = &binder_dev->context[i];
+	}
+	i = current_drv_ns_cell_index();
+	if( i >= 0 && i < MAX_CONTEXT){
+		proc->context = proc->acontext[i];
+	}else{
+		proc->context = NULL;
+	}
+#else
 	proc->context = &binder_dev->context;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	binder_alloc_init(&proc->alloc);
 
 	binder_stats_created(BINDER_STAT_PROC);
@@ -6610,6 +6783,11 @@ static int __init init_binder_device(const char *name)
 {
 	int ret;
 	struct binder_device *binder_device;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	int i;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL);
 	if (!binder_device)
@@ -6620,9 +6798,20 @@ static int __init init_binder_device(const char *name)
 	binder_device->miscdev.name = name;
 
 	refcount_set(&binder_device->ref, 1);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	for(i = 0; i < MAX_CONTEXT; i++){
+		binder_device->context[i].binder_context_mgr_uid = INVALID_UID;
+		binder_device->context[i].name = name;
+		binder_device->context[i].binder_context_mgr_node = NULL;
+		mutex_init(&binder_device->context[i].context_mgr_node_lock);
+	}
+#else
 	binder_device->context.binder_context_mgr_uid = INVALID_UID;
 	binder_device->context.name = name;
 	mutex_init(&binder_device->context.context_mgr_node_lock);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	ret = misc_register(&binder_device->miscdev);
 	if (ret < 0) {
@@ -6649,6 +6838,14 @@ static int __init binder_init(void)
 
 	atomic_set(&binder_transaction_log.cur, ~0U);
 	atomic_set(&binder_transaction_log_failed.cur, ~0U);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	ret = DRV_NS_REGISTER(binder, "binder");
+	if (ret < 0) {
+		return -ENOMEM;
+	}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	binder_debugfs_dir_entry_root = debugfs_create_dir("binder", NULL);
 	if (binder_debugfs_dir_entry_root) {
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index 5bbd87dd6c25..80e3016477c6 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -15,6 +15,12 @@
 #include <uapi/linux/android/binderfs.h>
 #include "binder_alloc.h"
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#define MAX_CONTEXT 6
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 struct binder_context {
 	struct binder_node *binder_context_mgr_node;
 	struct mutex context_mgr_node_lock;
@@ -34,7 +40,13 @@ struct binder_context {
 struct binder_device {
 	struct hlist_node hlist;
 	struct miscdevice miscdev;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	struct binder_context context[MAX_CONTEXT];
+#else
 	struct binder_context context;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	struct inode *binderfs_inode;
 	refcount_t ref;
 };
@@ -455,6 +467,11 @@ struct binder_proc {
 	struct dentry *debugfs_entry;
 	struct binder_alloc alloc;
 	struct binder_context *context;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	struct binder_context *acontext[MAX_CONTEXT];
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	spinlock_t inner_lock;
 	spinlock_t outer_lock;
 	struct dentry *binderfs_entry;
diff --git a/drivers/android/binderfs.c b/drivers/android/binderfs.c
index 8d4eb491d4a6..e335bd138dfc 100644
--- a/drivers/android/binderfs.c
+++ b/drivers/android/binderfs.c
@@ -125,6 +125,11 @@ static int binderfs_binder_device_create(struct inode *ref_inode,
 #else
 	bool use_reserve = true;
 #endif
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	int i = 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	/* Reserve new minor number for the new device. */
 	mutex_lock(&binderfs_minors_mutex);
@@ -168,11 +173,26 @@ static int binderfs_binder_device_create(struct inode *ref_inode,
 
 	refcount_set(&device->ref, 1);
 	device->binderfs_inode = inode;
-	device->context.binder_context_mgr_uid = INVALID_UID;
-	device->context.name = name;
+    /* Begin: xdja.lxl deleted for dual-system on 20231026 */
+	// device->context.binder_context_mgr_uid = INVALID_UID;
+	// device->context.name = name;
+    /* Begin: xdja.lxl deleted for dual-system on 20231026 */
 	device->miscdev.name = name;
 	device->miscdev.minor = minor;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		device->context[i].binder_context_mgr_uid = INVALID_UID;
+		device->context[i].name = name;
+		device->context[i].binder_context_mgr_node = NULL;
+		mutex_init(&device->context[i].context_mgr_node_lock);
+	}
+#else
+	device->context.binder_context_mgr_uid = INVALID_UID;
+	device->context.name = name;
 	mutex_init(&device->context.context_mgr_node_lock);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	req->major = MAJOR(binderfs_dev);
 	req->minor = minor;
@@ -271,7 +291,13 @@ static void binderfs_evict_inode(struct inode *inode)
 	mutex_unlock(&binderfs_minors_mutex);
 
 	if (refcount_dec_and_test(&device->ref)) {
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		kfree(device->context[0].name);
+#else
 		kfree(device->context.name);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		kfree(device);
 	}
 }
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4b030cf65bb2..1b839ff854db 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -29,10 +29,33 @@
 #include <linux/sched/mm.h>
 #include <linux/swiotlb.h>
 #include <linux/sysfs.h>
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 #include "base.h"
 #include "power/power.h"
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+struct drv_namespace init_drv_ns = {
+	.active = true,
+	.count = ATOMIC_INIT(2),  /* extra reference for active_dev_ns */
+	.pid_ns = &init_pid_ns,
+	.tag = { 'i', 'n', 'i', 't', 0 },
+	.notifiers = BLOCKING_NOTIFIER_INIT(init_drv_ns.notifiers),
+	.timestamp = 0,
+	.mutex = __MUTEX_INITIALIZER(init_drv_ns.mutex),
+	.info = { NULL },
+};
+EXPORT_SYMBOL_GPL(init_drv_ns);
+struct drv_namespace *active_drv_ns = &init_drv_ns;
+EXPORT_SYMBOL_GPL(active_drv_ns);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 #ifdef CONFIG_SYSFS_DEPRECATED
 #ifdef CONFIG_SYSFS_DEPRECATED_V2
 long sysfs_deprecated = 1;
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 95f90699d2b1..9913face87b2 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -24,6 +24,11 @@
 #include <linux/device.h>
 #include <linux/cdev.h>
 #include "input-compat.h"
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 struct evdev {
 	int open;
@@ -36,6 +41,11 @@ struct evdev {
 	struct cdev cdev;
 	bool exist;
 };
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+struct evdev_drv_ns;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 struct evdev_client {
 	unsigned int head;
@@ -45,6 +55,15 @@ struct evdev_client {
 	wait_queue_head_t wait;
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	struct evdev_drv_ns *evdev_ns;
+	struct list_head list;
+	bool grab;
+	struct list_head keys_down;
+	bool is_always_active;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	struct list_head node;
 	enum input_clock_type clk_type;
 	bool revoked;
@@ -53,6 +72,189 @@ struct evdev_client {
 	struct input_event buffer[];
 };
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+struct evdev_drv_ns {
+	struct mutex mutex;
+	struct list_head clients;
+	struct drv_ns_info drv_ns_info;
+};
+struct keydown {
+	u16 code;
+	struct list_head link;
+};
+static void set_keydown(struct evdev_client *client, u16 code)
+{
+	struct keydown *kd;
+	list_for_each_entry(kd, &client->keys_down, link) {
+		if (kd->code == code)
+			return;
+	}
+	kd = kmalloc(sizeof(*kd), GFP_ATOMIC);
+	if (!kd)
+		return;
+	kd->code = code;
+	list_add(&kd->link, &client->keys_down);
+}
+static void clear_keydown(struct evdev_client *client, u16 code)
+{
+	struct keydown *kd, *n;
+	list_for_each_entry_safe(kd, n, &client->keys_down, link) {
+		if (kd->code == code) {
+			list_del(&kd->link);
+			kfree(kd);
+			return;
+		}
+	}
+}
+/* evdev_ns_id, get_evdev_ns(), get_evdev_ns_cur(), put_evdev_ns() */
+DEFINE_DRV_NS_INFO(evdev)
+static bool is_always_active_evdev(struct evdev_client *client){
+	static char *always_active_evdev[] = {
+		"STM VL53L0 proximity sensor",
+		"sdm670-intcodec-b4-snd-card Headset Jack",
+		"sdm670-intcodec-b4-snd-card Button Jack",
+		NULL
+	};
+	char **evdevname;
+	for (evdevname = always_active_evdev; *evdevname != NULL; evdevname++){
+		if(strncmp(client->evdev->handle.dev->name, *evdevname, strlen(*evdevname)) == 0)
+			return true;
+	}
+	return false;
+}
+/* indicate whether an evdev client is in the foreground */
+static bool evdev_client_is_active(struct evdev_client *client)
+{
+	return client->is_always_active || is_active_evdev_drv_ns(client->evdev_ns);
+}
+static struct notifier_block evdev_ns_switch_notifier;
+static int evdev_grab(struct evdev *evdev, struct evdev_client *client);
+static int evdev_ungrab(struct evdev *evdev, struct evdev_client *client);
+static void __pass_event(struct evdev_client *client,const struct input_event *event);
+/* evdev_ns helpers */
+static struct drv_ns_info *evdev_drvns_create(struct drv_namespace *drv_ns)
+{
+	struct evdev_drv_ns *evdev_ns;
+	struct drv_ns_info *drv_ns_info;
+	evdev_ns = kzalloc(sizeof(*evdev_ns), GFP_KERNEL);
+	if (!evdev_ns)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&evdev_ns->mutex);
+	INIT_LIST_HEAD(&evdev_ns->clients);
+	pr_info("new evdev_drv_ns %p (d %p)\n", evdev_ns, drv_ns);
+	drv_ns_info = &evdev_ns->drv_ns_info;
+	drv_ns_info->nb = evdev_ns_switch_notifier;
+	drv_ns_register_notify(drv_ns, &drv_ns_info->nb);
+	return &evdev_ns->drv_ns_info;
+}
+static void evdev_drvns_release(struct drv_ns_info *drv_ns_info)
+{
+	struct evdev_drv_ns *evdev_ns;
+	evdev_ns = container_of(drv_ns_info, struct evdev_drv_ns, drv_ns_info);
+	pr_info("del evdev_drv_ns %p (d %p)\n", evdev_ns, drv_ns_info->drv_ns);
+	drv_ns_unregister_notify(drv_ns_info->drv_ns, &drv_ns_info->nb);
+	kfree(evdev_ns);
+}
+static struct drv_ns_ops evdev_ns_ops = {
+	.create = evdev_drvns_create,
+	.release = evdev_drvns_release,
+};
+static int evdev_ns_track_client(struct evdev_client *client)
+{
+	struct evdev_drv_ns *evdev_ns;
+	evdev_ns = get_evdev_ns_cur();
+	if (!evdev_ns)
+		return -ENOMEM;
+	//pr_info("track new client 0x%p in evdev_ns 0x%p (drv_ns 0x%p)\n",
+	//	client, evdev_ns, evdev_ns->drv_ns_info.drv_ns);
+	client->is_always_active = is_always_active_evdev(client);
+	client->evdev_ns = evdev_ns;
+	client->grab = false;
+	INIT_LIST_HEAD(&client->keys_down);
+	mutex_lock(&evdev_ns->mutex);
+	list_add(&client->list, &evdev_ns->clients);
+	mutex_unlock(&evdev_ns->mutex);
+	return 0;
+}
+static void evdev_ns_untrack_client(struct evdev_client *client)
+{
+	struct evdev_drv_ns *evdev_ns;
+	evdev_ns = client->evdev_ns;
+	//pr_info("untrack client 0x%p in evdev_ns 0x%p (drv_ns 0x%p)\n",
+	//	client, evdev_ns, evdev_ns->drv_ns_info.drv_ns);
+	mutex_lock(&evdev_ns->mutex);
+	list_del(&client->list);
+	mutex_unlock(&evdev_ns->mutex);
+	put_evdev_ns(evdev_ns);
+}
+/* drv_ns and resepctive fb_drv_ns protected by caller */
+static int evdev_ns_switch_callback(struct notifier_block *self,
+				    unsigned long action, void *data)
+{
+	struct drv_namespace *drv_ns = data;
+	struct evdev_drv_ns *evdev_ns;
+	struct evdev_client *client;
+	struct keydown *kd, *n;
+	struct input_event event;
+	ktime_t *ev_time = NULL;
+	struct timespec64 ts;
+	evdev_ns = find_evdev_ns(drv_ns);
+	WARN(evdev_ns == NULL, "drvns 0x%p: no matching evdev_ns\n", drv_ns);
+	mutex_lock(&evdev_ns->mutex);
+	switch (action) {
+	case DRV_NS_EVENT_ACTIVATE:
+		list_for_each_entry(client, &evdev_ns->clients, list)
+		{
+			mutex_lock(&client->evdev->mutex);
+			if (client->grab)
+				evdev_grab(client->evdev, client);
+			mutex_unlock(&client->evdev->mutex);
+		}
+		break;
+	case DRV_NS_EVENT_DEACTIVATE:
+		event.type = EV_KEY;
+		event.value = 0;
+		event.code = 0;
+		list_for_each_entry(client, &evdev_ns->clients, list)
+		{
+			if(!ev_time){
+				ev_time = input_get_timestamp(client->evdev->handle.dev);
+				ts = ktime_to_timespec64(ev_time[client->clk_type]);
+			}
+			/* release any pressed keys in the inactive client */
+			list_for_each_entry_safe(kd, n, &client->keys_down, link) {
+				event.code = kd->code;
+				event.input_event_sec = ts.tv_sec;
+				event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;
+				//event.time = ktime_to_timeval(ev_time[client->clk_type]);
+				pr_info("sending code %d KEY_UP to %s",kd->code, drv_ns->tag);
+				__pass_event(client, &event);
+			}
+			if (event.code) {
+				event.code = SYN_REPORT;
+				event.input_event_sec = ts.tv_sec;
+				event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;
+				//event.time = ktime_to_timeval(ev_time[client->clk_type]);
+				__pass_event(client, &event);
+				wake_up_interruptible(&client->wait);
+			}
+			mutex_lock(&client->evdev->mutex);
+			if (client->evdev->grab == client)
+				evdev_ungrab(client->evdev, client);
+			mutex_unlock(&client->evdev->mutex);
+		}
+		break;
+	}
+	mutex_unlock(&evdev_ns->mutex);
+	return 0;
+}
+static struct notifier_block evdev_ns_switch_notifier = {
+	.notifier_call = evdev_ns_switch_callback,
+};
+#endif /* CONFIG_DRV_NS */
+/* End: xdja.lxl modify for dual-system on 20231026 */
+
 static size_t evdev_get_mask_cnt(unsigned int type)
 {
 	static const size_t counts[EV_CNT] = {
@@ -239,6 +441,16 @@ static void __pass_event(struct evdev_client *client,
 		client->packet_head = client->head;
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	if (event->type == EV_KEY) {
+		if (event->value)
+			set_keydown(client, event->code);
+		else
+			clear_keydown(client, event->code);
+	}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 }
 
 static void evdev_pass_values(struct evdev_client *client,
@@ -302,9 +514,15 @@ static void evdev_events(struct input_handle *handle,
 	if (client)
 		evdev_pass_values(client, vals, count, ev_time);
 	else
-		list_for_each_entry_rcu(client, &evdev->client_list, node)
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+		list_for_each_entry_rcu(client, &evdev->client_list, node){
+#ifdef CONFIG_DRV_NS
+			if (!evdev_client_is_active(client))
+				continue;
+#endif
 			evdev_pass_values(client, vals, count, ev_time);
-
+        }
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	rcu_read_unlock();
 }
 
@@ -349,6 +567,11 @@ static int evdev_grab(struct evdev *evdev, struct evdev_client *client)
 	if (error)
 		return error;
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	client->grab = true;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	rcu_assign_pointer(evdev->grab, client);
 
 	return 0;
@@ -362,6 +585,11 @@ static int evdev_ungrab(struct evdev *evdev, struct evdev_client *client)
 	if (grab != client)
 		return  -EINVAL;
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	client->grab = false;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	rcu_assign_pointer(evdev->grab, NULL);
 	synchronize_rcu();
 	input_release_device(&evdev->handle);
@@ -446,6 +674,11 @@ static int evdev_release(struct inode *inode, struct file *file)
 	evdev_ungrab(evdev, client);
 	mutex_unlock(&evdev->mutex);
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	evdev_ns_untrack_client(client);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	evdev_detach_client(evdev, client);
 
 	for (i = 0; i < EV_CNT; ++i)
@@ -482,6 +715,14 @@ static int evdev_open(struct inode *inode, struct file *file)
 	client->bufsize = bufsize;
 	spin_lock_init(&client->buffer_lock);
 	client->evdev = evdev;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	error = evdev_ns_track_client(client);
+	if (error)
+		goto err_free_client;
+	pr_info("evdev_client:%s is_always_active=%d \n",evdev->handle.dev->name,client->is_always_active);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	evdev_attach_client(evdev, client);
 
 	error = evdev_open_device(evdev);
@@ -494,6 +735,11 @@ static int evdev_open(struct inode *inode, struct file *file)
 	return 0;
 
  err_free_client:
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	evdev_ns_untrack_client(client);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	evdev_detach_client(evdev, client);
 	kvfree(client);
 	return error;
@@ -527,6 +773,12 @@ static ssize_t evdev_write(struct file *file, const char __user *buffer,
 		}
 		retval += input_event_size();
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			continue;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		input_inject_event(&evdev->handle,
 				   event.type, event.code, event.value);
 		cond_resched();
@@ -1068,12 +1320,24 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		if (get_user(v, ip + 1))
 			return -EFAULT;
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		input_inject_event(&evdev->handle, EV_REP, REP_DELAY, u);
 		input_inject_event(&evdev->handle, EV_REP, REP_PERIOD, v);
 
 		return 0;
 
 	case EVIOCRMFF:
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		return input_ff_erase(dev, (int)(unsigned long) p, file);
 
 	case EVIOCGEFFECTS:
@@ -1084,6 +1348,17 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return 0;
 
 	case EVIOCGRAB:
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client)) {
+			if (p)
+				client->grab = true;
+			else
+				client->grab = false;
+			return 0;
+		} /* else */
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		if (p)
 			return evdev_grab(evdev, client);
 		else
@@ -1129,6 +1404,12 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return evdev_handle_get_keycode(dev, p);
 
 	case EVIOCSKEYCODE:
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		return evdev_handle_set_keycode(dev, p);
 
 	case EVIOCGKEYCODE_V2:
@@ -1177,6 +1458,12 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return str_to_user(dev->uniq, size, p);
 
 	case EVIOC_MASK_SIZE(EVIOCSFF):
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 		if (input_ff_effect_from_user(p, size, &effect))
 			return -EFAULT;
 
@@ -1218,6 +1505,12 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 	}
 
 	if (_IOC_DIR(cmd) == _IOC_WRITE) {
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (!evdev_client_is_active(client))
+			return 0;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 		if ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCSABS(0))) {
 
@@ -1430,11 +1723,29 @@ static struct input_handler evdev_handler = {
 
 static int __init evdev_init(void)
 {
-	return input_register_handler(&evdev_handler);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+	int ret;
+	ret = input_register_handler(&evdev_handler);
+	if (ret < 0)
+		return ret;
+#ifdef CONFIG_DRV_NS
+	ret = DRV_NS_REGISTER(evdev, "evdev");
+	if (ret < 0) {
+		input_unregister_handler(&evdev_handler);
+		return ret;
+	}
+#endif
+	return ret;
+/* End: xdja.lxl modify for dual-system on 20231026 */
 }
 
 static void __exit evdev_exit(void)
 {
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	DRV_NS_UNREGISTER(evdev);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	input_unregister_handler(&evdev_handler);
 }
 
diff --git a/include/linux/drv_namespace.h b/include/linux/drv_namespace.h
new file mode 100644
index 000000000000..308e859d5af7
--- /dev/null
+++ b/include/linux/drv_namespace.h
@@ -0,0 +1,189 @@
+#ifndef _LINUX_DRV_NS_H
+#define _LINUX_DRV_NS_H
+#include <linux/pid_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/notifier.h>
+#include <linux/hardirq.h>
+#include <linux/err.h>
+#define DRV_NS_TAG_LEN 64
+#define DRV_NS_DESC_MAX 32
+struct drv_namespace;
+struct drv_ns_info;
+struct drv_namespace {
+	bool active;
+	atomic_t count;
+	struct pid_namespace *pid_ns;
+	char tag[DRV_NS_TAG_LEN];
+	struct blocking_notifier_head notifiers;
+	unsigned long timestamp; /* jiffies */
+	struct mutex mutex;
+	struct drv_ns_info *info[DRV_NS_DESC_MAX];
+};
+struct drv_ns_info {
+	struct drv_namespace *drv_ns;
+	struct list_head list;
+	struct notifier_block nb;
+	atomic_t count;
+};
+extern struct drv_namespace init_drv_ns;
+extern struct net init_net;
+extern struct drv_namespace *active_drv_ns;
+struct drv_ns_ops {
+	struct drv_ns_info* (*create)(struct drv_namespace *drv_ns);
+	void (*release)(struct drv_ns_info *drv_ns_info);
+};
+/* driver namespace notifications */
+#define DRV_NS_EVENT_ACTIVATE		0x1
+#define DRV_NS_EVENT_DEACTIVATE		0x2
+extern void __put_drv_ns(struct drv_namespace *drv_ns);
+extern int get_drv_ns_idx(void);
+static inline void put_drv_ns(struct drv_namespace *drv_ns)
+{
+	if (atomic_dec_and_test(&drv_ns->count))
+		__put_drv_ns(drv_ns);
+}
+static inline struct drv_namespace *get_drv_ns(struct drv_namespace *drv_ns)
+{
+	atomic_inc(&drv_ns->count);
+	return drv_ns;
+}
+/* return the driver namespaces of the current process */
+static inline struct drv_namespace *current_drv_ns(void)
+{
+	if (in_interrupt())
+		return &init_drv_ns;
+	return current->nsproxy->drv_ns;
+}
+/* return the net namespaces of the current process */
+static inline struct net *current_net_ns(void)
+{
+	if (in_interrupt())
+		return &init_net;
+	return current->nsproxy->net_ns;
+}
+/* return whether given driver namespace is active */
+static inline bool is_active_drv_ns(struct drv_namespace *drv_ns)
+{
+	return drv_ns->active;
+}
+/* return and get the driver namespace of a given task */
+extern struct drv_namespace *get_drv_ns_by_task(struct task_struct *task);
+extern struct drv_namespace *get_drv_ns_by_vpid(pid_t vpid);
+/*
+ * set_active_drv_ns() will lock and unlock drv_namespace_lock
+ * and call all registered activate and inactivate notifiers.
+ */
+extern void set_active_drv_ns(struct drv_namespace *drv_ns);
+/* return root pid of the init process in a device namespace */
+static inline pid_t drv_ns_init_pid(struct drv_namespace *drv_ns)
+{
+	return drv_ns->pid_ns->child_reaper->pid;
+}
+/* driver namespaces: notifiers (de)registration */
+extern void drv_ns_register_notify(struct drv_namespace *drv_ns,
+				   struct notifier_block *nb);
+extern void drv_ns_unregister_notify(struct drv_namespace *drv_ns,
+				     struct notifier_block *nb);
+extern struct drv_namespace *copy_drv_ns(unsigned long flags,
+					 struct task_struct *task,
+					 struct pid_namespace *new_pidns);
+/* helpers for per-driver logic of device namespace */
+extern int register_drv_ns_ops(char *name, struct drv_ns_ops *ops);
+extern void unregister_drv_ns_ops(int ns_id);
+extern struct drv_ns_info *get_drv_ns_info(int ns_id,
+					   struct drv_namespace *drv_ns,
+					   bool lock, bool create);
+extern struct drv_ns_info *get_drv_ns_info_task(int ns_id,
+						struct task_struct *task);
+extern void put_drv_ns_info(int ns_id,
+			    struct drv_ns_info *drv_ns_info,
+			    int lock);
+extern void loop_drv_ns_info(int ns_id, void *ptr,
+			     void (*func)(struct drv_ns_info *drv_ns_info,
+					  void *ptr));
+/* macro-mania to reduce repetitive code - not for the faint of heart */
+#define i_to_x_drv_ns(i, x) container_of(i, struct x ## _drv_ns, drv_ns_info)
+#define _drv_ns_id(X) \
+	static int X ## _ns_id;
+#define _drv_ns_get(X) \
+	static inline \
+	struct X ## _drv_ns *get_ ## X ## _ns(struct drv_namespace *drv_ns) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info(X ## _ns_id, drv_ns, 1, 1); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+#define _drv_ns_find(X) \
+	static inline \
+	struct X ## _drv_ns *find_ ## X ## _ns(struct drv_namespace *drv_ns) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info(X ## _ns_id, drv_ns, 0, 0); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+#define _drv_ns_get_cur(X) \
+	static inline struct X ## _drv_ns *get_ ## X ## _ns_cur(void) \
+	{ \
+		struct drv_ns_info *info; \
+		info = get_drv_ns_info_task(X ## _ns_id, current); \
+		return info ? i_to_x_drv_ns(info, X) : NULL; \
+	}
+#define _drv_ns_put(X) \
+	static inline void put_ ## X ## _ns(struct X ## _drv_ns *X ## _ns) \
+	{ \
+		put_drv_ns_info(X ## _ns_id, &X ## _ns->drv_ns_info, 1); \
+	}
+#define _drv_ns_active(X) \
+	static inline bool \
+	is_active_ ## X ## _drv_ns(struct X ## _drv_ns *ns) \
+	{ \
+		return is_active_drv_ns(ns->drv_ns_info.drv_ns); \
+	}
+#define _drv_nb_self(X) \
+	static inline struct X ## _drv_ns * \
+	get_ ## X ## _nb_self(struct notifier_block *self) \
+	{ \
+		struct drv_ns_info *drv_ns_info; \
+		struct X ## _drv_ns *ns; \
+		drv_ns_info = container_of(self, struct drv_ns_info, nb); \
+		ns = container_of(drv_ns_info, \
+				  struct X ## _drv_ns, drv_ns_info); \
+		return ns; \
+	}
+/*
+ * Finally, this is what a driver author really needs to use:
+ * DEFINE_DRV_NS_INFO(X): X_ns_id, put_X_ns(), get_X_ns(), get_X_ns_cur()
+ *                        is_active_X_ns(), get_X_nb_self()
+ * DRV_NS_REGISTER(X): will register X with driver namespace
+ * DRV_NS_UNREGISTER(X): will unregister X from driver namespace
+ */
+#define DEFINE_DRV_NS_INFO(X) \
+	_drv_ns_id(X) \
+	_drv_ns_find(X) \
+	_drv_ns_get(X) \
+	_drv_ns_get_cur(X) \
+	_drv_ns_put(X) \
+	_drv_ns_active(X) \
+	_drv_nb_self(X)
+#define DRV_NS_REGISTER(X, s) \
+	(X ## _ns_id = register_drv_ns_ops(s, &X ## _ns_ops))
+#define DRV_NS_UNREGISTER(X) \
+	unregister_drv_ns_ops(X ## _ns_id)
+static inline int is_init_ns(struct drv_namespace *ns)
+{
+	if (ns == &init_drv_ns)
+		return 1;
+	return 0;
+}
+static inline struct nsproxy *drv_ns_nsproxy(struct drv_namespace *drv_ns)
+{
+	/*
+	 * a device namespace has a one-to-one relationship with a
+	 * PID namespace, so we know that the init task in the PID
+	 * namespace will also share our device namespace. Therefore,
+	 * we can take the nsproxy pointer from the child_reaper of
+	 * our associated PID namespace.
+	 */
+	return task_nsproxy(drv_ns->pid_ns->child_reaper);
+}
+#endif /* _LINUX_DEV_NS_H */
diff --git a/include/linux/nsproxy.h b/include/linux/nsproxy.h
index cdb171efc7cb..8f1762c5b411 100644
--- a/include/linux/nsproxy.h
+++ b/include/linux/nsproxy.h
@@ -11,6 +11,11 @@ struct ipc_namespace;
 struct pid_namespace;
 struct cgroup_namespace;
 struct fs_struct;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+struct drv_namespace;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 /*
  * A structure to contain pointers to all per-process
@@ -38,6 +43,11 @@ struct nsproxy {
 	struct time_namespace *time_ns;
 	struct time_namespace *time_ns_for_children;
 	struct cgroup_namespace *cgroup_ns;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	struct drv_namespace *drv_ns;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 };
 extern struct nsproxy init_nsproxy;
 
@@ -91,6 +101,14 @@ static inline struct cred *nsset_cred(struct nsset *set)
  *
  */
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+static inline struct nsproxy *task_nsproxy(struct task_struct *tsk)
+{
+	return rcu_dereference(tsk->nsproxy);
+}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 int copy_namespaces(unsigned long flags, struct task_struct *tsk);
 void exit_task_namespaces(struct task_struct *tsk);
 void switch_task_namespaces(struct task_struct *tsk, struct nsproxy *new);
diff --git a/init/Kconfig b/init/Kconfig
index 728f99e93031..ff44b0261b92 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1211,6 +1211,14 @@ config NET_NS
 	  Allow user space to create what appear to be multiple instances
 	  of the network stack.
 
+config DRV_NS
+	bool "drivers namespace"
+	depends on PID_NS
+	default n
+	help
+	Allow user space to create what appear to be multiple instances
+	of the drivers stack.
+
 endif # NAMESPACES
 
 config CHECKPOINT_RESTORE
diff --git a/kernel/Makefile b/kernel/Makefile
index ed1aa304b4a9..1f66ce0ad5af 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -80,6 +80,7 @@ obj-$(CONFIG_CGROUPS) += cgroup/
 obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
+obj-$(CONFIG_DRV_NS) += drv_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_IKHEADERS) += kheaders.o
 obj-$(CONFIG_SMP) += stop_machine.o
diff --git a/kernel/drv_namespace.c b/kernel/drv_namespace.c
new file mode 100644
index 000000000000..6f71089a5eea
--- /dev/null
+++ b/kernel/drv_namespace.c
@@ -0,0 +1,491 @@
+/*
+ * include/linux/drv_namespace.h
+ *
+ *
+ * Driver namespaces:
+ *
+ * The driver namespace allows a device driver to register itself and pass a
+ * pointer to its driver specific namespace structure and register notifiers
+ * which are called when the active namepace becomes inactive and when an
+ * inactive namespace becomes active.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GPL 2 license for more details.
+ * The full GPL 2 License is included in this distribution in the file called
+ * COPYING
+ */
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/pid_namespace.h>
+#include <linux/drv_namespace.h>
+#include <linux/kernel.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include "../fs/proc/internal.h"
+/* protects active namespace and switches */
+static DECLARE_RWSEM(global_drv_ns_lock);
+static void drv_ns_lock(struct drv_namespace *drv_ns)
+{
+	mutex_lock(&drv_ns->mutex);
+}
+static void drv_ns_unlock(struct drv_namespace *drv_ns)
+{
+	mutex_unlock(&drv_ns->mutex);
+}
+static struct drv_namespace *create_drv_ns(struct task_struct *task,
+					   struct pid_namespace *new_pidns)
+{
+	struct drv_namespace *drv_ns;
+	static int s_ndev;
+	drv_ns = kzalloc(sizeof(struct drv_namespace), GFP_KERNEL);
+	if (!drv_ns)
+		return ERR_PTR(-ENOMEM);
+	atomic_set(&drv_ns->count, 1);
+	BLOCKING_INIT_NOTIFIER_HEAD(&drv_ns->notifiers);
+	mutex_init(&drv_ns->mutex);
+	/* all new namespaces get a default tag */
+	memset(drv_ns->tag, 0, DRV_NS_TAG_LEN);
+	snprintf(drv_ns->tag, DRV_NS_TAG_LEN, "drv_ns.%d", ++s_ndev);
+	drv_ns->pid_ns = get_pid_ns(new_pidns);
+	return drv_ns;
+}
+struct drv_namespace *copy_drv_ns(unsigned long flags,
+				  struct task_struct *task,
+				  struct pid_namespace *new_pidns)
+{
+	struct drv_namespace *drv_ns = task->nsproxy->drv_ns;
+	/*
+	 * Couple driver namespace semantics with pid-namespace.
+	 * It's convenient, and we ran out of clone flags anyway.
+	 */
+	if (!(flags & CLONE_NEWPID))
+		return get_drv_ns(drv_ns);
+	else
+		return create_drv_ns(task, new_pidns);
+}
+void __put_drv_ns(struct drv_namespace *drv_ns)
+{
+	int n;
+	if (!drv_ns || drv_ns == &init_drv_ns)
+		return;
+	for (n = 0; n < DRV_NS_DESC_MAX; n++) {
+		if (drv_ns->info[n])
+			put_drv_ns_info(n, drv_ns->info[n], 0);
+	}
+	put_pid_ns(drv_ns->pid_ns);
+	kfree(drv_ns);
+}
+struct drv_namespace *get_drv_ns_by_task(struct task_struct *task)
+{
+	struct drv_namespace *drv_ns = NULL;
+	struct nsproxy *nsproxy;
+	rcu_read_lock();
+	nsproxy = task_nsproxy(task);
+	if (nsproxy)
+		drv_ns = get_drv_ns(nsproxy->drv_ns);
+	rcu_read_unlock();
+	return drv_ns;
+}
+struct drv_namespace *get_drv_ns_by_vpid(pid_t vpid)
+{
+	struct drv_namespace *drv_ns = NULL;
+	struct task_struct *task;
+	struct nsproxy *nsproxy;
+	rcu_read_lock();
+	task = find_task_by_pid_ns(vpid, &init_pid_ns);
+	if (task) {
+		nsproxy = task_nsproxy(task);
+		if (nsproxy)
+			drv_ns = get_drv_ns(nsproxy->drv_ns);
+	}
+	rcu_read_unlock();
+	return drv_ns;
+}
+/**
+ * notifications: activate/deactive driver namespace
+ */
+static BLOCKING_NOTIFIER_HEAD(drv_ns_notifiers);
+void drv_ns_register_notify(struct drv_namespace *drv_ns,
+			    struct notifier_block *nb)
+{
+	if (drv_ns != NULL)
+		blocking_notifier_chain_register(&drv_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_register(&drv_ns_notifiers, nb);
+}
+void drv_ns_unregister_notify(struct drv_namespace *drv_ns,
+			      struct notifier_block *nb)
+{
+	if (drv_ns != NULL)
+		blocking_notifier_chain_unregister(&drv_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_unregister(&drv_ns_notifiers, nb);
+}
+/*
+ * Helpers for per-driver logic of driver-namepace
+ *
+ * Drivers should embed 'struct drv_ns_info' in driver-specific,
+ * per-driver-namespace data, e.g.:
+ *
+ *   struct xxxx_namespace {
+ *     ... (data specific to xxxx)
+ *     struct drv_ns_info drvns_info;
+ *   };
+ *
+ * Drivers should register a 'struct drv_ns_ops' with ->create()
+ * and ->release() methods, and keep an identifier (drv_ns_xxx_id),
+ * for use by driver namespace generic code
+ *
+ * Drivers can iterate over per-driver data in all namespaces:
+ *   void loop_drv_ns_info(int drv_ns_id, void *ptr,
+ *              void (*func)(struct drv_ns_info *drv_ns_info, void *ptr))
+ *
+ * See include/linux/drv_namespace.h for helper macros to hide these details.
+ */
+struct drv_ns_desc {
+	char *name;
+	struct drv_ns_ops *ops;
+	struct mutex mutex;
+	struct list_head head;
+};
+static struct drv_ns_desc drv_ns_desc[DRV_NS_DESC_MAX];
+static DEFINE_SPINLOCK(drv_ns_desc_lock);
+int register_drv_ns_ops(char *name, struct drv_ns_ops *ops)
+{
+	struct drv_ns_desc *desc;
+	int n, ret = -ENOMEM;
+	if (!name)
+		return -EINVAL;
+	spin_lock(&drv_ns_desc_lock);
+	for (n = 0; n < DRV_NS_DESC_MAX; n++) {
+		desc = &drv_ns_desc[n];
+		if (!desc->name && ret < 0)
+			ret = n;
+		else if (desc->name && !strcmp(desc->name, name)) {
+			ret = -EBUSY;
+			break;
+		}
+	}
+	if (ret >= 0) {
+		pr_info("drv_ns: register info %s\n", name);
+		desc = &drv_ns_desc[ret];
+		desc->name = name;
+		desc->ops = ops;
+		INIT_LIST_HEAD(&desc->head);
+		mutex_init(&desc->mutex);
+	}
+	spin_unlock(&drv_ns_desc_lock);
+	return ret;
+}
+void unregister_drv_ns_ops(int drv_ns_id)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	spin_lock(&drv_ns_desc_lock);
+	pr_info("drv_ns: unregister desc %s\n", desc->name);
+	memset(&drv_ns_desc[drv_ns_id], 0, sizeof(*desc));
+	spin_unlock(&drv_ns_desc_lock);
+}
+/* this function is called with drv_ns_lock(drv_ns) held */
+static struct drv_ns_info *new_drv_ns_info(int drv_ns_id,
+					   struct drv_namespace *drv_ns)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_ns_info *drv_ns_info;
+	pr_debug("drv_ns: [0x%p] new info %s\n", drv_ns, desc->name);
+	drv_ns_info = desc->ops->create(drv_ns);
+	if (IS_ERR_OR_NULL(drv_ns_info))
+		return NULL;
+	pr_debug("drv_ns: [0x%p] got info 0x%p\n", drv_ns, drv_ns_info);
+	drv_ns->info[drv_ns_id] = drv_ns_info;
+	/* take a reference for our drv_ns_info array */
+	atomic_set(&drv_ns_info->count, 1);
+	/*
+	 * don't take a reference here: we're contained by the drv_namespace
+	 * structure, and an extra reference to that structure would create a
+	 * circular dependecy resulting in memory that can never be free'd.
+	 */
+	drv_ns_info->drv_ns = drv_ns;
+	mutex_lock(&desc->mutex);
+	list_add(&drv_ns_info->list, &desc->head);
+	mutex_unlock(&desc->mutex);
+	return drv_ns_info;
+}
+/* this function is called with drv_ns_lock(drv_ns) held */
+static void del_drv_ns_info(int drv_ns_id, struct drv_ns_info *drv_ns_info)
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_namespace *drv_ns = drv_ns_info->drv_ns;
+	pr_debug("drv_ns: [0x%p] destory info 0x%p\n", drv_ns, drv_ns_info);
+	drv_ns->info[drv_ns_id] = NULL;
+	mutex_lock(&desc->mutex);
+	list_del(&drv_ns_info->list);
+	mutex_unlock(&desc->mutex);
+	drv_ns_desc[drv_ns_id].ops->release(drv_ns_info);
+}
+/*
+ * get_drv_ns_info() is intended for internal use only. It is exported only
+ * to enable the helper macros in drv_namepsace.h to work properly.
+ *
+ * @create tells whether to create a new instance if none is found already,
+ * or just return NULL.
+ *
+ * @lock tells whether the @drv_ns should be locked against concurrent
+ * changes, or the caller is the one responsible (in which case there is
+ * not even a need for an extra refefence count).
+ */
+struct drv_ns_info *get_drv_ns_info(int drv_ns_id,
+				    struct drv_namespace *drv_ns,
+				    bool lock, bool create)
+{
+	struct drv_ns_info *drv_ns_info;
+	if (lock) {
+		down_read(&global_drv_ns_lock);
+		drv_ns_lock(drv_ns);
+	}
+	drv_ns_info = drv_ns->info[drv_ns_id];
+	if (!drv_ns_info && create)
+		drv_ns_info = new_drv_ns_info(drv_ns_id, drv_ns);
+	if (drv_ns_info) {
+		pr_debug("drv_ns: [0x%p] get info 0x%p count %d+\n", drv_ns,
+			 drv_ns_info, atomic_read(&drv_ns_info->count));
+	}
+	if (drv_ns_info && lock)
+		atomic_inc(&drv_ns_info->count);
+	if (lock) {
+		drv_ns_unlock(drv_ns);
+		up_read(&global_drv_ns_lock);
+	}
+	return drv_ns_info;
+}
+struct drv_ns_info *get_drv_ns_info_task(int drv_ns_id, struct task_struct *tsk)
+{
+	struct drv_ns_info *drv_ns_info = NULL;
+	struct drv_namespace *drv_ns;
+	drv_ns = get_drv_ns_by_task(tsk);
+	if (drv_ns) {
+		drv_ns_info = get_drv_ns_info(drv_ns_id, drv_ns, 1, 1);
+		put_drv_ns(drv_ns);
+	}
+	return drv_ns_info;
+}
+void put_drv_ns_info(int drv_ns_id, struct drv_ns_info *drv_ns_info, int lock)
+{
+	struct drv_namespace *drv_ns = drv_ns_info->drv_ns;
+	if (lock) {
+		down_read(&global_drv_ns_lock);
+		drv_ns_lock(drv_ns);
+	}
+	pr_debug("drv_ns: [0x%p] put info 0x%p count %d-\n", drv_ns,
+		 drv_ns_info, atomic_read(&drv_ns_info->count));
+	if (atomic_dec_and_test(&drv_ns_info->count))
+		del_drv_ns_info(drv_ns_id, drv_ns_info);
+	if (lock) {
+		drv_ns_unlock(drv_ns);
+		up_read(&global_drv_ns_lock);
+	}
+}
+/*
+ * @drv_ns_id: id of driver namespace subsystem
+ * @ptr: data pointer to be passed to callback
+ * @func: callback for each device namespace (atomic, must not sleep)
+ */
+void loop_drv_ns_info(int drv_ns_id, void *ptr,
+		      void (*func)(struct drv_ns_info *drv_ns_info, void *ptr))
+{
+	struct drv_ns_desc *desc = &drv_ns_desc[drv_ns_id];
+	struct drv_ns_info *drv_ns_info;
+	mutex_lock(&desc->mutex);
+	list_for_each_entry(drv_ns_info, &desc->head, list) {
+		pr_debug("drv_ns: loop info 0x%p (drv_ns 0x%p) of %s\n",
+			 drv_ns_info, drv_ns_info->drv_ns, desc->name);
+		(*func)(drv_ns_info, ptr);
+	}
+	mutex_unlock(&desc->mutex);
+}
+/**
+ * Set the active driver namespace (will call registered notifiers to
+ * allow device drivers to make device specific context store/restore)
+ *
+ * @dev_ns: The new active device namespace
+ */
+void set_active_drv_ns(struct drv_namespace *next_ns)
+{
+	struct drv_namespace *prev_ns;
+	BUG_ON(next_ns == NULL);
+	down_write(&global_drv_ns_lock);
+	pr_info("drv_ns: next_ns 0x%p\n", next_ns);
+	pr_info("drv_ns: active_drv_ns 0x%p\n", active_drv_ns);
+	if (next_ns == active_drv_ns)
+		goto done;
+	prev_ns = active_drv_ns;
+	/*
+	 * deactivate previous drv_ns:
+	 * - set active-state of previous drv_ns to false
+	 * - call previous drv_ns's notifiers with deactivate event
+	 * - call global notifiers with deactivate event
+	 */
+	drv_ns_lock(prev_ns);
+	prev_ns->active = false;
+	prev_ns->timestamp = jiffies;
+	(void) blocking_notifier_call_chain(&prev_ns->notifiers,
+					    DRV_NS_EVENT_DEACTIVATE, prev_ns);
+	(void) blocking_notifier_call_chain(&drv_ns_notifiers,
+					    DRV_NS_EVENT_DEACTIVATE, prev_ns);
+	drv_ns_unlock(prev_ns);
+	/*
+	 * activate next drv_ns:
+	 * - set active-state of next drv_ns to true
+	 * - call next drv_ns's notifiers with activate event
+	 * - call global notifiers with activate event
+	 */
+	drv_ns_lock(next_ns);
+	next_ns->active = true;
+	next_ns->timestamp = jiffies;
+	/* make the switch */
+	active_drv_ns = next_ns;
+	(void) blocking_notifier_call_chain(&next_ns->notifiers,
+					    DRV_NS_EVENT_ACTIVATE, next_ns);
+	(void) blocking_notifier_call_chain(&drv_ns_notifiers,
+					    DRV_NS_EVENT_ACTIVATE, next_ns);
+	drv_ns_unlock(next_ns);
+	get_drv_ns(next_ns);
+	put_drv_ns(prev_ns);
+	pr_info("dev_ns: activate 0x%p done\n", active_drv_ns);
+ done:
+	up_write(&global_drv_ns_lock);
+}
+/**
+ * Setup for /proc/drv_ns
+ */
+static struct proc_dir_entry *proc_drv_ns_dir;
+struct proc_dir_entry *
+create_drv_ns_proc(const char *name, const struct proc_ops *fops)
+{
+	struct proc_dir_entry *entry;
+	entry = proc_create(name, 0, proc_drv_ns_dir, fops);
+	return entry;
+}
+static int proc_active_ns_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_drv_ns_lock);
+	seq_printf(seq, "%d\n", drv_ns_init_pid(active_drv_ns));
+	up_read(&global_drv_ns_lock);
+	return 0;
+}
+static int proc_ns_tag_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_drv_ns_lock);
+	seq_printf(seq, "active: %d timestamp: %ld tag: %s\n",
+		   drv_ns_init_pid(active_drv_ns),
+		   active_drv_ns->timestamp,
+		   active_drv_ns->tag);
+	up_read(&global_drv_ns_lock);
+	return 0;
+}
+static bool drv_ns_proc_permission(void)
+{
+	return current_drv_ns() == &init_drv_ns;
+}
+static int proc_active_ns_open(struct inode *inode, struct file *file)
+{
+	if (!drv_ns_proc_permission())
+		return -EPERM;
+	return single_open(file, proc_active_ns_show, PDE(inode)->data);
+}
+static int proc_ns_tag_open(struct inode *inode, struct file *file)
+{
+	//if (!drv_ns_proc_permission())
+	//	return -EPERM;
+	return single_open(file, proc_ns_tag_show, PDE(inode)->data);
+}
+static ssize_t proc_active_ns_write(struct file *file,
+				    const char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	struct drv_namespace *drv_ns;
+	char spid[64] = {0};
+	pid_t pid = 0;
+	/* only init ns may change active ns */
+	if (!drv_ns_proc_permission())
+		return -EPERM;
+	if (count >= sizeof(spid) || count == 0)
+		return -EFAULT;
+	if (copy_from_user(spid, buffer, count))
+		return -EFAULT;
+	if (kstrtoint(spid, 10, &pid) || !pid) {
+		pr_warn("drv_ns: bad PID format '%s'\n", spid);
+		return -EINVAL;
+	}
+	drv_ns = get_drv_ns_by_vpid(pid);
+	if (!drv_ns) {
+		pr_warn("drv_ns: non-existing PID %d\n", pid);
+		return -EINVAL;
+	}
+	set_active_drv_ns(drv_ns);
+	put_drv_ns(drv_ns);
+	return count;
+}
+static ssize_t proc_ns_tag_write(struct file *file,
+				 const char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	char name[DRV_NS_TAG_LEN] = {0};
+	if (count >= sizeof(name) || count == 0)
+		return -EFAULT;
+	if (copy_from_user(name, buffer, count))
+		return -EFAULT;
+	memset(current_drv_ns()->tag, 0, DRV_NS_TAG_LEN);
+	strcpy(current_drv_ns()->tag, name);
+	pr_info("drv_ns: tag = %s \n", current_drv_ns()->tag);
+	return count;
+}
+static const struct proc_ops active_ns_fileops = {
+	.proc_open = proc_active_ns_open,
+	.proc_read = seq_read,
+	.proc_write = proc_active_ns_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+static const struct proc_ops ns_tag_fileops = {
+	.proc_open = proc_ns_tag_open,
+	.proc_read = seq_read,
+	.proc_write = proc_ns_tag_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+static __init int drv_namespace_init(void)
+{
+	struct proc_dir_entry *entry;
+	proc_drv_ns_dir = proc_mkdir("drv_ns", NULL);
+	if (!proc_drv_ns_dir) {
+		pr_err("[drv_namespace_init] proc_mkdir fail!\n");
+		return -ENOMEM;
+	}
+	entry = proc_create("active_ns_pid", 0644, proc_drv_ns_dir,
+			    &active_ns_fileops);
+	if (!entry) {
+		pr_err("[drv_namespace_init] proc_create active_ns_pid fail!\n");
+		goto out_fail_active_ns;
+	}
+	entry = proc_create("ns_tag", 0644, proc_drv_ns_dir,
+			    &ns_tag_fileops);
+	if (!entry) {
+		pr_err("[drv_namespace_init] proc_create ns_tag fail!\n");
+		goto out_fail_ns_tag;
+	}
+	pr_info("[drv_namespace_init] success exit...\n");
+	return 0;
+out_fail_ns_tag:
+	remove_proc_entry("active_ns_pid", proc_drv_ns_dir);
+out_fail_active_ns:
+	remove_proc_entry("drv_ns", NULL);
+	return -ENOMEM;
+}
+device_initcall(drv_namespace_init);
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index 12dd41b39a7f..33572957a7ee 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -26,6 +26,11 @@
 #include <linux/syscalls.h>
 #include <linux/cgroup.h>
 #include <linux/perf_event.h>
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 static struct kmem_cache *nsproxy_cachep;
 
@@ -47,6 +52,11 @@ struct nsproxy init_nsproxy = {
 	.time_ns		= &init_time_ns,
 	.time_ns_for_children	= &init_time_ns,
 #endif
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	.drv_ns			= &init_drv_ns,
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 };
 
 static inline struct nsproxy *create_nsproxy(void)
@@ -121,8 +131,26 @@ static struct nsproxy *create_new_namespaces(unsigned long flags,
 	}
 	new_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	new_nsp->drv_ns = copy_drv_ns(flags, tsk, new_nsp->pid_ns_for_children);
+	if (IS_ERR(new_nsp->drv_ns)) {
+		err = PTR_ERR(new_nsp->drv_ns);
+		goto out_drv;
+	}
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	return new_nsp;
 
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+out_drv:
+	if (new_nsp->time_ns_for_children)
+		put_time_ns(new_nsp->time_ns_for_children);
+	if (new_nsp->time_ns)
+		put_time_ns(new_nsp->time_ns);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 out_time:
 	put_net(new_nsp->net_ns);
 out_net:
@@ -206,6 +234,12 @@ void free_nsproxy(struct nsproxy *ns)
 		put_time_ns(ns->time_ns_for_children);
 	put_cgroup_ns(ns->cgroup_ns);
 	put_net(ns->net_ns);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	if (ns->drv_ns)
+		put_drv_ns(ns->drv_ns);
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	kmem_cache_free(nsproxy_cachep, ns);
 }
 
diff --git a/kernel/power/wakelock.c b/kernel/power/wakelock.c
index 52571dcad768..1de3628d7dd3 100644
--- a/kernel/power/wakelock.c
+++ b/kernel/power/wakelock.c
@@ -19,6 +19,11 @@
 #include <linux/rbtree.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+#include <linux/drv_namespace.h>
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 
 #include "power.h"
 
@@ -28,6 +33,11 @@ struct wakelock {
 	char			*name;
 	struct rb_node		node;
 	struct wakeup_source	*ws;
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	struct drv_namespace * drv_ns;
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 #ifdef CONFIG_PM_WAKELOCKS_GC
 	struct list_head	lru;
 #endif
@@ -45,7 +55,13 @@ ssize_t pm_show_wakelocks(char *buf, bool show_active)
 
 	for (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {
 		wl = rb_entry(node, struct wakelock, node);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (wl->ws->active == show_active && wl->drv_ns == current_drv_ns())
+#else
 		if (wl->ws->active == show_active)
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 			len += sysfs_emit_at(buf, len, "%s ", wl->name);
 	}
 
@@ -157,7 +173,13 @@ static struct wakelock *wakelock_lookup_add(const char *name, size_t len,
 		parent = *node;
 		wl = rb_entry(*node, struct wakelock, node);
 		diff = strncmp(name, wl->name, len);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+		if (diff == 0 && wl->drv_ns == current_drv_ns()) {
+#else
 		if (diff == 0) {
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 			if (wl->name[len])
 				diff = -1;
 			else
@@ -186,6 +208,11 @@ static struct wakelock *wakelock_lookup_add(const char *name, size_t len,
 	}
 
 	wl->ws = wakeup_source_register(NULL, wl->name);
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#ifdef CONFIG_DRV_NS
+	wl->drv_ns = current_drv_ns();
+#endif
+/* End: xdja.lxl modify for dual-system on 20231026 */
 	if (!wl->ws) {
 		kfree(wl->name);
 		kfree(wl);
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 1235854233c9..52045cea4530 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -116,12 +116,16 @@ static int __init enforcing_setup(char *str)
 {
 	unsigned long enforcing;
 	if (!kstrtoul(str, 0, &enforcing))
-		selinux_enforcing_boot = enforcing ? 1 : 0;
+        /* Begin: xdja.lxl modify for dual-system on 20231026 */
+		selinux_enforcing_boot = enforcing ? 0 : 0;
+        /* End: xdja.lxl modify for dual-system on 20231026 */
 	return 1;
 }
 __setup("enforcing=", enforcing_setup);
 #else
-#define selinux_enforcing_boot 1
+/* Begin: xdja.lxl modify for dual-system on 20231026 */
+#define selinux_enforcing_boot 0
+/* End: xdja.lxl modify for dual-system on 20231026 */
 #endif
 
 int selinux_enabled_boot __initdata = 1;
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index d893c2280f59..4bc278b5239f 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -159,7 +159,9 @@ static ssize_t sel_write_enforce(struct file *file, const char __user *buf,
 	if (sscanf(page, "%d", &new_value) != 1)
 		goto out;
 
-	new_value = !!new_value;
+	/* Begin: xdja.lxl modify for dual-system on 20231026 */
+	new_value = 0;
+	/* End: xdja.lxl modify for dual-system on 20231026 */
 
 	old_value = enforcing_enabled(state);
 	if (new_value != old_value) {
